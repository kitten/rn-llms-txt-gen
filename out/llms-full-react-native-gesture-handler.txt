# react-native-gesture-handler

### Overview

The **React Native Gesture Handler** offers a declarative API that exposes the native touch and gesture systems to React Native applications.

#### How It Works

Explore its functionality by tapping and dragging circles to understand various gestures.

### Reasons to Use Gesture Handler

- **Native Gesture Recognizers**: Utilizes platform-specific APIs for handling touch streams on the UI thread.

- **Native Components**: Includes components like `SwipeableRow` or `Drawer` designed for optimal interactions.

- **High Performance (120 FPS)**: Integrates with Reanimated to enable smooth gesture-based experiences at up to 120 frames per second.

For more details, refer to the latest article on Gesture Handler features and check out related blog posts.

### About Software Mansion

Software Mansion is a team of React Native Core Contributors and experts specializing in resolving various React Native challenges. Whether you need assistance with gestures, animations, or general development, we are here to help.

## Installation

### Requirements

The `react-native-gesture-handler` library supports the three most recent minor versions of `react-native`. Below is a compatibility table:

|Gesture Handler Version|React Native Version|
|-|-|
|2.24.0+|0.75.0+|
|2.21.0+|0.74.0+|
|2.18.0+|0.73.0+|
|2.16.0+|0.68.0+|
|2.14.0+|0.67.0+|
|2.10.0+|0.64.0+|
|2.0.0+|0.63.0+|

To fully leverage touch events, ensure you are using `react-native-reanimated` version 2.3.0 or newer.

#### Installation Steps

##### Step 1: Install the Package

Choose one of the following methods to install:

- **EXPO**

  ```bash
  npx expo install react-native-gesture-handler
  ```

- **NPM**

  ```bash
  npm install react-native-gesture-handler
  ```

- **YARN**

  ```bash
  yarn add react-native-gesture-handler
  ```

##### Step 2: Wrap Your App with `GestureHandlerRootView`

```typescript
import { GestureHandlerRootView } from 'react-native-gesture-handler';

export default function App() {
  return (
    <GestureHandlerRootView>
      <ActualApp />
    </GestureHandlerRootView>
  );
}
```

- If no styles are provided, it defaults to `flex: 1`. Ensure custom styles include `flex: 1` to render your app correctly.
- Place `GestureHandlerRootView` as close to the root of your application as possible. Gestures outside this view won't be recognized.

**Tip:** For component libraries using gesture handlers, wrap the library code with `GestureHandlerRootView`.

##### Step 3: Platform-Specific Setup

###### Expo Development Build

For Expo development builds, update native code in iOS and Android directories:

```bash
npx expo prebuild
```

###### Android

No additional steps are required for Android. For gestures within Modals, wrap the content with `GestureHandlerRootView`:

```typescript
import { Modal } from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';

export function CustomModal({ children, ...rest }) {
  return (
    <Modal {...rest}>
      <GestureHandlerRootView>
        {children}
      </GestureHandlerRootView>
    </Modal>
  );
}
```

###### Kotlin

To specify a Kotlin version for Gesture Handler on Android, set the `kotlinVersion` in your `android/build.gradle`:

```groovy
buildscript {
    ext {
        kotlinVersion = "1.6.21"
    }
}
```

###### iOS

Before running your app during development, install pods:

```bash
cd ios && pod install && cd ..
```

###### Web

No additional configuration is needed for the web. From version 2.10.0, a new implementation is enabled by default. Verify gesture behavior matches native platforms. To revert to the legacy implementation, add this at the start of your `index.js`:

```typescript
import { enableLegacyWebImplementation } from "react-native-gesture-handler"

enableLegacyWebImplementation(true)
```

Adapting to the new implementation is recommended as the legacy version will be deprecated in future releases.

###### With wix/react-native-navigation

When using native navigation libraries like `wix/react-native-navigation`, ensure each screen is wrapped with `GestureHandlerRootView` using `gestureHandlerRootHOC`. This can be done during screen registration:

```typescript
import { gestureHandlerRootHOC } from "react-native-gesture-handler"
import { Navigation } from "react-native-navigation"
import FirstTabScreen from "./FirstTabScreen"
import SecondTabScreen from "./SecondTabScreen"
import PushedScreen from "./PushedScreen"

export function registerScreens() {
  Navigation.registerComponent(
    "example.FirstTabScreen",
    () => gestureHandlerRootHOC(FirstTabScreen),
    () => FirstTabScreen
  )
  Navigation.registerComponent(
    "example.SecondTabScreen",
    () => gestureHandlerRootHOC(SecondTabScreen),
    () => SecondTabScreen
  )
  Navigation.registerComponent(
    "example.PushedScreen",
    () => gestureHandlerRootHOC(PushedScreen),
    () => PushedScreen
  )
}
```

Ensure each screen in your app is wrapped with `GestureHandlerRootView` as native navigation libraries map each screen to a separate root view.

## Rotation gesture

A continuous gesture capable of recognizing and tracking rotation movements. Activation occurs when fingers are placed on the screen and move in a specific manner.

The gesture callback facilitates ongoing monitoring, providing details such as the degree of rotation, the focal point (anchor), and instantaneous velocity.

### Example

```typescript
import { StyleSheet } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

export default function App() {
  const rotation = useSharedValue(1);
  const savedRotation = useSharedValue(1);

  const rotationGesture = Gesture.Rotation()
    .onUpdate((e) => {
      rotation.value = savedRotation.value + e.rotation;
    })
    .onEnd(() => {
      savedRotation.value = rotation.value;
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotateZ: `${(rotation.value / Math.PI) * 180}deg` }],
  }));

  return (
    <GestureDetector gesture={rotationGesture}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
    borderRadius: 20,
    marginBottom: 30,
  },
});
```

### Configuration

#### Properties Common to All Gestures:

- **`enabled(value: boolean)`**: Determines if the handler analyzes touch events. Default is `true`. Setting it to `false` ensures the handler never becomes `ACTIVE`.

- **`shouldCancelWhenOutside(value: boolean)`**: Cancels or fails recognition when fingers leave the view area. Defaults vary by gesture type.

- **`hitSlop(settings)`**: Adjusts the active area for gesture recognition. Supports negative values and specific boundary adjustments (`left`, `right`, `top`, `bottom`, `horizontal`, `vertical`, `width`, `height`). Primarily reduces the activation area, with Android supporting positive expansions within parent bounds.

- **`withRef(ref)`**: Sets a ref to the gesture object for interoperability with older APIs.

- **`withTestId(testID)`**: Assigns a `testID` for querying in tests.

- **`cancelsTouchesInView(value)`** (**iOS only**): Cancels touches for native UI components when active. Default is `true`.

- **`runOnJS(value: boolean)`**: Determines if callbacks run on the JS thread instead of the UI thread. Defaults to `false`.

- **`simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`**: Marks gestures to be recognized simultaneously without composing them.

- **`requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`**: Requires another gesture to fail before activation.

- **`blocksExternalGesture(otherGesture1, otherGesture2, ...)`**: Delays other gestures until this one fails or doesn't start. Marks relations without composing them.

- **`activeCursor(value)`** (Web only): Specifies the cursor style when active. Supports CSS cursor values. Default is `"auto"`.

#### Properties Common to All Continuous Gestures:

- **`manualActivation(value: boolean)`**: Disables automatic activation, allowing manual state management.

### Callbacks

#### Common to All Gestures:

- **`onBegin(callback)`**: Triggered when the gesture handler starts receiving touches but hasn't yet recognized a gesture.

- **`onStart(callback)`**: Called when the gesture is recognized and transitions to an active state.

- **`onEnd(callback)`**: Invoked when the recognized gesture finishes, provided it was previously active.

- **`onFinalize(callback)`**: Executed upon finalizing gesture handling, whether recognized or failed.

- **`onTouchesDown(callback)`**: Triggered each time a finger touches the screen.

- **`onTouchesMove(callback)`**: Called whenever a finger moves on the screen.

- **`onTouchesUp(callback)`**: Invoked when a finger is lifted from the screen.

- **`onTouchesCancelled(callback)`**: Executed when touch tracking stops, such as gesture completion.

#### Common to All Continuous Gestures:

- **`onUpdate(callback)`**: Called with every update during active gesture recognition.

- **`onChange(callback)`**: Triggered with updates, providing change information relative to the last event.

### Event Data

#### Specific to `RotationGesture`:

- **`rotation`**: Rotation amount in radians from the focal point (anchor).

- **`velocity`**: Instantaneous velocity in points per second.

- **`anchorX`**: X coordinate of the gesture's central focal point (anchor) in points.

- **`anchorY`**: Y coordinate of the gesture's central focal point (anchor) in points.

#### Common to All Gestures:

- **`state`**: Current handler state, expressed as a constant from the `State` object.

- **`numberOfPointers`**: Number of fingers currently on the screen.

- **`pointerType`**: Type of pointer device, represented by the `PointerType` enum (`TOUCH`, `STYLUS`, `MOUSE`, `KEY`, `OTHER`).

## Pinch gesture

A continuous gesture that recognizes pinch gestures, allowing for tracking the distance between two fingers to scale or zoom content. The gesture activates when fingers are placed on the screen and change their position. A callback can be used for continuous tracking of the pinch gesture, providing information about velocity, anchor (focal) point, and scale.

The distance between the fingers is reported as a scale factor. At the beginning of the gesture, the scale factor is 1.0. As the distance between two fingers increases, the scale factor increases proportionally; it decreases as the distance reduces. Pinch gestures are commonly used to change the size of objects or content onscreen, such as adjusting the zoom level of map views.

### Example

```typescript
import { StyleSheet } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

export default function App() {
  const scale = useSharedValue(1);
  const savedScale = useSharedValue(1);

  const pinchGesture = Gesture.Pinch()
    .onUpdate((e) => {
      scale.value = savedScale.value * e.scale;
    })
    .onEnd(() => {
      savedScale.value = scale.value;
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  return (
    <GestureDetector gesture={pinchGesture}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
    borderRadius: 20,
    marginBottom: 30,
  },
});
```

### Configuration

#### Properties Common to All Gestures:

|Property|Description|
|-|-|
|`enabled(value: boolean)`|Indicates whether the handler should analyze touch events. Default is `true`. If set to `false`, the handler's state will never become `ACTIVE`.|
|`shouldCancelWhenOutside(value: boolean)`|When `true`, cancels or fails recognition if a finger leaves the view area. Defaults vary by gesture type; most are `false` except for `LongPressGesture` and `TapGesture`, which default to `true`.|
|`hitSlop(settings)`|Controls the activation area of the gesture within the connected view. Negative numbers reduce bounds evenly, while objects can specify reductions per side or edge. Positive values on Android expand beyond view bounds but not past parent view bounds. Use React Native's View hitSlop for cross-platform support.|
|`withRef(ref)`|Sets a ref to the gesture object for interoperability with older APIs.|
|`withTestId(testID)`|Assigns a `testID` property for querying in tests.|
|`cancelsTouchesInView(value)` (**iOS only**)|When `true`, cancels touches for native UI components when active. Default is `true`.|
|`runOnJS(value: boolean)`|Determines if callbacks run on the JS thread (`true`) or UI thread (`false`). Defaults to `false` with `react-native-reanimated`.|
|`simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`|Marks gestures for simultaneous recognition without composing them. Requires additional detectors for recognition.|
|`requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`|Adds a relation requiring another gesture to fail before activation. Does not compose gestures; requires additional detectors.|
|`blocksExternalGesture(otherGesture1, otherGesture2, ...)`|Makes other gestures wait until this one fails or doesn't start. Marks relations without composing gestures; requires additional detectors.|
|`activeCursor(value)` (**Web only**)|Specifies the cursor when the gesture activates. Supports CSS cursor values (e.g., `"grab"`, `"zoom-in"`). Default is `"auto"`.|

#### Properties Common to All Continuous Gestures:

- **`manualActivation(value: boolean)`**: When `true`, prevents automatic activation even if criteria are met, allowing manual state manipulation.

### Callbacks

#### Callbacks Common to All Gestures:

|Callback|Description|
|-|-|
|`onBegin(callback)`|Called when the gesture handler starts receiving touches but is not yet active.|
|`onStart(callback)`|Called when the gesture is recognized and transitions to an active state.|
|`onEnd(callback)`|Called when a recognized gesture finishes, provided it was previously active.|
|`onFinalize(callback)`|Called when handling finalizesâ€”either recognition completes or fails.|
|`onTouchesDown(callback)`|Triggered every time a finger is placed on the screen.|
|`onTouchesMove(callback)`|Triggered every time a finger moves on the screen.|
|`onTouchesUp(callback)`|Triggered every time a finger is lifted from the screen.|
|`onTouchesCancelled(callback)`|Triggered when a finger stops being tracked, such as when a gesture finishes.|

#### Callbacks Common to All Continuous Gestures:

- **`onUpdate(callback)`**: Called with each update while the gesture is active.
- **`onChange(callback)`**: Called with updates during activity, providing change information relative to the last event.

### Event Data

#### Attributes Specific to `PinchGesture`:

|Attribute|Description|
|-|-|
|`scale`|Scale factor relative to touch points in screen coordinates.|
|`velocity`|Velocity of the gesture at the current moment, expressed as scale factor per second.|
|`focalX`|X-axis position of the center anchor point of the gesture in points.|
|`focalY`|Y-axis position of the center anchor point of the gesture in points.|

#### Attributes Common to All Gestures:

|Attribute|Description|
|-|-|
|`state`|Current state of the handler, expressed as a constant from the `State` object.|
|`numberOfPointers`|Number of pointers (fingers) currently on the screen.|
|`pointerType`|Type of pointer device in use, represented by the `PointerType` enum: `TOUCH`, `STYLUS`, `MOUSE`, `KEY`, or `OTHER`.|

## Force Touch Gesture

A continuous gesture that recognizes the force of a touch, allowing for tracking pressure on some iOS devices. The gesture activates when the touch force is greater than or equal to `minForce` and fails if it exceeds `maxForce`. A callback can be used for continuous tracking of touch pressure, providing information for one finger (the first one).

At the beginning of the gesture, the pressure factor is 0.0, increasing proportionally with pressure up to a maximum of 1.0.

There's no implementation on Android; it simply renders children without any wrappers. Since this behavior is only available on some iOS devices, this gesture should not be used for defining crucial behaviors. Use it as an additional improvement and ensure all features are accessible without this gesture.

### Reference

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const forceTouch = Gesture.ForceTouch();

  return (
    <GestureDetector gesture={forceTouch}>
      <View />
    </GestureDetector>
  );
}
```

### Configuration

#### Properties Specific to `ForceTouchGesture`:

|Property|Description|
|-|-|
|`minForce(value: number)`|Minimal pressure required for activation. Range `[0.0, 1.0]`. Default is `0.2`.|
|`maxForce(value: number)`|Maximal pressure before gesture fails. Range `[0.0, 1.0]`.|
|`feedbackOnActivation(value: boolean)`|Defines if haptic feedback occurs on activation.|

#### Properties Common to All Gestures:

|Property|Description|
|-|-|
|`enabled(value: boolean)`|Indicates whether the handler analyzes touch events. Default is `true`.|
|`shouldCancelWhenOutside(value: boolean)`|Cancels recognition if finger leaves view area. Defaults vary by handler type.|
|`hitSlop(settings)`|Controls gesture activation area within the view. Supports negative values for reduction.|
|`withRef(ref)`|Sets a ref to the gesture object for interoperability with old API.|
|`withTestId(testID)`|Sets a `testID` property for querying in tests.|
|`cancelsTouchesInView(value)` (**iOS only**)|Cancels touches for native UI components when active. Default is `true`.|
|`runOnJS(value: boolean)`|Runs callbacks on JS thread if true, otherwise on the UI thread. Defaults to `false`.|
|`simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`|Marks relation for simultaneous recognition with other gestures.|
|`requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`|Requires another gesture to fail before activation.|
|`blocksExternalGesture(otherGesture1, otherGesture2, ...)`|Makes other gestures wait until this one fails or doesn't start.|
|`activeCursor(value)` (**Web only**)|Specifies cursor when gesture activates. Supports CSS cursor values. Default is `"auto"`.|

#### Properties Common to All Continuous Gestures:

|Property|Description|
|-|-|
|`manualActivation(value: boolean)`|When true, the handler does not activate automatically; state must be manipulated manually.|

### Callbacks

#### Callbacks Common to All Gestures:

|Callback|Description|
|-|-|
|`onBegin(callback)`|Called when gesture handling starts receiving touches.|
|`onStart(callback)`|Called when the gesture is recognized and transitions to active state.|
|`onEnd(callback)`|Called when a recognized gesture finishes, if previously in active state.|
|`onFinalize(callback)`|Called when gesture handling finalizes (recognized or failed).|
|`onTouchesDown(callback)`|Called every time a finger is placed on the screen.|
|`onTouchesMove(callback)`|Called every time a finger moves on the screen.|
|`onTouchesUp(callback)`|Called every time a finger is lifted from the screen.|
|`onTouchesCancelled(callback)`|Called when a finger stops being tracked, e.g., gesture finishes.|

#### Callbacks Common to All Continuous Gestures:

|Callback|Description|
|-|-|
|`onUpdate(callback)`|Called every time the gesture receives an update while active.|
|`onChange(callback)`|Called with information about changes in value relative to the last event.|

### Event Data

#### Attributes Specific to `ForceTouchGesture`:

|Attribute|Description|
|-|-|
|`force`|The pressure of a touch.|

#### Attributes Common to All Gestures:

|Attribute|Description|
|-|-|
|`state`|Current state of the handler, expressed as one of the constants in the `State` object.|
|`numberOfPointers`|Number of pointers (fingers) currently on the screen.|
|`pointerType`|Type of pointer device in use, represented by the `PointerType` enum (`TOUCH`, `STYLUS`, etc.).|

## Buttons

The Gesture Handler library provides native components that function as buttons, serving as alternatives to `TouchableHighlight` or `TouchableOpacity` from React Native (RN) core. These gesture handler buttons recognize touches natively, ensuring a deterministic recognition process and enabling highly performant ripple effects on Android (`TouchableNativeFeedback` requires touch events to return to JavaScript before updating the ripple effect, causing lag on older devices). Additionally, they offer native and platform-specific interactions for buttons within scrollable containers, slightly delaying interaction to prevent premature highlighting during flinging.

The library currently exposes three components that render native touchable elements:

- `BaseButton`
- `RectButton`
- `BorderlessButton`

All buttons are wrapped with `NativeViewGestureHandler`, allowing the application of common gesture handler properties and additional properties specific to `NativeViewGestureHandler`.

**IMPORTANT**: To ensure button accessibility, wrap children in a `View` with `accessible` and `accessibilityRole="button"` props. Example:

```tsx
// Not accessible:
const NotAccessibleButton = () => (
  <RectButton onPress={this._onPress}>
    <Text>Foo</Text>
  </RectButton>
)

// Accessible:
const AccessibleButton = () => (
  <RectButton onPress={this._onPress}>
    <View accessible accessibilityRole="button">
      <Text>Bar</Text>
    </View>
  </RectButton>
)
```

This is applicable to both iOS and Android platforms. On iOS, inaccessible buttons cannot be selected; on Android, they cannot be clicked in accessibility mode.

### `BaseButton`

`BaseButton` can serve as a base class for implementing custom interactions when the button is pressed.

#### Properties specific to `BaseButton`:

- **onActiveStateChange**: A function triggered when the button transitions between active and inactive states. It receives the active state as a boolean parameter.

- **onPress**: A function triggered upon pressing the button, similar to `onPress` in `TouchableHighlight`.

- **onLongPress**: A function triggered if the button is pressed for at least `delayLongPress` milliseconds.

- **rippleColor** (**Android only**): Defines the color of the native ripple animation used since API level 21.

- **exclusive**: Determines whether more than one button can be pressed simultaneously. Default is `true`.

- **delayLongPress**: The delay, in milliseconds, before the `onLongPress` callback is invoked. Default is 600.

### `RectButton`

Use `RectButton` for rectangular elements or content blocks that are pressable, such as table rows or buttons with text and icons. It provides platform-specific interactions: a rectangular ripple on Android, background highlighting on iOS, and similar effects on older Android versions. In addition to `BaseButton` properties, it includes:

#### Properties specific to `RectButton`:

- **underlayColor**: The background color dimmed when the button is active.

- **activeOpacity** (**iOS only**): The opacity applied to the underlay during the active state.

### `BorderlessButton`

Use `BorderlessButton` for simple icon-only or text-only buttons. Interaction varies by platform: a borderless ripple on Android and background dimming on iOS, similar to `TouchableOpacity`. In addition to `BaseButton` properties, it includes:

#### Properties specific to `BorderlessButton`:

- **borderless** (**Android only**): Set to `false` if the ripple should be confined within view bounds.

- **activeOpacity** (**iOS only**): The opacity applied during the active state.

### Design Patterns

These components are not designed to behave identically across platforms but rather to handle similar behaviors on iOS and Android, considering their design concepts. For platform-specific design patterns, refer to official Apple documentation and Material.io guidelines.

The library supports using native components with native feedback in appropriate situations. If a custom design approach is unnecessary, `RectButton` and `BorderlessButton` are sufficient. Otherwise, rely on `BaseButton`, which can be customized for specific needs.

#### Common Use Cases

- **Lists and Action Buttons**: Use `RectButton` for list items or action buttons that appear as separate UI blocks. It changes opacity on click and supports a ripple effect on Android. Emphasis is achieved through fill color or transparency, with outlined buttons used for medium emphasis.

- **Icon or Text Only Buttons**: Use `BorderlessButton` for simple icon-only or text-only buttons. Interaction varies by platform: borderless ripple on Android and dimming on iOS. Suitable for non-crucial actions.

#### `PureNativeButton`

For more complex button implementations, use `PureNativeButton` to access the native component. It is generally not recommended but can be useful when wrapping with Animated or Reanimated:

```tsx
import {
  createNativeWrapper,
  PureNativeButton,
} from "react-native-gesture-handler"
import Animated from "react-native-reanimated"

const { event, Value, createAnimatedComponent } = Animated

const AnimatedRawButton = createNativeWrapper(
  createAnimatedComponent(PureNativeButton),
  {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: false,
  }
)

export default class App extends React.Component {
  constructor(props) {
    super(props)
    const state = new Value()
    this._onGestureEvent = event([
      {
        nativeEvent: { state },
      },
    ])
  }

  render() {
    return <AnimatedRawButton onHandlerStateChange={this._onGestureEvent} />
  }
}
```

## Pan gesture

A pan gesture recognizes and tracks a continuous dragging motion. It activates when a finger touches the screen and moves beyond an initial distance.

Configurations include setting a minimum starting distance, specifying vertical or horizontal detection, and defining the number of fingers required for activation (supporting multifinger swipes). A callback function can be used to continuously track the gesture's movement, providing details such as XY translation from the start point and instantaneous velocity.

### Example

```typescript
import { StyleSheet } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  withTiming,
  useAnimatedStyle,
} from 'react-native-reanimated';

const END_POSITION = 200;

export default function App() {
  const onLeft = useSharedValue(true);
  const position = useSharedValue(0);

  const panGesture = Gesture.Pan()
    .onUpdate((e) => {
      if (onLeft.value) {
        position.value = e.translationX;
      } else {
        position.value = END_POSITION + e.translationX;
      }
    })
    .onEnd((e) => {
      if (position.value < END_POSITION / 2) {
        withTiming(0, { duration: 200 }, () => {
          onLeft.value = true;
        });
      } else {
        withTiming(END_POSITION, { duration: 200 }, () => {
          onLeft.value = false;
        });
      }
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: position.value }],
  }));

  return (
    <GestureDetector gesture={panGesture}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    width: 100,
    height: 100,
    backgroundColor: 'blue',
  },
});
```

### Multifinger Pan Gestures

Multifinger pan gestures can be configured by setting the `minPointers` and `maxPointers` properties. This allows for specifying the minimum and maximum number of fingers required to activate the gesture.

```typescript
const multiFingerPanGesture = Gesture.Pan().minPointers(2).maxPointers(3)
```

### Event Data

#### Pan Gesture Specific Attributes

- `translationX`: Accumulated translation along the X-axis, in points.
- `translationY`: Accumulated translation along the Y-axis, in points.
- `velocityX`: Current velocity along the X-axis, in points per second.
- `velocityY`: Current velocity along the Y-axis, in points per second.
- `x`: X-coordinate of the pointer relative to the view, in points.
- `y`: Y-coordinate of the pointer relative to the view, in points.
- `absoluteX`: X-coordinate of the pointer relative to the window, in points.
- `absoluteY`: Y-coordinate of the pointer relative to the window, in points.
- `stylusData`: Additional stylus information including tilt angles and pressure.

#### Common Attributes for All Gestures

- `state`: Current state of the handler (e.g., active, failed).
- `numberOfPointers`: Number of fingers currently on the screen.
- `pointerType`: Type of pointer device (e.g., touch, stylus).

### Callbacks

#### Common to All Gestures

- `onBegin(callback)`: Called when touches begin but before activation.
- `onStart(callback)`: Called when the gesture is recognized and becomes active.
- `onEnd(callback)`: Called when an active gesture ends.
- `onFinalize(callback)`: Called after a gesture is finalized (recognized or failed).
- `onTouchesDown(callback)`: Triggered when a finger touches down.
- `onTouchesMove(callback)`: Triggered when a finger moves on the screen.
- `onTouchesUp(callback)`: Triggered when a finger lifts off the screen.
- `onTouchesCancelled(callback)`: Triggered when tracking stops (e.g., gesture ends).

#### Common to Continuous Gestures

- `onUpdate(callback)`: Called with each update during an active gesture.
- `onChange(callback)`: Called with changes in value relative to the last event.

### Configuration Properties

#### Pan Gesture Specific

- `minPointers(min: number)`: Minimum fingers required for activation.
- `maxPointers(max: number)`: Maximum fingers allowed for activation.

#### Common to All Gestures

- `manualActivation(value: boolean)`: If true, manual state management is needed.
- `simultaneousWithExternalGesture(otherGestures...)`: Recognizes gestures simultaneously with others.
- `requireExternalGestureToFail(otherGestures...)`: Requires other gestures to fail before activation.
- `blocksExternalGesture(otherGestures...)`: Blocks other gestures until this one fails or doesn't start.

#### Platform-Specific

- **iOS**: `cancelsTouchesInView(value: boolean)`: Cancels touches for native UI components when active.
- **Web**: `activeCursor(cursorStyle: string)`: Sets the cursor style during activation.

## Buttons

The Gesture Handler library provides native components that function as buttons, serving as alternatives to `TouchableHighlight` or `TouchableOpacity` from React Native (RN) core. These gesture handler buttons recognize touches natively, ensuring a deterministic recognition process and enabling highly performant ripple effects on Android (`TouchableNativeFeedback` requires touch events to return to JavaScript before updating the ripple effect, causing lag on older devices). Additionally, they offer native and platform-specific interactions for buttons within scrollable containers, slightly delaying interaction to prevent premature highlighting during flinging.

The library currently exposes three components that render native touchable elements:

- `BaseButton`
- `RectButton`
- `BorderlessButton`

All buttons are wrapped with `NativeViewGestureHandler`, allowing the application of common gesture handler properties and additional properties specific to `NativeViewGestureHandler`.

**IMPORTANT**: To ensure button accessibility, wrap children in a `View` with `accessible` and `accessibilityRole="button"` props. Example:

```tsx
// Not accessible:
const NotAccessibleButton = () => (
  <RectButton onPress={this._onPress}>
    <Text>Foo</Text>
  </RectButton>
)

// Accessible:
const AccessibleButton = () => (
  <RectButton onPress={this._onPress}>
    <View accessible accessibilityRole="button">
      <Text>Bar</Text>
    </View>
  </RectButton>
)
```

This is applicable to both iOS and Android platforms. On iOS, inaccessible buttons cannot be selected; on Android, they cannot be clicked in accessibility mode.

### `BaseButton`

`BaseButton` can serve as a base class for implementing custom interactions when the button is pressed.

#### Properties specific to `BaseButton`:

- **onActiveStateChange**: A function triggered when the button transitions between active and inactive states. It receives the active state as a boolean parameter.

- **onPress**: A function triggered upon pressing the button, similar to `onPress` in `TouchableHighlight`.

- **onLongPress**: A function triggered if the button is pressed for at least `delayLongPress` milliseconds.

- **rippleColor** (**Android only**): Defines the color of the native ripple animation used since API level 21.

- **exclusive**: Determines whether more than one button can be pressed simultaneously. Default is `true`.

- **delayLongPress**: The delay, in milliseconds, before the `onLongPress` callback is invoked. Default is 600.

### `RectButton`

Use `RectButton` for rectangular elements or content blocks that are pressable, such as table rows or buttons with text and icons. It provides platform-specific interactions: a rectangular ripple on Android, background highlighting on iOS, and similar effects on older Android versions. In addition to `BaseButton` properties, it includes:

#### Properties specific to `RectButton`:

- **underlayColor**: The background color dimmed when the button is active.

- **activeOpacity** (**iOS only**): The opacity applied to the underlay during the active state.

### `BorderlessButton`

Use `BorderlessButton` for simple icon-only or text-only buttons. Interaction varies by platform: a borderless ripple on Android and background dimming on iOS, similar to `TouchableOpacity`. In addition to `BaseButton` properties, it includes:

#### Properties specific to `BorderlessButton`:

- **borderless** (**Android only**): Set to `false` if the ripple should be confined within view bounds.

- **activeOpacity** (**iOS only**): The opacity applied during the active state.

### Design Patterns

These components are not designed to behave identically across platforms but rather to handle similar behaviors on iOS and Android, considering their design concepts. For platform-specific design patterns, refer to official Apple documentation and Material.io guidelines.

The library supports using native components with native feedback in appropriate situations. If a custom design approach is unnecessary, `RectButton` and `BorderlessButton` are sufficient. Otherwise, rely on `BaseButton`, which can be customized for specific needs.

#### Common Use Cases

- **Lists and Action Buttons**: Use `RectButton` for list items or action buttons that appear as separate UI blocks. It changes opacity on click and supports a ripple effect on Android. Emphasis is achieved through fill color or transparency, with outlined buttons used for medium emphasis.

- **Icon or Text Only Buttons**: Use `BorderlessButton` for simple icon-only or text-only buttons. Interaction varies by platform: borderless ripple on Android and dimming on iOS. Suitable for non-crucial actions.

#### `PureNativeButton`

For more complex button implementations, use `PureNativeButton` to access the native component. It is generally not recommended but can be useful when wrapping with Animated or Reanimated:

```tsx
import {
  createNativeWrapper,
  PureNativeButton,
} from "react-native-gesture-handler"
import Animated from "react-native-reanimated"

const { event, Value, createAnimatedComponent } = Animated

const AnimatedRawButton = createNativeWrapper(
  createAnimatedComponent(PureNativeButton),
  {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: false,
  }
)

export default class App extends React.Component {
  constructor(props) {
    super(props)
    const state = new Value()
    this._onGestureEvent = event([
      {
        nativeEvent: { state },
      },
    ])
  }

  render() {
    return <AnimatedRawButton onHandlerStateChange={this._onGestureEvent} />
  }
}
```

## Gesture states & events

Each gesture can be conceptualized as a "state machine." At any given moment, each handler instance is assigned a state that may change due to new touch events or specific conditions imposed by the touch system.

A gesture can exist in one of six possible states:

- **UNDETERMINED**

  - This is the initial and default state for every gesture recognizer. After recognizing a gesture, it reverts to this state.

- **FAILED**

  - Occurs when a gesture recognizer receives touches but fails to recognize them due to certain conditions (e.g., exceeding `maxDist`). The state resets to `UNDETERMINED` after failing.

- **BEGAN**

  - Indicates that the gesture recognizer has started receiving touch input but hasn't gathered enough data to either fail or activate fully.

- **CANCELLED**

  - Triggered when a continuous gesture is interrupted by new touches or commands from the touch system controller. The state remains `CANCELLED` until it resets to `UNDETERMINED`.

- **ACTIVE**

  - Represents a recognized gesture that continues until completion (e.g., finger lift) or cancellation. Normally transitions to `END`, but if cancelled, moves to `CANCELLED`.

- **END**
  - Signifies the end of touch input for a gesture. The state becomes `END` and remains so until it resets to `UNDETERMINED`.

### State Flows

Typically, a gesture progresses from an initial touch event through recognition and acknowledgment of its conclusion before resetting to the initial state.

### Events

RNGH2 defines three types of events: `StateChangeEvent`, `GestureEvent`, and `PointerEvent`.

- **`StateChangeEvent`**: Triggered whenever a gesture transitions between states, carrying both current and previous state information.

- **`GestureEvent`**: Occurs with each update to a gesture, including the current state.

- **`PointerEvent`**: Provides raw touch event data (e.g., screen touches or finger movements) handled internally before reaching callbacks.

#### Event Callbacks

- **`onBegin`**

  - Invoked when transitioning to the `BEGAN` state.

- **`onStart`**

  - Triggered upon entering the `ACTIVE` state.

- **`onEnd`**

  - Called during transitions from `ACTIVE` to `END`, `FAILED`, or `CANCELLED`. The `success` argument is `true` for `END`, otherwise `false`.

- **`onFinalize`**

  - Executed when transitioning to `END`, `FAILED`, or `CANCELLED`. Similar to `onEnd`, with the `success` parameter indicating a successful transition. Follows `onEnd` if moving from `ACTIVE`.

- **`onUpdate`**

  - Triggered during updates while in the `ACTIVE` state.

- **`onPointerDown`**

  - Occurs when new pointers touch the screen, potentially involving multiple pointers due to event batching.

- **`onPointerMove`**

  - Activated when pointers move on the screen, possibly including data for multiple pointers.

- **`onPointerUp`**

  - Triggered when pointers are lifted from the screen, with potential information about multiple pointers.

- **`onPointerCancelled`**
  - Called when no further pointer information is available due to gesture completion or interruption. May involve multiple pointers due to event batching.

## Handler State

Gesture handlers are conceptualized as "state machines," where each instance maintains an assigned state that can change due to new touch events or be altered by the touch system under specific conditions. There are six possible states for a gesture handler:

- **UNDETERMINED**
- **FAILED**
- **BEGAN**
- **CANCELLED**
- **ACTIVE**
- **END**

Each of these states is detailed below.

### Accessing State

To monitor changes in a handler's state, use the `onHandlerStateChange` callback along with the destructured `nativeEvent` argument. The `state` attribute within `nativeEvent` can be compared to constants from the `State` object (as demonstrated in the example).

```typescript
import { State, LongPressGestureHandler } from 'react-native-gesture-handler';

class Demo extends Component {
  _handleStateChange = ({ nativeEvent }) => {
    if (nativeEvent.state === State.ACTIVE) {
      Alert.alert('Longpress');
    }
  };

  render() {
    return (
      <LongPressGestureHandler onHandlerStateChange={this._handleStateChange}>
        <Text style={styles.buttonText}>Longpress me</Text>
      </LongPressGestureHandler>
    );
  }
}
```

### State Flows

The typical state flow for a gesture handler involves recognizing an initial touch event, acknowledging its conclusion, and resetting to the initial state. This sequence is represented as:

`UNDETERMINED` -> `BEGAN` -----> `ACTIVE` -----> `END` -> `UNDETERMINED`

A different flow occurs when touches lead to recognition failure:

`UNDETERMINED` -> `BEGAN` -----> `FAILED` -> `UNDETERMINED`

If a gesture is recognized but interrupted by the touch system, it results in cancellation:

`UNDETERMINED` -> `BEGAN` -----> `ACTIVE` -----> `CANCELLED` -> `UNDETERMINED`

### States Description

#### UNDETERMINED

The initial state of each handler, returning to this state after gesture recognition is complete.

#### FAILED

Occurs when touches are received but not recognized due to constraints like exceeding a defined `maxDist`. The state resets to `UNDETERMINED` afterward.

#### BEGAN

Indicates the start of touch stream reception without sufficient data for failure or activation.

#### CANCELLED

Triggered by new touches or commands from the touch system, leading to gesture recognition cancellation. The state transitions back to `UNDETERMINED`.

#### ACTIVE

The handler recognizes a gesture and remains in this state until the gesture concludes (e.g., finger lift) or is cancelled. Normally, it progresses to `END`, but if cancelled by the touch system, it becomes `CANCELLED`. Further details on discrete and continuous handlers can provide insights into how long a handler stays `ACTIVE`.

#### END

Signifies the end of a gesture with touches indicating completion. The state transitions to `UNDETERMINED` after resetting.

## Legacy Gesture Handlers

### Overview

The legacy gesture handler API is scheduled for removal in upcoming versions of Gesture Handler. Users are encouraged to transition to the new gestures API. For detailed migration instructions, refer to the provided upgrading guide.

### Cross-Handler Interactions

The previous cross-handler interaction capabilities will be deprecated in future releases. Transitioning to the updated gestures API is recommended. Consult the upgrading guide for further details.

### Common Handler Properties

Properties common across handlers in the old API are slated for removal. Users should adopt the new gestures API and refer to the upgrading guide for assistance.

### Specific Gesture Handlers

#### Pan

The pan gesture handler from the legacy API will be deprecated. Transitioning to the gestures API is advised. See the upgrading guide for more information.

#### Tap

The tap gesture handler in the old API will no longer be supported. Users should migrate to the new gestures API. Refer to the upgrading guide for guidance.

#### Long Press

Long press functionality from the legacy API will be removed. Transitioning to the gestures API is recommended. Consult the upgrading guide for more details.

#### Rotation

The rotation gesture handler in the old API will be deprecated. Migrating to the gestures API is advised. See the upgrading guide for further information.

#### Fling

Fling gesture handling from the legacy API will be removed. Users should transition to the new gestures API. Refer to the upgrading guide for assistance.

#### Pinch

The pinch gesture handler in the old API will no longer be supported. Transitioning to the gestures API is recommended. Consult the upgrading guide for more details.

#### Force Touch

Force touch functionality from the legacy API will be deprecated. Migrating to the gestures API is advised. See the upgrading guide for further information.

### NativeView

The `NativeView` component in the old API will be removed. Users should adopt the new gestures API and refer to the upgrading guide for assistance.

### createNativeWrapper()

The `createNativeWrapper()` function from the legacy API will no longer be supported. Transitioning to the gestures API is recommended. Consult the upgrading guide for more details.

## Testing with Jest

### Mocking Native Modules

To load mocks provided by RNGH, add the following to your Jest configuration in `package.json`:

```json
"setupFiles": ["./node_modules/react-native-gesture-handler/jestSetup.js"]
```

Example configuration:

```json
"jest": {
  "preset": "react-native",
  "setupFiles": ["./node_modules/react-native-gesture-handler/jestSetup.js"]
}
```

### Testing Gestures and Gesture Handlers' Callbacks

RNGH offers an API for triggering selected handlers:

- `fireGestureHandler(gestureOrHandler, eventList)`
- `getByGestureTestId(testID)`

#### fireGestureHandler(gestureOrHandler, eventList)

This function simulates a sequence of events (starting with the `BEGIN` state and ending with one of `END`, `FAIL`, or `CANCEL`) that call appropriate callbacks associated with a specified gesture handler.

##### Arguments

###### `gestureOrHandler`

Represents either:

1. A gesture handler component found using Jest queries, such as `getByTestId`.
1. A gesture identified by `getByGestureTestId()`.

###### `eventList`

The event data passed to the relevant callback. RNGH automatically fills in missing data according to these rules:

1. The `oldState` is derived from the state of the previous event; for `BEGIN` events, it uses an `UNDETERMINED` value.
1. Events following the first `ACTIVE` state can omit the `state` field.
1. Handler-specific data (e.g., `numberOfTouches`, `x`) are filled with default values if missing.
1. Missing `BEGIN` and `END` events are added, using data from the first and last provided event, respectively.
1. If the initial event lacks a `state` field, it defaults to the `ACTIVE` state.

Examples:

```typescript
const oldStateFilled = [
  { state: State.BEGAN },
  { state: State.ACTIVE },
  { state: State.END },
] // Three events with specified states are fired.

const implicitActiveState = [
  { state: State.BEGAN },
  { state: State.ACTIVE },
  { x: 5 },
  { state: State.END },
] // Four events, including two ACTIVE events (the second one has overridden additional data).

const implicitBegin = [
  { x: 1, y: 11 },
  { x: 2, y: 12, state: State.FAILED },
] // Three events, including an implicit BEGAN event, one ACTIVE event, and a FAILED event with additional data.

const implicitBeginAndEnd = [
  { x: 5, y: 15 },
  { x: 6, y: 16 },
  { x: 7, y: 17 },
] // Five events, including three ACTIVE events and implicit BEGAN and END events. The BEGAN event uses the first event's additional data, while the END event uses the last event's.

const allImplicits = [] // Three events, one BEGIN, one ACTIVE, and one END with default values.
```

##### Example

Extracted from RNGH tests; refer to `Events.test.tsx` for full implementation:

```typescript
it('sends events with additional data to handlers', () => {
  const panHandlers = mockedEventHandlers();
  render(<SingleHandler handlers={panHandlers} treatStartAsUpdate />);
  fireGestureHandler<PanGesture>(getByGestureTestId('pan'), [
    { state: State.BEGAN, translationX: 0 },
    { state: State.ACTIVE, translationX: 10 },
    { translationX: 20 },
    { translationX: 20 },
    { state: State.END, translationX: 30 },
  ]);

  expect(panHandlers.active).toHaveBeenCalledTimes(3);
  expect(panHandlers.active).toHaveBeenLastCalledWith(
    expect.objectContaining({ translationX: 20 })
  );
});
```

### getByGestureTestId(testID)

Returns an opaque data type associated with a gesture, identified via the `testID` attribute in rendered components (see `withTestID` method).

#### Arguments

##### `testID`

A string that uniquely identifies the gesture.

#### Notes

The `testID` must be unique among components rendered in the test.

#### Example

Refer to the example provided for `fireGestureHandler`.

## About Gesture Handlers

> **Warning:** The old API will be removed in a future version of Gesture Handler. Please migrate to the gestures API instead. Refer to our upgrading guide for more information.

### Overview

Gesture handlers are fundamental components of this library, representing elements of the native touch system that can be instantiated and controlled from JavaScript using React's Component interface. Each handler type is designed to recognize specific gestures (such as pan or pinch) and provides gesture-specific data through events (like translation or scale).

Handlers process the touch stream synchronously on the UI thread, ensuring smooth interactions even if the JavaScript thread is blocked.

Each handler functions as an isolated state machine, transitioning between states based on input from the touch stream. When a gesture begins, handlers potentially interested in recognizing it are selected based on the initial finger position. All subsequent touch events (touch down, move, up, or when other fingers are placed or lifted) are delivered to these initially selected handlers. Once one gesture becomes active, it cancels all others (see "Cross handler interactions" for more details).

Gesture handler components do not create native views in the view hierarchy; instead, they exist within the library's registry and connect to native views. When using any gesture handler component, ensure a native view is rendered as its child since these handlers lack corresponding views in the hierarchy.

### Available Gesture Handlers

The library currently supports the following gestures, with detailed documentation available for each:

- `PanGestureHandler`
- `TapGestureHandler`
- `LongPressGestureHandler`
- `RotationGestureHandler`
- `FlingGestureHandler`
- `PinchGestureHandler`
- `ForceTouchGestureHandler`

### Discrete vs Continuous Gestures

Gestures are categorized as either discrete or continuous:

- **Continuous Gesture Handlers**: Remain active for extended periods, generating a stream of gesture events until the gesture concludes. For example, `PanGestureHandler` provides updates on translation and other properties while active.

- **Discrete Gesture Handlers**: Activate briefly and end immediately. An example is `LongPressGestureHandler`, which detects if a finger remains placed for a sufficient duration without tracking movements (handled by `PanGestureHandler`).

Note: The `onGestureEvent` callback is only applicable to continuous gesture handlers and should not be used with discrete handlers like `TapGestureHandler`.

### Nesting Handlers

Handler components can be nested, but it's recommended that the innermost handler renders a native view component. Some limitations apply when using the `useNativeDriver` flag. Hereâ€™s an example of nested handlers:

```typescript
class Multitap extends Component {
  render() {
    return (
      <LongPressGestureHandler
        onHandlerStateChange={this._onLongpress}
        minDurationMs={800}>
        <TapGestureHandler
          onHandlerStateChange={this._onSingleTap}
          waitFor={this.doubleTapRef}>
          <TapGestureHandler
            ref={this.doubleTapRef}
            onHandlerStateChange={this._onDoubleTap}
            numberOfTaps={2}>
            <View style={styles.box} />
          </TapGestureHandler>
        </TapGestureHandler>
      </LongPressGestureHandler>
    );
  }
}
```

### Using Native Components

The gesture handler library provides components typically available in React Native, wrapped in `NativeViewGestureHandler`. These include:

- `ScrollView`
- `FlatList`
- `Switch`
- `TextInput`
- `DrawerLayoutAndroid` (**Android only**)

For using other handlers or buttons within a `ScrollView`, utilize the `waitFor` property to define interactions between a handler and `ScrollView`.

### Events with `useNativeDriver`

Since gesture handlers hook into their child views rather than creating native views, directly nesting two gesture handlers with `Animated.event` is not supported. To address this limitation, place an `<Animated.View>` component between the handlers.

Instead of:

```typescript
const PanAndRotate = () => (
  <PanGestureHandler onGestureEvent={Animated.event({ ... }, { useNativeDriver: true })}>
    <RotationGestureHandler onGestureEvent={Animated.event({ ... }, { useNativeDriver: true })}>
      <Animated.View style={animatedStyles}/>
    </RotationGestureHandler>
  </PanGestureHandler>
);
```

Use:

```typescript
const PanAndRotate = () => (
  <PanGestureHandler onGestureEvent={Animated.event({ ... }, { useNativeDriver: true })}>
    <Animated.View>
      <RotationGestureHandler onGestureEvent={Animated.event({ ... }, { useNativeDriver: true })}>
        <Animated.View style={animatedStyles}/>
      </RotationGestureHandler>
    </Animated.View>
  </PanGestureHandler>
);
```

Additionally, when using the `useNativeDriver` flag with an `Animated.event`, ensure the child component is wrapped by an `Animated.API` (e.g., `<Animated.View>`) instead of a regular `<View>`:

```typescript
class Draggable extends Component {
  render() {
    return (
      <PanGestureHandler onGestureEvent={Animated.event({ ... }, { useNativeDriver: true })}>
        <Animated.View style={animatedStyles} /> {/* <-- NEEDS TO BE Animated.View */}
      </PanGestureHandler>
    );
  }
}
```

## Custom Swipeable Component with Scroll Functionality

When developing a custom swipeable component, you may encounter issues where scrolling does not function as expected. To address this, it is recommended to set the `touchAction` property to `"pan-y"` within your gesture detector configuration.

Here's how you can implement this:

```typescript
<GestureDetector gesture={...} touchAction="pan-y">
  ...
</GestureDetector>
```

By setting `touchAction` to `"pan-y"`, you allow vertical panning, which helps maintain scroll functionality in your custom swipeable component.

## Cross handler interactions

**Warning:** The old API will be removed in future versions of Gesture Handler. Please migrate to the gestures API instead. Refer to our upgrading guide for more information.

Gesture handlers can "communicate" with each other to support complex gestures and control how they activate under certain scenarios. There are two methods described below for achieving this communication. In both cases, it is necessary to provide a reference of one handler as a property to the other. Gesture handlers rely on ref objects created using `React.createRef()` introduced in React 16.3.

### Simultaneous Recognition

By default, only one gesture handler can be in the `ACTIVE` state at any given time. When a gesture handler recognizes a gesture, it cancels all other handlers that are in the `BEGAN` state and prevents any new handlers from receiving a stream of touch events as long as it remains `ACTIVE`.

This behavior can be modified using the `simultaneousHandlers` property (available for all types of handlers). This property accepts a ref or an array of refs to other handlers. Handlers connected in this way will be allowed to remain in the `ACTIVE` state simultaneously.

#### Use Cases

Simultaneous recognition is necessary when implementing a photo preview component that supports zooming (scaling), rotating, and panning while zoomed in. In such cases, you would use a `PinchGestureHandler`, `RotationGestureHandler`, and `PanGestureHandler` to recognize gestures at the same time.

#### Example

See the "Scale, rotate & tilt" example from the GestureHandler Example App or view it directly on your phone by visiting our expo demo.

```typescript
class PinchableBox extends React.Component {
  // ...take a look at full implementation in an Example app
  render() {
    const imagePinch = React.createRef();
    const imageRotation = React.createRef();
    return (
      <RotationGestureHandler
        ref={imageRotation}
        simultaneousHandlers={imagePinch}
        onGestureEvent={this._onRotateGestureEvent}
        onHandlerStateChange={this._onRotateHandlerStateChange}>
        <Animated.View>
          <PinchGestureHandler
            ref={imagePinch}
            simultaneousHandlers={imageRotation}
            onGestureEvent={this._onPinchGestureEvent}
            onHandlerStateChange={this._onPinchHandlerStateChange}>
            <Animated.View style={styles.container} collapsable={false}>
              <Animated.Image
                style={[
                  styles.pinchableImage,
                  {
                    /* events-related transformations */
                  },
                ]}
              />
            </Animated.View>
          </PinchGestureHandler>
        </Animated.View>
      </RotationGestureHandler>
    );
  }
}
```

### Awaiting Other Handlers

#### Use Cases

A good example where awaiting is necessary is when you want to have single and double tap handlers registered for one view (e.g., a button). In such cases, the single tap handler should await the double tap. Otherwise, if you try to perform a double tap, the single tap handler will fire after the first hit on the button, consequently cancelling the double tap handler.

#### Example

See the "Multitap" example from GestureHandler Example App or view it directly on your phone by visiting our expo demo.

```typescript
const doubleTap = React.createRef();
const PressBox = () => (
  <TapGestureHandler
    onHandlerStateChange={({ nativeEvent }) =>
      nativeEvent.state === State.ACTIVE && Alert.alert('Single tap!')
    }
    waitFor={doubleTap}>
    <TapGestureHandler
      ref={doubleTap}
      onHandlerStateChange={({ nativeEvent }) =>
        nativeEvent.state === State.ACTIVE && Alert.alert("You're so fast")
      }
      numberOfTaps={2}>
      <View style={styles.box} />
    </TapGestureHandler>
  </TapGestureHandler>
);
```

## Fling gesture

A discrete gesture activated by sufficiently long and fast movement. The gesture becomes ACTIVE when the movement meets these criteria, transitioning to END upon finger release. If the finger lifts before activation, recognition fails.

### Example

```typescript
import { StyleSheet } from 'react-native';
import {
  Gesture,
  GestureDetector,
  Directions,
} from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

export default function App() {
  const position = useSharedValue(0);
  const flingGesture = Gesture.Fling()
    .direction(Directions.RIGHT)
    .onStart((e) => {
      position.value = withTiming(position.value + 10, { duration: 100 });
    });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: position.value }],
  }));

  return (
    <GestureDetector gesture={flingGesture}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
    borderRadius: 20,
    marginBottom: 30,
  },
});
```

### Configuration

#### Properties Specific to `FlingGesture`:

|Property|Description|||
|-|-|-|-|
|`direction(value: Directions)`|Specifies allowed movement directions. Use constants from the `Directions` object, combining multiple directions with \`|`. Example: `fling.direction(Directions.RIGHT|Directions.LEFT);`or`fling.direction(Directions.DOWN);\`|
|`numberOfPointers(value: number)`|Sets the exact number of pointers required for gesture recognition.|||
|`mouseButton(value: MouseButton)` (Web & Android only)|Chooses which mouse button to respond to, using predefined fields in `MouseButton`: `LEFT`, `RIGHT`, `MIDDLE`, `BUTTON_4`, `BUTTON_5`, `ALL`. Combine with \`|`operator; default is`LEFT\`.||

#### Properties Common to All Gestures:

|Property|Description|
|-|-|
|`enabled(value: boolean)`|Determines if the handler analyzes touch events. Default is `true`. Disabling during recognition changes state to `FAILED` or `CANCELLED`.|
|`shouldCancelWhenOutside(value: boolean)`|Cancels/fails recognition when a finger leaves the view area. Defaults vary by gesture type; most are `false`, except for `LongPressGesture` and `TapGesture` which default to `true`.|
|`hitSlop(settings)`|Controls the active area for gesture recognition, reducing or expanding bounds as specified. Supports negative numbers, objects with specific side reductions, and `width`/`height` attributes.|
|`withRef(ref)`|Sets a ref for interoperability with older APIs.|
|`withTestId(testID)`|Assigns a `testID` for querying in tests.|
|`cancelsTouchesInView(value)` (**iOS only**)|When `true`, cancels touches for native UI components when active. Default is `true`.|
|`runOnJS(value: boolean)`|Determines if callbacks run on the JS thread (`true`) or UI thread (`false`). Defaults to `false` with `react-native-reanimated`.|
|`simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`|Marks gestures for simultaneous recognition without composing them. Requires separate detectors.|
|`requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`|Requires another gesture to fail before activation. Does not compose gestures; requires separate detectors.|
|`blocksExternalGesture(otherGesture1, otherGesture2, ...)`|Delays other gestures until this one fails or doesn't start. Marks relations without composing; requires separate detectors.|

### Callbacks

#### Common to All Gestures:

|Callback|Description|
|-|-|
|`onBegin(callback)`|Called when the gesture handler starts receiving touches but hasn't yet recognized the gesture.|
|`onStart(callback)`|Triggered when the gesture is recognized and transitions to active state.|
|`onEnd(callback)`|Invoked when a recognized gesture finishes, only if previously active.|
|`onFinalize(callback)`|Called upon finalizing gesture handlingâ€”either recognition or failure.|
|`onTouchesDown(callback)`|Executed every time a finger touches the screen.|
|`onTouchesMove(callback)`|Triggered with each finger movement on the screen.|
|`onTouchesUp(callback)`|Invoked when a finger is lifted from the screen.|
|`onTouchesCancelled(callback)`|Called when a finger stops being tracked, such as gesture completion.|

### Event Data

#### Specific to `FlingGesture`:

|Attribute|Description|
|-|-|
|`x`|X coordinate of the pointer relative to the attached view (in points).|
|`y`|Y coordinate of the pointer relative to the attached view (in points).|
|`absoluteX`|X coordinate of the pointer relative to the window, recommended for transformed views.|
|`absoluteY`|Y coordinate of the pointer relative to the window, recommended for transformed views.|

#### Common to All Gestures:

|Attribute|Description|
|-|-|
|`state`|Current handler state, expressed as constants from the `State` object.|
|`numberOfPointers`|Number of pointers currently on the screen.|
|`pointerType`|Type of pointer device, using `PointerType`: `TOUCH`, `STYLUS`, `MOUSE`, `KEY`, `OTHER`.|

## Common handler properties

**Warning:** The old API will be removed in future versions of Gesture Handler. Please migrate to the gestures API instead. Refer to our upgrading guide for more information.

This page covers the common set of properties that all gesture handler components expose.

### Units

All handler component properties and event attributes representing onscreen dimensions are expressed in screen density-independent units known as "points." These units are commonly used in the React Native ecosystem (e.g., in the layout system). They do not map directly to physical pixels but correspond to iOS's points and Android's dp units.

### Properties

This section describes properties applicable to all gesture handler components:

#### `enabled`

- **Type:** Boolean
- **Description:** Indicates whether the handler should analyze a stream of touch events. When set to `false`, the handler's state will never become `ACTIVE`. If updated while recognizing a gesture, it changes to `FAILED` or `CANCELLED` based on its current state.
- **Default Value:** `true`

#### `shouldCancelWhenOutside`

- **Type:** Boolean
- **Description:** When `true`, the handler cancels or fails recognition if the finger leaves the connected view's area. The default value varies by handler type; most handlers default to `false`, except for `LongPressGestureHandler` and `TapGestureHandler`, which default to `true`.

#### `cancelsTouchesInView` (**iOS only**)

- **Type:** Boolean
- **Description:** When `true`, the handler cancels touches for native UI components (e.g., `UIButton`, `UISwitch`) it's attached to when active.
- **Default Value:** `true`

#### `simultaneousHandlers`

- **Type:** React ref object or array of refs
- **Description:** Allows activation even if other handlers provided by their refs are in an `ACTIVE` state. Prevents these handlers from cancelling the current handler upon activation. See cross-handler interaction for more details.

#### `waitFor`

- **Type:** React ref object or array of refs
- **Description:** The handler will not activate as long as handlers provided by their refs are in the `BEGAN` state. See cross-handler interaction for more details.

#### `hitSlop`

- **Description:** Controls the area within the connected view where gesture recognition can begin. A negative number reduces the view's bounds evenly on all sides. Alternatively, an object can specify reductions for each side (`left`, `right`, `top`, `bottom`) or use `horizontal`/`vertical`. The object may also include `width` and `height` attributes to restrict activation to edges.
- **Note:** Primarily designed to reduce the gesture activation area; supported values are non-positive (0 or lower) on all platforms except Android, where positive values expand beyond view bounds but not past parent view bounds. Use React Native's View hitSlop property for cross-platform support.

#### `userSelect` (**Web only**)

- **Type:** `"none" | "auto" | "text"`
- **Description:** Specifies the `userSelect` property applied to the underlying view.
- **Default Value:** `"none"`

#### `activeCursor` (**Web only**)

- **Type:** CSS cursor value (e.g., `"grab"`, `"zoom-in"`)
- **Description:** Specifies the cursor used when a gesture activates.
- **Default Value:** `"auto"`

#### `onGestureEvent`

- **Type:** Callback or `Animated.event`
- **Description:** Triggered for each touch event while the handler is in an ACTIVE state. The event payload varies by handler type, with common attributes documented below and specific ones on corresponding handler pages.

#### `onHandlerStateChange`

- **Type:** Callback or `Animated.event`
- **Description:** Triggered when the handler's state changes. Includes the same payload as `onGestureEvent` plus an `oldState` attribute representing the previous state before the change.

### Event Data

This section describes attributes of the event object provided to `onGestureEvent` and `onHandlerStateChange` callbacks:

#### `state`

- **Description:** Current state of the handler, expressed as one of the constants in the `State` object exported by the library. Refer to the handler state section for more details.

#### `numberOfPointers`

- **Description:** Represents the number of pointers (fingers) currently on the screen.

## Hover gesture

A continuous gesture designed to recognize hovering actions over a view. This can be triggered by moving a mouse or stylus above the view.

On iOS, additional visual effects are configurable.

### Reference

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const hover = Gesture.Hover();

  return (
    <GestureDetector gesture={hover}>
      <View />
    </GestureDetector>
  );
}
```

### Remarks

- The `Hover` gesture does not continue after a mouse click or stylus touch. For handling both scenarios, combine it with the `Pan` gesture.

### Configuration

#### Properties Specific to `HoverGesture` (iOS Only)

##### `effect(effect: HoverEffect)`

Defines the visual effect applied while hovering over the view. Possible values include:

- `HoverEffect.None`
- `HoverEffect.Lift`
- `HoverEffect.Highlight`

Defaults to `HoverEffect.None`.

```typescript
import { HoverEffect } from "react-native-gesture-handler"
```

#### Properties Common to All Gestures

##### `enabled(value: boolean)`

Determines if the handler analyzes touch events. When set to `false`, the handler's state will never be `ACTIVE`. If updated during gesture recognition, it transitions to `FAILED` or `CANCELLED`. Default is `true`.

##### `shouldCancelWhenOutside(value: boolean)`

If `true`, the handler cancels or fails when a finger leaves the view area. Defaults vary by handler type; most are `false`, except for `LongPressGesture` and `TapGesture`, which default to `true`.

##### `hitSlop(settings)`

Controls the gesture activation area within the view. Negative numbers reduce the bounds evenly on all sides. Alternatively, specify reductions per side (`left`, `right`, `top`, `bottom`) or use `horizontal`/`vertical`. You can also set `width` and `height` to restrict gestures to edges.

**Note:** Primarily reduces activation area; supported for non-positive values (0 or lower). On Android, positive values are allowed but limited by parent view bounds. For cross-platform edge effects, use React Native's View hitSlop property.

##### `withRef(ref)`

Sets a ref to the gesture object for interoperability with older APIs.

##### `withTestId(testID)`

Assigns a `testID` to the gesture object for test querying.

##### `cancelsTouchesInView(value)` (iOS Only)

When `true`, cancels touches for native UI components (`UIButton`, `UISwitch`, etc.) when active. Default is `true`.

##### `runOnJS(value: boolean)`

If `react-native-reanimated` is installed, callbacks are workletized and run on the UI thread by default. Setting this to `true` runs all callbacks on the JS thread instead. Defaults to `false`.

##### `simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`

Marks gestures for simultaneous recognition without composing them. Requires adding `otherGestures` to another detector.

##### `requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`

Requires specified gestures to fail before this one can activate.

##### `blocksExternalGesture(otherGesture1, otherGesture2, ...)`

Prevents specified gestures from activating until this gesture fails or doesn't start. Requires adding `otherGestures` to another detector.

**Note:** Marks relations without composing them; `GestureDetector` won't recognize `otherGestures`.

##### `activeCursor(value)` (Web Only)

Specifies the cursor style when the gesture activates, supporting all CSS cursor values (e.g., `"grab"`, `"zoom-in"`). Default is `"auto"`.

### Callbacks

#### Common to All Gestures

##### `onBegin(callback)`

Called when the handler starts receiving touches but hasn't yet recognized a gesture.

##### `onStart(callback)`

Triggered when the gesture is recognized and transitions to an active state.

##### `onEnd(callback)`

Invoked when a recognized gesture finishes, provided it was previously in an active state.

##### `onFinalize(callback)`

Called when the handler finalizes handling a gesture, whether recognized or failed.

##### `onTouchesDown(callback)`

Executed every time a finger touches the screen.

##### `onTouchesMove(callback)`

Triggered whenever a finger moves on the screen.

##### `onTouchesUp(callback)`

Invoked each time a finger is lifted from the screen.

##### `onTouchesCancelled(callback)`

Called when a finger stops being tracked, such as when a gesture finishes.

#### Common to All Continuous Gestures

##### `onUpdate(callback)`

Executed every time an active gesture receives an update.

##### `onChange(callback)`

Triggered with updates during an active gesture, providing change information relative to the last event.

### Event Data Specific to `HoverGesture`

- **`x`**: X coordinate of the pointer relative to the view, in points.
- **`y`**: Y coordinate of the pointer relative to the view, in points.
- **`absoluteX`**: X coordinate of the pointer relative to the window, in points. Use this for transformed views.
- **`absoluteY`**: Y coordinate of the pointer relative to the window, in points. Use this for transformed views.
- **`stylusData`**: Contains additional stylus information:
  - `tiltX`: Angle between the Y-Z plane of the stylus and the screen (degrees).
  - `tiltY`: Angle between the X-Z plane of the stylus and the screen (degrees).
  - `altitudeAngle`: Angle between stylus axis and device screen's X-Y plane.
  - `azimuthAngle`: Angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis.
  - `pressure`: Normalized pressure of the stylus.

### Event Attributes Common to All Gestures

- **`state`**: Current state of the handler, expressed as a constant from the `State` object.
- **`numberOfPointers`**: Number of pointers (fingers) on the screen.
- **`pointerType`**: Type of pointer device in use, represented by the `PointerType` enum:
  - `TOUCH`: Finger
  - `STYLUS`: Stylus or digital pen
  - `MOUSE`: Computer mouse
  - `KEY`: Keyboard
  - `OTHER`: Unknown device type

## PanGestureHandler

> **Warning:** The old API will be removed in a future version of Gesture Handler. Please migrate to the gestures API instead. Refer to our upgrading guide for more information.

The `PanGestureHandler` is a continuous gesture handler designed to recognize and track panning (dragging) gestures. It activates when a finger touches the screen and moves beyond an initial distance.

### Custom Activation Criteria

The `PanGestureHandler` component offers several properties to customize activation criteria:

- **Multiple Properties:** When multiple properties are set, all must be met for successful recognition, and at least one can be exceeded to fail recognition.
  - Example: Setting both `minDeltaX` and `minDeltaY` to 20 requires movement of 20 points in both axes. Conversely, setting `maxDeltaX`, `maxDeltaY` to 20, and `minDist` to 23 will cause failure if the finger moves 20 points along X-axis but not Y-axis.

### Multi-Touch Pan Handling

#### Platform Differences:

- **iOS:** Treats multiple fingers as a single pointer at their center of mass.
- **Android:** Defaults to using the latest placed finger for translation properties, similar to native components like scroll views.

#### Customization:

- On Android, use `avgTouches` to switch to iOS-like behavior (center of mass).

Note: Translation properties remain unaffected by additional fingers unless tracking the "center of mass" is required. Use relative or absolute positions (`x`, `y`, `absoluteX`, `absoluteY`) for such cases.

### Properties

Inherits from base handler class with specific properties:

- **`minDist`:** Minimum distance to activate (in points).
- **`minPointers`:** Required number of fingers before activation.
- **`maxPointers`:** Maximum number of fingers allowed; exceeding this fails recognition.
- **`activeOffsetX/Y`:** Range along X or Y axis without activating the handler. Can be an array `[lower, upper]` or a single value `p`.
- **`failOffsetX/Y`:** Range beyond which gesture recognition fails if not yet activated.
- **Deprecated Methods:**
  - Use `failOffsetX={[-N, N]}` instead of `maxDeltaX={N}`.
  - Use `failOffsetY={[-N, N]}` instead of `maxDeltaY={N}`.

### Event Data

Includes attributes specific to `PanGestureHandler`:

- **`translationX/Y`:** Accumulated translation along X or Y axis (in points).
- **`velocityX/Y`:** Current velocity along X or Y axis (points per second).
- **`x/y`:** Relative position of the pointer to the view.
- **`absoluteX/Y`:** Position relative to the window, recommended for transformed views.

### Example

```typescript
import React, { Component } from 'react';
import { Animated, Dimensions } from 'react-native';
import {
  GestureHandlerRootView,
  PanGestureHandler,
} from 'react-native-gesture-handler';

const { width } = Dimensions.get('screen');
const circleRadius = 30;

class Circle extends Component {
  _touchX = new Animated.Value(width / 2 - circleRadius);

  _onPanGestureEvent = Animated.event([{ nativeEvent: { x: this._touchX } }], {
    useNativeDriver: true,
  });

  render() {
    return (
      <GestureHandlerRootView>
        <PanGestureHandler onGestureEvent={this._onPanGestureEvent}>
          <Animated.View
            style={{
              height: 150,
              justifyContent: 'center',
            }}>
            <Animated.View
              style={[
                {
                  backgroundColor: '#42a5f5',
                  borderRadius: circleRadius,
                  height: circleRadius * 2,
                  width: circleRadius * 2,
                },
                {
                  transform: [
                    {
                      translateX: Animated.add(
                        this._touchX,
                        new Animated.Value(-circleRadius)
                      ),
                    },
                  ],
                },
              ]}
            />
          </Animated.View>
        </PanGestureHandler>
      </GestureHandlerRootView>
    );
  }
}

export default function App() {
  return <Circle />;
}
```

## TapGestureHandler

**Warning:**\
The old API will be deprecated in future versions of Gesture Handler. It is recommended to migrate to the gestures API. Refer to our upgrading guide for more details.

A discrete gesture handler that recognizes one or multiple taps.

Tap gestures detect brief contact by one or more fingers on the screen, with minimal movement from their initial touch positions. You can configure the number of required taps and the allowed distance from the starting position. For instance, tap gesture recognizers can be set up to detect single, double, or triple taps.

For a handler to activate, specific gesture requirements such as `minPointers`, `numberOfTaps`, `maxDist`, `maxDurationMs`, and `maxDelayMs` must be satisfied. Once activated, the handler will immediately END.

### Properties

In addition to properties inherited from the base handler class, the `TapGestureHandler` component has specific properties:

#### `minPointers`

The minimum number of pointers (fingers) required before activation. This should be a positive integer with a default value of 1.

#### `maxDurationMs`

Defines the maximum time in milliseconds for how quickly a finger must be released after touching. The default is set to 500 ms.

#### `maxDelayMs`

Specifies the maximum allowable time in milliseconds between taps when multiple taps are required. The default is 500 ms.

#### `numberOfTaps`

The number of tap gestures needed to activate the handler, with a default value of 1.

#### `maxDeltaX`

Defines the maximum distance in points that a finger can travel along the X-axis during a tap gesture. If exceeded before activation, the gesture will not be recognized.

#### `maxDeltaY`

Specifies the maximum distance in points for movement along the Y-axis during a tap gesture. Exceeding this distance before activation results in failure to recognize the gesture.

#### `maxDist`

The maximum allowable distance in points that a finger can travel during a tap gesture. If exceeded, the handler will not recognize the gesture.

### Event Data

In addition to event attributes from the base handler class, the `TapGestureHandler` component has specific gesture event attributes:

#### `x`

X coordinate of the current pointer position (finger or leading pointer) relative to the view attached to the handler, expressed in points.

#### `y`

Y coordinate of the current pointer position (finger or leading pointer) relative to the view attached to the handler, expressed in points.

#### `absoluteX`

X coordinate of the current pointer position (finger or leading pointer) relative to the window. Use `absoluteX` instead of `x` when the view can be transformed due to gestures.

#### `absoluteY`

Y coordinate of the current pointer position (finger or leading pointer) relative to the window. Use `absoluteY` instead of `y` in cases where the view attached to the handler may transform as a result of gestures.

### Example

Refer to the multitap example from the GestureHandler Example App for implementation details.

```typescript
export class PressBox extends Component {
  doubleTapRef = React.createRef();

  render() {
    return (
      <TapGestureHandler
        onHandlerStateChange={this._onSingleTap}
        waitFor={this.doubleTapRef}>
        <TapGestureHandler ref={this.doubleTapRef} numberOfTaps={2}>
          <View style={styles.box} />
        </TapGestureHandler>
      </TapGestureHandler>
    );
  }
}
```

## LongPressGestureHandler

> **Warning:**\
> The old API will be deprecated in future versions of Gesture Handler. It is recommended to migrate to the gestures API. Refer to our upgrading guide for more information.

The `LongPressGestureHandler` is a discrete gesture handler that activates when a view is pressed for a sufficient duration. Once the finger is released, the handler's state transitions to END immediately. The handler will not recognize a touch event if the finger is lifted before reaching the minimum required time or if it moves beyond an allowable distance.

This handler utilizes `UILongPressGestureRecognizer` on iOS and `LongPressGestureHandler` on Android.

### Properties

The properties specific to the `LongPressGestureHandler` component are listed below. For additional inherited properties, refer to the base handler class documentation:

#### `minDurationMs`

- **Description:** Minimum duration in milliseconds that a finger must remain pressed on the view.
- **Default Value:** 500 ms.

#### `maxDist`

- **Description:** Maximum allowable distance in points that defines how far the finger can travel during a long press gesture. If exceeded before activation, the gesture is not recognized.
- **Default Value:** 10 points.

### Event Data

The event attributes specific to the `LongPressGestureHandler` component are detailed below. For more attributes from the base handler class, refer to its documentation:

#### `x`

- **Description:** X coordinate in points of the current pointer position (finger or leading pointer) relative to the view attached to the handler.

#### `y`

- **Description:** Y coordinate in points of the current pointer position (finger or leading pointer) relative to the view attached to the handler.

#### `absoluteX`

- **Description:** X coordinate in points of the current pointer position (finger or leading pointer) relative to the window. Use `absoluteX` instead of `x` if the view can be transformed due to gestures.

#### `absoluteY`

- **Description:** Y coordinate in points of the current pointer position (finger or leading pointer) relative to the window. Use `absoluteY` instead of `y` if the view can be transformed due to gestures.

#### `duration`

- **Description:** Duration of the long press gesture, measured from the start of the event, expressed in milliseconds.

### Example

Below is an example demonstrating how to use the `LongPressGestureHandler`:

```typescript
const LongPressButton = () => (
  <LongPressGestureHandler
    onHandlerStateChange={({ nativeEvent }) => {
      if (nativeEvent.state === State.ACTIVE) {
        Alert.alert("I'm being pressed for so long");
      }
    }}
    minDurationMs={800}>
    <View style={styles.box} />
  </LongPressGestureHandler>
);
```

This example sets up a button that triggers an alert when held down for more than 800 milliseconds.

## Custom swipeable components inside ScrollView (web)

When developing custom swipeable components within a `ScrollView` on the web, you might opt for more control over their behavior by creating your own version instead of using pre-built solutions like ReanimatedSwipeable. However, one common issue encountered is that scrolling functionality may not work as expected after implementing a custom swipeable component.

To address this problem, consider setting the `touchAction` property to `"pan-y"`. This adjustment can help ensure that vertical panning and scrolling are handled correctly within your component.

Here's an example of how you might implement this in TypeScript:

```typescript
import React from 'react';
import { View } from 'react-native';

const CustomSwipeableComponent: React.FC = () => {
  return (
    <View style={{ touchAction: 'pan-y' }}>
      {/* Your swipeable component implementation */}
    </View>
  );
};

export default CustomSwipeableComponent;
```

By setting `touchAction` to `"pan-y"`, you allow the browser to handle vertical panning, which can resolve issues with scrolling when using custom swipeable components inside a `ScrollView`.

## Migrating off RNGHEnabledRootView

### Update `MainActivity.java`

Modify your `MainActivity.java` file (or wherever an instance of `ReactActivityDelegate` is created) to ensure that it no longer overrides the method responsible for creating a `ReactRootView` instance or uses `RNGestureHandlerEnabledRootView`. Additionally, remove the import statement for `RNGestureHandlerEnabledRootView`:

```java
package com.swmansion.gesturehandler.react.example;

import com.facebook.react.ReactActivity;
// Remove this line:
// import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;

public class MainActivity extends ReactActivity {

  // Remove these lines:
  /*
  @Override
  protected ReactActivityDelegate createReactActivityDelegate() {
    return new ReactActivityDelegate(this, getMainComponentName()) {
      @Override
      protected ReactRootView createRootView() {
        return new RNGestureHandlerEnabledRootView(MainActivity.this);
      }
    };
  }
  */
}
```

### Verify App Functionality

Some libraries (such as React Navigation) already utilize `GestureHandlerRootView` to enable gesture interactions. If gestures in your app function correctly after removing `RNGestureHandlerEnabledRootView`, you can skip the next step.

### Update Your JavaScript Code

Replace any usage of `RNGestureHandlerEnabledRootView` with `<GestureHandlerRootView>` or `gestureHandlerRootHOC`. For example:

```jsx
export default function App() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      {/* content */}
    </GestureHandlerRootView>
  )
}
```

**Note:** `GestureHandlerRootView` behaves like a standard `View`. To ensure it fills the screen, you must pass `{ flex: 1 }`, similar to how you would with a regular View. By default, it will take on the size of its nested content.

## RotationGestureHandler

> **Warning:**\
> The old API will be deprecated in future versions of Gesture Handler. It is recommended to migrate to the gestures API. Refer to our upgrading guide for more details.

The `RotationGestureHandler` is a continuous gesture handler designed to recognize and track rotation gestures. Activation occurs when fingers are placed on the screen and move appropriately.

This handler provides callbacks for continuous tracking, offering insights into the gesture's characteristics such as the amount of rotation (in radians), the focal point or anchor of the rotation, and its instantaneous velocity.

On iOS, this functionality is implemented using `UIRotationGestureRecognizer`, while on Android it is developed from scratch.

### Properties

The properties specific to `RotationGestureHandler` do not extend those provided by the base handler class.

### Event Data

In addition to the event attributes available in the base handler class, `RotationGestureHandler` includes the following gesture-specific attributes:

- **rotation**: The amount of rotation, measured in radians, from the gesture's focal point (anchor).
- **velocity**: The instantaneous velocity of the gesture, expressed in points per second.
- **anchorX**: The X coordinate of the gesture's central focal point (anchor), measured in points.
- **anchorY**: The Y coordinate of the gesture's central focal point (anchor), measured in points.

### Example

Below is an example demonstrating how to use `RotationGestureHandler`:

```typescript
class RotableBox extends React.Component {
  _rotate = new Animated.Value(0);

  _rotateStr = this._rotate.interpolate({
    inputRange: [-100, 100],
    outputRange: ['-100rad', '100rad'],
  });

  _lastRotate = 0;

  _onRotateGestureEvent = Animated.event(
    [{ nativeEvent: { rotation: this._rotate } }],
    { useNativeDriver: USE_NATIVE_DRIVER }
  );

  _onRotateHandlerStateChange = (event) => {
    if (event.nativeEvent.oldState === State.ACTIVE) {
      this._lastRotate += event.nativeEvent.rotation;
      this._rotate.setOffset(this._lastRotate);
      this._rotate.setValue(0);
    }
  };

  render() {
    return (
      <RotationGestureHandler
        onGestureEvent={this._onRotateGestureEvent}
        onHandlerStateChange={this._onRotateHandlerStateChange}>
        <Animated.Image
          style={[
            styles.pinchableImage,
            {
              transform: [{ perspective: 200 }, { rotate: this._rotateStr }],
            },
          ]}
        />
      </RotationGestureHandler>
    );
  }
}
```

This example illustrates how to create a rotatable box using `RotationGestureHandler`, with continuous tracking of rotation gestures.

## FlingGestureHandler

> **Warning:**\
> The old API will be deprecated in future versions of Gesture Handler. It is recommended to migrate to the gestures API. Refer to our upgrading guide for more details.

The `FlingGestureHandler` is a discrete gesture handler that activates when movement is sufficiently long and fast. Activation occurs if the movement duration is short enough. Once activated, it transitions to an END state upon finger release. If the finger is lifted before activation, the gesture will not be recognized. On iOS, this handler uses `UISwipeGestureRecognizer`, while on Android, it's implemented from scratch.

### Properties

In addition to properties inherited from the base handler class, `FlingGestureHandler` includes specific properties:

#### `direction`

Specifies the allowed direction(s) of movement. You can define one or multiple directions in a single parameter:

```typescript
direction={Directions.RIGHT | Directions.LEFT}
```

or

```typescript
direction={Directions.DOWN}
```

#### `numberOfPointers`

Determines the exact number of pointers required to recognize the fling gesture.

### Event Data

In addition to event attributes from the base handler class, `FlingGestureHandler` provides specific gesture event attributes:

#### `x`

Represents the X coordinate of the current pointer position (either a single finger or the leading pointer in multi-touch scenarios) relative to the view attached to the handler. The value is expressed in point units.

#### `y`

Represents the Y coordinate of the current pointer position (either a single finger or the leading pointer in multi-touch scenarios) relative to the view attached to the handler. The value is expressed in point units.

#### `absoluteX`

Represents the X coordinate of the current pointer position (either a single finger or the leading pointer in multi-touch scenarios) relative to the window, expressed in point units. It's recommended over `x` when the original view can be transformed due to gestures.

#### `absoluteY`

Represents the Y coordinate of the current pointer position (either a single finger or the leading pointer in multi-touch scenarios) relative to the window, expressed in point units. It's recommended over `y` when the original view can be transformed due to gestures.

### Example

Below is an example demonstrating how to use `FlingGestureHandler`:

```typescript
const LongPressButton = () => (
  <FlingGestureHandler
    direction={Directions.RIGHT | Directions.LEFT}
    onHandlerStateChange={({ nativeEvent }) => {
      if (nativeEvent.state === State.ACTIVE) {
        Alert.alert("I'm flinged!");
      }
    }}>
    <View style={styles.box} />
  </FlingGestureHandler>
);
```

This example shows a button that triggers an alert when flinged to the right or left.

## Quick start

RNGH2 simplifies adding gestures to your application. To implement a gesture, wrap the target view with `GestureDetector`, define the desired gesture, and pass it to the detector.

### Example: Dragging a Ball

To illustrate using this API, we'll create an app where you can drag a ball around. This requires integrating `react-native-gesture-handler` for gestures and `react-native-reanimated` for animations.

#### Step 1: Define Styles

First, define the necessary styles:

```typescript
import { StyleSheet } from "react-native"

const styles = StyleSheet.create({
  ball: {
    width: 100,
    height: 100,
    borderRadius: 100,
    backgroundColor: "blue",
    alignSelf: "center",
  },
})
```

#### Step 2: Create the Ball Component

Next, write the `Ball` component:

```typescript
import { GestureDetector } from 'react-native-gesture-handler';
import Animated from 'react-native-reanimated';

function Ball() {
  return (
    <GestureDetector>
      <Animated.View style={[styles.ball]} />
    </GestureDetector>
  );
}
```

#### Step 3: Define Shared Values and Animated Styles

Define shared values to track the ball's position and create animated styles for positioning:

```typescript
import {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from "react-native-reanimated"

function Ball() {
  const isPressed = useSharedValue(false)
  const offset = useSharedValue({ x: 0, y: 0 })

  const animatedStyles = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: offset.value.x },
        { translateY: offset.value.y },
        { scale: withSpring(isPressed.value ? 1.2 : 1) },
      ],
      backgroundColor: isPressed.value ? "yellow" : "blue",
    }
  })

  // ...
}
```

#### Step 4: Apply Animated Styles

Add the animated styles to the ball's styles:

```typescript
// ...
return (
  <GestureDetector>
    <Animated.View style={[styles.ball, animatedStyles]} />
  </GestureDetector>
);
// ...
```

#### Step 5: Define and Assign the Pan Gesture

Finally, define the pan gesture and assign it to the detector:

```typescript
import { Gesture } from 'react-native-gesture-handler';

function Ball() {
  const start = useSharedValue({ x: 0, y: 0 });
  const gesture = Gesture.Pan()
    .onBegin(() => {
      isPressed.value = true;
    })
    .onUpdate((e) => {
      offset.value = {
        x: e.translationX + start.value.x,
        y: e.translationY + start.value.y,
      };
    })
    .onEnd(() => {
      start.value = {
        x: offset.value.x,
        y: offset.value.y,
      };
    })
    .onFinalize(() => {
      isPressed.value = false;
    });

  // ...
}

// ...
return (
  <GestureDetector gesture={gesture}>
    <Animated.View style={[styles.ball, animatedStyles]} />
  </GestureDetector>
);
// ...
```

**Note:** The `start` shared value stores the ball's position when grabbed to ensure correct positioning later, as we only have access to translation relative to the gesture's starting point.

Now, add the `Ball` component to a view in your app to see it in action!

## Native gesture

A gesture that integrates with other touch handling components within RNGH's gesture system. This integration facilitates interactions between gestures and native components, allowing them to establish relationships with other gestures.

When utilized, the native component should be a direct child of a `GestureDetector`.

### Example

This example demonstrates rendering a `ScrollView` containing multiple colored rectangles. Each rectangle includes a black section that, when touched, disables the `ScrollView` for the duration of the `Pan` gesture.

```typescript
import { View, ScrollView } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const COLORS = ['red', 'green', 'blue', 'purple', 'orange', 'cyan'];

export default function App() {
  const native = Gesture.Native();

  return (
    <GestureDetector gesture={native}>
      <ScrollView style={{ flex: 1 }}>
        <ScrollableContent scrollGesture={native} />
      </ScrollView>
    </GestureDetector>
  );
}

function ScrollableContent({ scrollGesture }) {
  return (
    <View>
      {COLORS.map((color) => (
        <Rectangle key={color} color={color} scrollGesture={scrollGesture} />
      ))}
    </View>
  );
}

function Rectangle({ color, scrollGesture }) {
  const pan = Gesture.Pan().blocksExternalGesture(scrollGesture);

  return (
    <View
      key={color}
      style={{ width: '100%', height: 250, backgroundColor: color }}>
      <GestureDetector gesture={pan}>
        <View style={{ width: '100%', height: 50, backgroundColor: 'black' }} />
      </GestureDetector>
    </View>
  );
}
```

### Remarks

- The `Native` gesture can be used in gesture composition and cross-component interactions like any other gesture. This allows you to block a native component during the gesture or make it work alongside another gesture.

**Warning**: Do not use the `Native` gesture with components exported by React Native Gesture Handler, as they already have a native gesture handler applied. Attaching a native gesture twice may cause the components to malfunction.

### Configuration

#### Properties Specific to `NativeGesture`

##### `shouldActivateOnStart(value: boolean)` (**Android only**)

When set to `true`, the underlying handler will activate unconditionally upon receiving any touches in the `BEGAN` or `UNDETERMINED` state.

##### `disallowInterruption(value: boolean)`

When set to `true`, cancels all other gesture handlers when this `NativeViewGestureHandler` changes its state to `ACTIVE`.

#### Properties Common to All Gestures

##### `enabled(value: boolean)`

Indicates whether the handler should analyze touch events. When set to `false`, the handler's state will **never** become `ACTIVE`. If updated during gesture recognition, it will immediately change to `FAILED` or `CANCELLED`. Default is `true`.

##### `shouldCancelWhenOutside(value: boolean)`

When `true`, the handler cancels or fails recognition if a finger leaves the connected view area. The default varies by handler type; most handlers default to `false`, except for `LongPressGesture` and `TapGesture`, which default to `true`.

##### `hitSlop(settings)`

Controls the part of the connected view where gesture recognition can begin. Negative numbers reduce the view bounds evenly on all sides. Alternatively, specify reductions for each side (`left`, `right`, `top`, `bottom`) or use `horizontal`/`vertical`. You can also set `width` and `height` to restrict activation to edges.

**Important**: This parameter primarily reduces gesture activation areas. It supports non-positive values (0 or lower) on all sides, with positive values supported only on Android for expanding beyond view bounds but not past parent view bounds. For cross-platform support, use React Native's View hitSlop property.

##### `withRef(ref)`

Sets a ref to the gesture object for interoperability with the old API.

##### `withTestId(testID)`

Assigns a `testID` to the gesture object for querying in tests.

##### `cancelsTouchesInView(value)` (**iOS only**)

Accepts a boolean. When `true`, cancels touches for native UI components (`UIButton`, `UISwitch`, etc.) when active. Default is `true`.

##### `runOnJS(value: boolean)`

When `react-native-reanimated` is installed, gesture callbacks are workletized and run on the UI thread by default. This option allows running all callbacks on the JS thread instead, regardless of whether they are worklets or not. Defaults to `false`.

##### `simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`

Marks a gesture for simultaneous recognition with this one.

**Important**: This method only marks relations between gestures without composing them. The `otherGestures` need to be added to another detector for recognition by `GestureDetector`.

##### `requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`

Requires another gesture to fail before this one can activate.

##### `blocksExternalGesture(otherGesture1, otherGesture2, ...)`

Makes other gestures wait until this gesture fails or doesn't start.

**Important**: This method only marks relations between gestures without composing them. The `otherGestures` need to be added to another detector for recognition by `GestureDetector`.

##### `activeCursor(value)` (Web only)

Specifies the cursor used when the gesture activates, supporting all CSS cursor values (e.g., `"grab"`, `"zoom-in"`). Default is `"auto"`.

### Callbacks

#### Common to All Gestures

##### `onBegin(callback)`

Sets a callback called when the gesture handler starts receiving touches. At this point, it's not yet active or recognized.

##### `onStart(callback)`

Sets a callback called when the gesture is recognized and transitions to an active state.

##### `onEnd(callback)`

Sets a callback called when a recognized gesture finishes, only if previously active.

##### `onFinalize(callback)`

Sets a callback called when the handler finalizes handling a gestureâ€”either recognized and finished or failed.

##### `onTouchesDown(callback)`

Sets a callback for each finger placed on the screen.

##### `onTouchesMove(callback)`

Sets a callback for each finger movement on the screen.

##### `onTouchesUp(callback)`

Sets a callback for each finger lifted from the screen.

##### `onTouchesCancelled(callback)`

Sets a callback for when a finger stops being tracked, such as when a gesture finishes.

### Event Data

#### Specific to `NativeGesture`

##### `pointerInside`

Indicates if the gesture was performed inside the containing view (`true`) or outside (`false`).

#### Common to All Gestures

##### `state`

Represents the current state of the handler, expressed as one of the constants in the `State` object exported by the library.

##### `numberOfPointers`

The number of pointers (fingers) currently on the screen.

##### `pointerType`

Indicates the type of pointer device used. Represented by the `PointerType` enum:

- `TOUCH`: Represents a finger.
- `STYLUS`: Represents a stylus or digital pen.
- `MOUSE`: Represents a computer mouse.
- `KEY`: Represents a keyboard.
- `OTHER`: Represents an unknown device type that is not relevant.

## PinchGestureHandler

> **Warning:**\
> The old API will be deprecated in future versions of Gesture Handler. It is recommended to migrate to the gestures API. Refer to our upgrading guide for more details.

The `PinchGestureHandler` is a continuous gesture handler designed to recognize pinch gestures, which are commonly used to scale or zoom content on the screen. This handler activates when two fingers touch and move across the screen. The callback function associated with this gesture provides continuous tracking of the pinch gesture, offering insights into velocity, the focal point (anchor) of the gesture, and the scaling factor.

The distance between the fingers is represented as a scale factor. Initially, at the start of the gesture, the scale factor is set to 1.0. As the distance between the two fingers increases or decreases, the scale factor adjusts proportionally. Pinch gestures are frequently utilized for resizing objects or content onscreen, such as adjusting the zoom level in map views.

On iOS, this handler leverages `UIPinchGestureRecognizer`, while on Android, it is implemented from scratch.

### Properties

The properties specific to `PinchGestureHandler` do not extend beyond those provided by the base handler class.

### Event Data

For a comprehensive list of event attributes from the base handler class, refer to its documentation. Below are gesture event attributes unique to `PinchGestureHandler`:

- **`scale`:** Represents the scale factor relative to the screen coordinates of the two touch points.

- **`velocity`:** Indicates the velocity of the pinch gesture at the current moment, expressed in terms of scale factor per second.

- **`focalX`:** The X-axis position (in points) of the center anchor point of the gesture.

- **`focalY`:** The Y-axis position (in points) of the center anchor point of the gesture.

### Example

For a practical demonstration, refer to the scale and rotation example in the Gesture Handler Example App.

```typescript
import React from 'react';
import { Animated, View } from 'react-native';
import { PinchGestureHandler, State } from 'react-native-gesture-handler';

const USE_NATIVE_DRIVER = true;

export class PinchableBox extends React.Component {
  _baseScale = new Animated.Value(1);
  _pinchScale = new Animated.Value(1);
  _scale = Animated.multiply(this._baseScale, this._pinchScale);
  _lastScale = 1;

  _onPinchGestureEvent = Animated.event(
    [{ nativeEvent: { scale: this._pinchScale } }],
    { useNativeDriver: USE_NATIVE_DRIVER }
  );

  _onPinchHandlerStateChange = (event) => {
    if (event.nativeEvent.oldState === State.ACTIVE) {
      this._lastScale *= event.nativeEvent.scale;
      this._baseScale.setValue(this._lastScale);
      this._pinchScale.setValue(1);
    }
  };

  render() {
    return (
      <PinchGestureHandler
        onGestureEvent={this._onPinchGestureEvent}
        onHandlerStateChange={this._onPinchHandlerStateChange}>
        <View style={{ flex: 1 }} collapsable={false}>
          <Animated.Image
            source={{ uri: 'https://example.com/image.jpg' }}
            style={{
              width: 200,
              height: 200,
              transform: [
                { perspective: 200 },
                { scale: this._scale }
              ],
            }}
          />
        </View>
      </PinchGestureHandler>
    );
  }
}
```

This example demonstrates how to implement a pinchable box using `PinchGestureHandler` in React Native. The component tracks the pinch gesture and updates the image's scale accordingly.

## Force Touch Gesture Handler

The `ForceTouchGestureHandler` is a continuous gesture handler designed to recognize the force of touch. It tracks the pressure applied during a touch on certain iOS devices. The handler activates when the touch pressure meets or exceeds the specified `minForce`. If the pressure surpasses `maxForce`, the handler fails.

### Key Features

- **Pressure Tracking**: Monitors the pressure of touch, starting from 0.0 and scaling up to 1.0 as pressure increases.
- **iOS Implementation**: Utilizes a custom `UIGestureRecognizer` on iOS. No implementation is provided for Android; it simply renders children without additional wrappers.
- **Non-Critical Use**: Due to limited device support, this handler should not be used for critical behaviors but can enhance user experience.

### Properties

#### Inherited from Base Handler Class

Refer to the base handler class for common properties.

#### Specific to `ForceTouchGestureHandler`

##### `minForce`

- **Description**: The minimum pressure required to activate the handler.
- **Range**: `[0.0, 1.0]`
- **Default**: `0.2`

##### `maxForce`

- **Description**: The maximum allowable pressure before the handler fails.
- **Range**: `[0.0, 1.0]`

##### `feedbackOnActivation`

- **Type**: Boolean
- **Description**: Determines if haptic feedback should occur upon activation.

### Event Data

#### Inherited from Base Handler Class

Refer to the base handler class for common event attributes.

#### Specific to `ForceTouchGestureHandler`

##### `force`

- **Description**: Represents the pressure of a touch.

### Static Method

#### `forceTouchAvailable`

- **Usage**: Check if `ForceTouchGestureHandler` is supported using `ForceTouchGestureHandler.forceTouchAvailable`.

### Example Usage

```typescript
<ForceTouchGestureHandler
  minForce={0}
  onGestureEvent={this._onGestureEvent}
  onHandlerStateChange={this._onHandlerStateChange}>
  <Animated.View
    style={[
      styles.box,
      { transform: [{ scale: Animated.add(1, this.force) }] },
    ]}
  />
</ForceTouchGestureHandler>
```

**Note**: For a detailed example, refer to the Gesture Handler Example App.

## Manual gesture

A manual gesture lacks specific activation criteria and event data. Its state must be managed manually using a state manager, ensuring it doesn't fail when all pointers are lifted from the screen.

### Reference

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const manual = Gesture.Manual();

  return (
    <GestureDetector gesture={manual}>
      <Animated.View />
    </GestureDetector>
  );
}
```

### Configuration

#### Common Properties for All Gestures:

##### `enabled(value: boolean)`

Determines if the handler analyzes touch events. When set to `false`, the handler's state will **never** become `ACTIVE`. If updated during gesture recognition, it changes to `FAILED` or `CANCELLED` based on its current state. Default is `true`.

##### `shouldCancelWhenOutside(value: boolean)`

If `true`, the handler cancels or fails recognition when a finger leaves the connected view's area. Defaults vary by handler type; most are `false`, except for `LongPressGesture` and `TapGesture`, which default to `true`.

##### `hitSlop(settings)`

Controls the gesture activation area within the connected view. Negative numbers reduce bounds evenly on all sides. Alternatively, specify reductions with `left`, `right`, `top`, or `bottom`. Use `horizontal` or `vertical` for combined adjustments. `width` and `height` allow edge-specific activations (e.g., `left: 0` and `width: 20`). Note: Primarily reduces activation area; non-positive values are supported, with Android allowing positive values within parent bounds.

**IMPORTANT:** This parameter is designed to reduce the gesture activation area. It supports only non-positive values for all parameters except `width` and `height`. On Android, positive values are allowed but limited by parent view bounds. Use React Native's View hitSlop property for cross-platform edge effects.

##### `withRef(ref)`

Sets a ref to the gesture object for interoperability with older APIs.

##### `withTestId(testID)`

Assigns a `testID` to the gesture object, enabling test queries.

##### `cancelsTouchesInView(value)` (**iOS only**)

Accepts a boolean. When `true`, cancels touches for native UI components (`UIButton`, `UISwitch`, etc.) when active. Default is `true`.

##### `runOnJS(value: boolean)`

When `react-native-reanimated` is installed, callbacks are workletized and run on the UI thread by default. This option allows running all callbacks on the JS thread instead. Defaults to `false`.

##### `simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)`

Marks a gesture for simultaneous recognition with this one.

**IMPORTANT:** This method only marks relations between gestures without composing them. `GestureDetector` will not recognize `otherGestures`; they must be added to another detector for recognition.

##### `requireExternalGestureToFail(otherGesture1, otherGesture2, ...)`

Requires another gesture to fail before activation.

##### `blocksExternalGesture(otherGesture1, otherGesture2, ...)`

Waits for this gesture to fail (or not start) before activating others.

**IMPORTANT:** This method only marks relations between gestures without composing them. `GestureDetector` will not recognize `otherGestures`; they must be added to another detector for recognition.

##### `activeCursor(value)` (Web only)

Specifies the cursor used when the gesture activates, supporting all CSS cursor values (e.g., `"grab"`, `"zoom-in"`). Default is `"auto"`.

### Callbacks

#### Common Callbacks for All Gestures:

##### `onBegin(callback)`

Called when the handler starts receiving touches but hasn't yet recognized the gesture.

##### `onStart(callback)`

Triggered when the gesture is recognized and transitions to an active state.

##### `onEnd(callback)`

Invoked when a recognized gesture finishes, provided it was previously active.

##### `onFinalize(callback)`

Called when the handler finalizes handling a gestureâ€”either recognized and finished or failed.

##### `onTouchesDown(callback)`

Executed every time a finger touches the screen.

##### `onTouchesMove(callback)`

Triggered whenever a finger moves on the screen.

##### `onTouchesUp(callback)`

Invoked each time a finger is lifted from the screen.

##### `onTouchesCancelled(callback)`

Called when a finger stops being tracked, such as when a gesture finishes.

#### Common Callbacks for All Continuous Gestures:

##### `onUpdate(callback)`

Executed every time an active gesture receives an update.

##### `onChange(callback)`

Triggered with each update during an active gesture, providing change information relative to the last event.

### Event Data

#### Attributes Common to All Gestures:

##### `state`

Represents the handler's current state using constants from the `State` object exported by the library.

##### `numberOfPointers`

Indicates the number of pointers (fingers) currently on the screen.

##### `pointerType`

Specifies the pointer device type, represented by the `PointerType` enum with fields:

- `TOUCH`: Finger
- `STYLUS`: Stylus or digital pen
- `MOUSE`: Computer mouse
- `KEY`: Keyboard
- `OTHER`: Unknown device type

## Make sure to migrate off the \`RNGestureHandlerEnabledRootView\` (Android only)

The `RNGestureHandlerEnabledRootView`, required in Gesture Handler 1 for overriding `createRootView`, was deprecated in version 2.0 and removed by version 2.4 due to its association with difficult-to-debug crashes. If you're still using it, refer to the guide on migrating off RNGHEnabledRootView.

### Upgrading to the New API

Gesture Handler 2 introduces a new Gesture API along with the `GestureDetector` component, simplifying gesture declaration by reducing boilerplate code. Instead of separate components for each gesture type, `GestureDetector` attaches gestures based on configuration objects created using the `Gesture` object. Here's an example:

```typescript
const tapGesture = Gesture.Tap().onStart(() => {
  console.log('Tap!');
});

return (
  <GestureDetector gesture={tapGesture}>
    <View />
  </GestureDetector>
);
```

The new API eliminates `onGestureEvent` and `onHandlerStateChange`, handling state transitions internally. Key callbacks include:

- **`onBegin`**: Triggered when the gesture enters the `BEGAN` state.
- **`onStart`**: Activated when the gesture moves from `BEGAN` to `ACTIVE`.
- **`onUpdate`**: Called during each event in the `ACTIVE` state, replacing `onGestureEvent`.
- **`onChange`**: Follows `onUpdate`, providing change values since the last event.
- **`onEnd`**: Triggered when transitioning from `ACTIVE` to `END`, `FAILED`, or `CANCELLED`. The reason for ending is determined by a second argument.
- **`onFinalize`**: Called upon entering `END`, `FAILED`, or `CANCELLED`, regardless of whether the gesture was `ACTIVE`.

The distinction between `onEnd` and `onFinalize` lies in their activation: `onEnd` triggers only if the gesture was `ACTIVE`, while `onFinalize` activates if it reached `BEGAN`. Use `onEnd` for cleanup post-`onStart`, and `onFinalize` after `onBegin`.

#### Configuring Gestures

Gestures are configured using a builder-like pattern, where methods replace properties. For instance:

```typescript
return (
  <TapGestureHandler
    numberOfTaps={2}
    maxDurationMs={500}
    maxDelayMs={500}
    maxDist={10}
    onHandlerStateChange={({ nativeEvent }) => {
      if (nativeEvent.state === State.ACTIVE) {
        console.log('Tap!');
      }
    }}>
    <View />
  </TapGestureHandler>
);
```

This can be equivalently configured as:

```typescript
const tapGesture = Gesture.Tap()
  .numberOfTaps(2)
  .maxDuration(500)
  .maxDelay(500)
  .maxDistance(10)
  .onStart(() => {
    console.log('Tap!');
  });

return (
  <GestureDetector gesture={tapGesture}>
    <View />
  </GestureDetector>
);
```

Refer to the API Reference under Gestures for available modifiers.

#### Using Multiple Gestures on a Single View

Previously, stacking multiple gestures required deep component trees with `Animated.View` layers. For example:

```typescript
return (
  <TapGestureHandler ... >
    <Animated.View>
      <PanGestureHandler ... >
        <Animated.View>
          <PinchGestureHandler ... >
            <YourView />
          </PinchGestureHandler>
        </Animated.View>
      </PanGestureHandler>
    </Animated.View>
  </TapGestureHandler>
);
```

With `GestureDetector`, use the Gesture Composition API to stack gestures:

```typescript
const tapGesture = Gesture.Tap();
const panGesture = Gesture.Pan();
const pinchGesture = Gesture.Pinch();

return (
  <GestureDetector gesture={Gesture.Race(tapGesture, panGesture, pinchGesture)}>
    <YourView />
  </GestureDetector>
);
```

Use `Gesture.Simultaneous` for simultaneous recognition and `Gesture.Exclusive` for exclusive gestures.

#### Replacing `waitFor` and `simultaneousHandlers`

For relations between gestures on the same view, use the Gesture Composition API. For different views or old gesture handlers, replace `simultaneousHandlers` with `simultaneousWithExternalGesture`, and `waitFor` with `requireExternalGestureToFail`. Use `.withRef(refObject)` to pass a ref object to an old handler.

## Composed gestures

Composed gestures such as `Race`, `Simultaneous`, and `Exclusive` offer a straightforward method for establishing relationships between different gestures. For further information, refer to the section on Gesture Composition.

### Reference Example

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const panGesture = Gesture.Pan();
  const longPressGesture = Gesture.LongPress();

  // Compose gestures using Race
  const composedGesture = Gesture.Race(panGesture, longPressGesture);

  return (
    <GestureDetector gesture={composedGesture}>
      <Animated.View />
    </GestureDetector>
  );
}
```

This example demonstrates how to use the `Race` method to compose two gestures: a pan gesture and a long press gesture. The composed gesture is then used within a `GestureDetector` component, which wraps an `Animated.View`.

## Common handler properties

**Warning:** The old API will be removed in future versions of Gesture Handler. Please migrate to the gestures API instead. Refer to our upgrading guide for more information.

This page covers the common set of properties that all gesture handler components expose.

### Units

All handler component properties and event attributes representing onscreen dimensions are expressed in screen density-independent units known as "points." These units are commonly used in the React Native ecosystem (e.g., in the layout system). They do not map directly to physical pixels but correspond to iOS's points and Android's dp units.

### Properties

This section describes properties applicable to all gesture handler components:

#### `enabled`

- **Type:** Boolean
- **Description:** Indicates whether the handler should analyze a stream of touch events. When set to `false`, the handler's state will never become `ACTIVE`. If updated while recognizing a gesture, it changes to `FAILED` or `CANCELLED` based on its current state.
- **Default Value:** `true`

#### `shouldCancelWhenOutside`

- **Type:** Boolean
- **Description:** When `true`, the handler cancels or fails recognition if the finger leaves the connected view's area. The default value varies by handler type; most handlers default to `false`, except for `LongPressGestureHandler` and `TapGestureHandler`, which default to `true`.

#### `cancelsTouchesInView` (**iOS only**)

- **Type:** Boolean
- **Description:** When `true`, the handler cancels touches for native UI components (e.g., `UIButton`, `UISwitch`) it's attached to when active.
- **Default Value:** `true`

#### `simultaneousHandlers`

- **Type:** React ref object or array of refs
- **Description:** Allows activation even if other handlers provided by their refs are in an `ACTIVE` state. Prevents these handlers from cancelling the current handler upon activation. See cross-handler interaction for more details.

#### `waitFor`

- **Type:** React ref object or array of refs
- **Description:** The handler will not activate as long as handlers provided by their refs are in the `BEGAN` state. See cross-handler interaction for more details.

#### `hitSlop`

- **Description:** Controls the area within the connected view where gesture recognition can begin. A negative number reduces the view's bounds evenly on all sides. Alternatively, an object can specify reductions for each side (`left`, `right`, `top`, `bottom`) or use `horizontal`/`vertical`. The object may also include `width` and `height` attributes to restrict activation to edges.
- **Note:** Primarily designed to reduce the gesture activation area; supported values are non-positive (0 or lower) on all platforms except Android, where positive values expand beyond view bounds but not past parent view bounds. Use React Native's View hitSlop property for cross-platform support.

#### `userSelect` (**Web only**)

- **Type:** `"none" | "auto" | "text"`
- **Description:** Specifies the `userSelect` property applied to the underlying view.
- **Default Value:** `"none"`

#### `activeCursor` (**Web only**)

- **Type:** CSS cursor value (e.g., `"grab"`, `"zoom-in"`)
- **Description:** Specifies the cursor used when a gesture activates.
- **Default Value:** `"auto"`

#### `onGestureEvent`

- **Type:** Callback or `Animated.event`
- **Description:** Triggered for each touch event while the handler is in an ACTIVE state. The event payload varies by handler type, with common attributes documented below and specific ones on corresponding handler pages.

#### `onHandlerStateChange`

- **Type:** Callback or `Animated.event`
- **Description:** Triggered when the handler's state changes. Includes the same payload as `onGestureEvent` plus an `oldState` attribute representing the previous state before the change.

### Event Data

This section describes attributes of the event object provided to `onGestureEvent` and `onHandlerStateChange` callbacks:

#### `state`

- **Description:** Current state of the handler, expressed as one of the constants in the `State` object exported by the library. Refer to the handler state section for more details.

#### `numberOfPointers`

- **Description:** Represents the number of pointers (fingers) currently on the screen.

## Gestures (Version: 2.x)

### GestureDetector

The `GestureDetector` serves as the core component within RNGH2, tasked with creating and updating native gesture handlers based on the configuration of provided gestures. A key enhancement over previous versions is its ability to recognize multiple gestures simultaneously through gesture composition. It's important to note that `GestureDetector` does not support integration with the Animated API or Reanimated 1.

### Gesture

A `Gesture` object facilitates the creation and combination of various gestures, enabling more complex interactions.

### Pan Gesture

```typescript
<InteractiveExample />
```

### Tap Gesture

```typescript
<InteractiveExample />
```

### Long Press Gesture

```typescript
<InteractiveExample />
```

### Rotation Gesture

```typescript
<InteractiveExample />
```

### Pinch Gesture

```typescript
<InteractiveExample />
```

### Fling Gesture

```typescript
<InteractiveExample />
```

### Hover Gesture

```typescript
<InteractiveExample />
```

### Force Touch Gesture

This continuous gesture detects the force of a touch, allowing for pressure tracking on certain iOS devices.

### Native Gesture

A `Native Gesture` enables other touch handling components to function within RNGH's gesture system. This integration facilitates seamless interactions between gestures and native components, enabling them to establish relationships with other gestures.

### Manual Gesture

A `Manual Gesture` lacks specific activation criteria or event data. Its state must be managed manually using a state manager. Unlike other gestures, it does not fail when all pointers are removed from the screen.

### Composed Gestures

Composed gestures (Race, Simultaneous, Exclusive) offer an easy method for establishing relationships between gestures. For more information, refer to Gesture Composition.

### Touch Events

Attributes of touch events include various properties that define their behavior and characteristics.

### Gesture State Manager

The `GestureStateManager` allows manual control over gesture states. Note that react-native-reanimated is required for its use, as it enables synchronous execution of methods within worklets.

## Touch events

### Touch Event Attributes

- **eventType**: Indicates the type of event, such as finger placement on the screen, movement, lifting, or cancellation.

- **changedTouches**: An array containing objects for each touch affected by the event (placed down, moved, lifted, or cancelled).

- **allTouches**: An array with objects representing all active touches.

- **numberOfTouches**: A count of currently active touches.

> **Caution**: Do not rely on the order of items in `touches` as it may change during a gesture. Use the `id` attribute to track individual touches across events.

### PointerData Attributes

- **id**: A unique number representing the touch's ID, used for tracking the touch between events since the ID remains constant while being tracked.

- **x**: The X coordinate of the current position of the touch relative to the view attached to the `GestureDetector`, expressed in point units.

- **y**: The Y coordinate of the current position of the touch relative to the view attached to the `GestureDetector`, expressed in point units.

- **absoluteX**: The X coordinate of the current position of the touch relative to the window, expressed in point units. Recommended for use when the original view can be transformed due to a gesture.

- **absoluteY**: The Y coordinate of the current position of the touch relative to the window, expressed in point units. Recommended for use when the original view can be transformed due to a gesture.

## Gesture state manager

The `GestureStateManager` provides manual control over gesture states, requiring `react-native-reanimated` for synchronous execution of methods within worklets.

### Methods Overview

#### `begin()`

- **Purpose**: Transition the gesture to the `BEGAN` state.
- **Effectiveness**: Ineffective if the gesture is already active or has finished.

#### `activate()`

- **Purpose**: Transition the gesture to the `ACTIVE` state.
- **Effectiveness**: Ineffective if the handler is currently active or has finished. Activation may be delayed for gestures marked as `exclusive` until a higher-priority gesture fails.

#### `end()`

- **Purpose**: Transition the gesture to the `END` state.
- **Effectiveness**: Ineffective if the handler has already completed its process.

#### `fail()`

- **Purpose**: Transition the gesture to the `FAILED` state.
- **Effectiveness**: Ineffective if the handler has already finished.

## Touch events

### Touch Event Attributes

- **eventType**: Indicates the type of event, such as finger placement on the screen, movement, lifting, or cancellation.

- **changedTouches**: An array containing objects for each touch affected by the event (placed down, moved, lifted, or cancelled).

- **allTouches**: An array with objects representing all active touches.

- **numberOfTouches**: A count of currently active touches.

> **Caution**: Do not rely on the order of items in `touches` as it may change during a gesture. Use the `id` attribute to track individual touches across events.

### PointerData Attributes

- **id**: A unique number representing the touch's ID, used for tracking the touch between events since the ID remains constant while being tracked.

- **x**: The X coordinate of the current position of the touch relative to the view attached to the `GestureDetector`, expressed in point units.

- **y**: The Y coordinate of the current position of the touch relative to the view attached to the `GestureDetector`, expressed in point units.

- **absoluteX**: The X coordinate of the current position of the touch relative to the window, expressed in point units. Recommended for use when the original view can be transformed due to a gesture.

- **absoluteY**: The Y coordinate of the current position of the touch relative to the window, expressed in point units. Recommended for use when the original view can be transformed due to a gesture.

## Gesture state manager

The `GestureStateManager` provides manual control over gesture states, requiring `react-native-reanimated` for synchronous execution of methods within worklets.

### Methods Overview

#### `begin()`

- **Purpose**: Transition the gesture to the `BEGAN` state.
- **Effectiveness**: Ineffective if the gesture is already active or has finished.

#### `activate()`

- **Purpose**: Transition the gesture to the `ACTIVE` state.
- **Effectiveness**: Ineffective if the handler is currently active or has finished. Activation may be delayed for gestures marked as `exclusive` until a higher-priority gesture fails.

#### `end()`

- **Purpose**: Transition the gesture to the `END` state.
- **Effectiveness**: Ineffective if the handler has already completed its process.

#### `fail()`

- **Purpose**: Transition the gesture to the `FAILED` state.
- **Effectiveness**: Ineffective if the handler has already finished.

## GestureDetector

The `GestureDetector` is a key component within RNGH2, tasked with creating and updating native gesture handlers based on the configuration of provided gestures. A notable advancement over previous gesture handlers is its ability to recognize multiple gestures simultaneously through gesture composition. It's important to note that `GestureDetector` does not support the Animated API or Reanimated 1.

### Reference

```typescript
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

function App() {
  const tap = Gesture.Tap();
  return (
    <GestureDetector gesture={tap}>
      <Animated.View />
    </GestureDetector>
  );
}
```

### Properties

#### `gesture`

This property accepts a gesture object that includes configuration and callbacks. It can be any of the base gestures (`Tap`, `Pan`, `LongPress`, `Fling`, `Pinch`, `Rotation`, `ForceTouch`) or any composed gesture (`Race`, `Simultaneous`, `Exclusive`).

**Info:**\
The `GestureDetector` determines whether to use Reanimated for processing provided gestures based on their callbacks. If a callback is a worklet, Reanimated tools are utilized, enabling synchronous gesture handling.

Starting with Reanimated 2.3.0, Gesture Handler provides a StateManager in touch events, facilitating gesture state management.

#### `userSelect` (Web only)

This parameter specifies the `userSelect` property for the underlying view. Possible values include `"none"`, `"auto"`, or `"text"`. The default is set to `"none"`.

#### `touchAction` (Web only)

This parameter defines the `touchAction` property for the underlying view, supporting all CSS `touch-action` values such as `"none"` and `"pan-y"`. The default value is `"none"`.

#### `enableContextMenu(value: boolean)` (Web only)

Determines whether a context menu should be enabled after right-clicking on the underlying view. By default, this is set to `false`.

### Remarks

- **Gesture Recognition:**\
  Gesture Detector uses the first native view in its subtree for gesture recognition. If this view serves solely as a container for its children, it may be automatically collapsed. Consider the following example:

  ```typescript
  export default function Example() {
    const tap = Gesture.Tap().onStart(() => {
      console.log('tap');
    });

    return (
      <GestureDetector gesture={tap}>
        <FunctionalComponent>
          <View style={styles.box} />
        </FunctionalComponent>
      </GestureDetector>
    );
  }

  function FunctionalComponent(props) {
    return <View collapsable={false}>{props.children}</View>;
  }
  ```

  Removing the `collapsable` prop from the View would cause the gesture to malfunction, as it would be attached to a view absent in the hierarchy. Gesture Detector automatically adds this prop to its direct child but cannot do so for more complex view trees.

- **Gesture Instance Usage:**\
  Using the same instance of a gesture across multiple Gesture Detectors is not feasible. Consider the following code:

  ```typescript
  export default function Example() {
    const pan = Gesture.Pan();

    return (
      <View>
        <GestureDetector gesture={pan}>
          <View>
            <GestureDetector gesture={pan}> {/* Avoid this! */}
              <View />
            </GestureDetector>
          </View>
        </GestureDetector>
      </View>
    );
  }
  ```

  This example will result in an error because it attempts to use the same `Pan` instance in two different Gesture Detectors.

## Buttons

The Gesture Handler library offers native components designed to function as buttons. These components serve as alternatives to `TouchableHighlight` or `TouchableOpacity` from React Native's core library. The key advantages of using Gesture Handler's buttons include:

- **Native Touch Recognition**: They recognize touches natively, ensuring a deterministic process.
- **High Performance on Android**: Enables rendering ripples efficiently with `TouchableNativeFeedback`, avoiding the lag caused by touch events needing to return to JavaScript before updating ripple effectsâ€”a common issue on older devices.
- **Optimized Interaction in Scrollable Containers**: Provides native and platform-specific default interactions for buttons within scrollable containers, where interaction is slightly delayed. This delay prevents premature button highlighting during flinging actions.

These features enhance the user experience by ensuring smooth and responsive button interactions across different platforms and device capabilities.

## Gesture

`Gesture` is an object that facilitates the creation and composition of gestures.

### Reference

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const tap = Gesture.Tap();

  return (
    <GestureDetector gesture={tap}>
      <Animated.View />
    </GestureDetector>
  );
}
```

#### Gesture Methods

- **`Gesture.Tap()`**: Creates a `TapGesture` instance with default configuration and no callbacks.

- **`Gesture.Pan()`**: Generates a `PanGesture` instance with default settings and no callbacks.

- **`Gesture.LongPress()`**: Produces a `LongPressGesture` instance with default configuration and no callbacks.

- **`Gesture.Fling()`**: Forms a `FlingGesture` instance with default setup and no callbacks.

- **`Gesture.Pinch()`**: Constructs a `PinchGesture` instance with default parameters and no callbacks.

- **`Gesture.Rotation()`**: Establishes a `RotationGesture` instance with default configuration and no callbacks.

- **`Gesture.Hover()`**: Creates a `HoverGesture` instance with default settings and no callbacks.

- **`Gesture.ForceTouch()`**: Generates a `ForceTouchGesture` instance with default configuration and no callbacks.

- **`Gesture.Manual()`**: Forms a `ManualGesture` instance with default setup and no callbacks.

- **`Gesture.Native()`**: Produces a `NativeGesture` instance with default parameters and no callbacks.

#### Gesture Composition

- **`Gesture.Race(gesture1, gesture2, gesture3, ...)`**: Composes gestures such that only one can be active at any time. The first to activate cancels the others.

- **`Gesture.Simultaneous(gesture1, gesture2, gesture3, ...)`**: Allows all provided gestures to become active simultaneously without cancelling each other.

- **`Gesture.Exclusive(gesture1, gesture2, gesture3, ...)`**: Composes gestures where only one can be active at a time. The first has the highest priority, followed by subsequent ones in order. Useful for composing similar activation criteria gestures (e.g., single and double tap).

### Remarks

- To optimize performance, consider using `useMemo` to wrap gesture configurations. This reduces the workload for Gesture Handler during updates.

```typescript
import React from "react"

function App() {
  const gesture = React.useMemo(
    () =>
      Gesture.Tap().onStart(() => {
        console.log("Number of taps:", tapNumber + 1)
        setTapNumber((value) => value + 1)
      }),
    [tapNumber, setTapNumber]
  )
  // ...
}
```

## Drawer Layout

> **Caution:** This is a cross-platform alternative to React Native's `DrawerLayoutAndroid` component. It offers a compatible API and can be used on both Android and iOS platforms. For detailed usage of standard parameters, refer to the React Native documentation.

### Usage:

The `DrawerLayout` component is not exported by default from the `react-native-gesture-handler` package. To use it, import as follows:

```typescript
import DrawerLayout from "react-native-gesture-handler/DrawerLayout"
```

### Properties:

In addition to standard parameters, `DrawerLayout` includes additional attributes for customization:

#### `drawerType`

- **Possible values:** `front`, `back`, or `slide` (default is `front`)
- **Description:**
  - `front`: The drawer slides in and out with the gesture, appearing on top of the content view.
  - `back`: The drawer appears behind the content view and can be revealed by pulling the content view to the side.
  - `slide`: The drawer seems attached to the side of the content view; both the content view and drawer follow the gesture.

#### `edgeWidth`

- **Type:** number
- **Description:** Defines how far from the edge of the content view the gesture should activate.

#### `hideStatusBar`

- **Type:** boolean
- **Description:** When set to `true`, the Drawer component uses the StatusBar API to hide the OS status bar when the drawer is pulled or open.

#### `statusBarAnimation`

- **Possible values:** `slide`, `none`, or `fade` (default is `slide`)
- **Description:** Used with `hideStatusBar` set to `true` to select the animation for hiding/showing the status bar. See StatusBar documentation for more details.

#### `overlayColor`

- **Type:** color (default: `"black"`)
- **Description:** Specifies a semi-transparent overlay color displayed on top of the content view when the drawer is open. The opacity is animated from 0% to 70%.

#### `renderNavigationView`

- **Type:** function
- **Description:** This attribute allows the function passed as `renderNavigationView` to take an Animated value indicating the progress of the drawer's opening/closing animation (progress value: 0 when closed, 1 when opened). It can be used to animate children components during this process.

#### `onDrawerClose`

- **Type:** function
- **Description:** Called when the drawer is closed.

#### `onDrawerOpen`

- **Type:** function
- **Description:** Called when the drawer is opened.

#### `onDrawerSlide`

- **Type:** function
- **Description:** Called during a drawer slide open from touch events. The progress of the drawer opening/closing (0 when closed, 1 when opened) is passed back.

#### `onDrawerStateChanged`

- **Type:** function
- **Arguments:**
  - `newState`: `DrawerState` - State of the `Drawer`. Possible values:
    - `Idle`
    - `Dragging`
    - `Settling`
  - `drawerWillShow`: boolean - Indicates if the drawer is about to open.

#### `enableTrackpadTwoFingerGesture` (iOS only)

- **Type:** boolean
- **Description:** Enables two-finger gestures on supported devices, such as iPads with trackpads. Without this enabled, a click + drag gesture is required; otherwise, swiping with two fingers will trigger the gesture.

#### `children`

- **Type:** component or function
- **Description:** The default child component rendered and wrapped by the drawer. It can also be a render function that takes an Animated value indicating the progress of the drawer's opening/closing animation (progress value: 0 when closed, 1 when opened), similar to `renderNavigationView`.

#### `mouseButton(value: MouseButton)` (Web & Android only)

- **Type:** enum
- **Description:** Allows users to choose which mouse button should trigger the handler. The `MouseButton` enum includes:
  - `LEFT`
  - `RIGHT`
  - `MIDDLE`
  - `BUTTON_4`
  - `BUTTON_5`
  - `ALL`
- **Usage:** Arguments can be combined using the `|` operator, e.g., `mouseButton(MouseButton.LEFT | MouseButton.RIGHT)`. Default is set to `MouseButton.LEFT`.

#### `enableContextMenu(value: boolean)` (Web only)

- **Type:** boolean
- **Description:** Specifies whether a context menu should be enabled after clicking on the underlying view with the right mouse button. Default value is `false`.

### Methods:

#### `openDrawer(options)`

- **Description:** Can take an optional `options` parameter for customizing the open animation.
- **Options:**
  - `velocity`: number, initial velocity of the object attached to the spring (default: 0).
  - `speed`: number, controls speed of the animation (default: 12).

#### `closeDrawer(options)`

- **Description:** Can take an optional `options` parameter for customizing the close animation.
- **Options:**
  - `velocity`: number, initial velocity of the object attached to the spring (default: 0).
  - `speed`: number, controls speed of the animation (default: 12).

### Example:

See the drawer example from the GestureHandler Example App or view it directly on your phone by visiting our Expo demo.

```typescript
class Drawerable extends Component {
  handleDrawerSlide = (status) => {
    // Outputs a value between 0 and 1
    console.log(status);
  };

  renderDrawer = () => {
    return (
      <View>
        <Text>I am in the drawer!</Text>
      </View>
    );
  };

  render() {
    return (
      <View style={{ flex: 1 }}>
        <DrawerLayout
          drawerWidth={200}
          drawerPosition={DrawerLayout.positions.Right}
          drawerType="front"
          drawerBackgroundColor="#ddd"
          renderNavigationView={this.renderDrawer}
          onDrawerSlide={this.handleDrawerSlide}>
          <View>
            <Text>Hello, it's me</Text>
          </View>
        </DrawerLayout>
      </View>
    );
  }
}
```

## Gesture composition & interactions

In RNGH2, composing gestures has been simplified compared to previous versions. There is no longer a need to create a reference for each gesture that depends on another one. Instead, you can utilize the Race, Simultaneous, and Exclusive methods provided by the Gesture object.

### Methods for Composing Gestures

- **Race**: This method allows multiple gestures to compete against each other. The first gesture to complete will be recognized.

- **Simultaneous**: With this method, multiple gestures are required to occur at the same time in order to trigger an action.

- **Exclusive**: This method ensures that only one specific gesture can be recognized at a time, preventing overlap with others.

These methods facilitate more intuitive and flexible gesture interactions within your application.

## Manual gestures

RNGH2 introduces manual gestures and touch events, allowing for custom gesture tracking. This guide demonstrates creating a simple gesture that tracks all pointers on the screen.

### Step 1: Define Pointer Information

First, define an interface to store pointer information, including visibility and position:

```typescript
interface Pointer {
  visible: boolean
  x: number
  y: number
}
```

### Step 2: Create a Pointer Element Component

Create a component that displays the pointer's location. It uses shared values for pointer data and gesture activation status. The pointer is represented by a ball, changing color and size based on its state:

```typescript
import { StyleSheet } from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
} from 'react-native-reanimated';

function PointerElement(props: {
  pointer: Animated.SharedValue<Pointer>,
  active: Animated.SharedValue<boolean>,
}) {
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: props.pointer.value.x },
      { translateY: props.pointer.value.y },
      {
        scale:
          (props.pointer.value.visible ? 1 : 0) *
          (props.active.value ? 1.3 : 1),
      },
    ],
    backgroundColor: props.active.value ? 'red' : 'blue',
  }));

  return <Animated.View style={[styles.pointer, animatedStyle]} />;
}

const styles = StyleSheet.create({
  pointer: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: 'red',
    position: 'absolute',
    marginStart: -30,
    marginTop: -30,
  },
});
```

### Step 3: Handle Gesture and Draw Pointers

Create a component to manage the gesture, storing pointer data in an array. Render pointers within an `Animated.View`:

```typescript
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

export default function Example() {
  const trackedPointers: Animated.SharedValue<Pointer>[] = [];
  const active = useSharedValue(false);

  for (let i = 0; i < 12; i++) {
    trackedPointers[i] =
      useSharedValue <
      Pointer >
      {
        visible: false,
        x: 0,
        y: 0,
      };
  }

  const gesture = Gesture.Manual();

  return (
    <GestureDetector gesture={gesture}>
      <Animated.View style={{ flex: 1 }}>
        {trackedPointers.map((pointer, index) => (
          <PointerElement pointer={pointer} active={active} key={index} />
        ))}
      </Animated.View>
    </GestureDetector>
  );
}
```

### Step 4: Implement onTouchesDown

Set up the gesture to track pointers on touch down. Activate the gesture if there are at least two touches:

```typescript
const gesture = Gesture.Manual().onTouchesDown((e, manager) => {
  for (const touch of e.changedTouches) {
    trackedPointers[touch.id].value = {
      visible: true,
      x: touch.x,
      y: touch.y,
    }
  }

  if (e.numberOfTouches >= 2) {
    manager.activate()
  }
})
```

### Step 5: Handle onTouchesMove

Update pointer positions during movement:

```typescript
const gesture = Gesture.Manual()
    ...
    .onTouchesMove((e, _manager) => {
      for (const touch of e.changedTouches) {
        trackedPointers[touch.id].value = {
          visible: true,
          x: touch.x,
          y: touch.y,
        };
      }
    })
```

### Step 6: Implement onTouchesUp

Hide pointers on lift and end the gesture if no touches remain:

```typescript
const gesture = Gesture.Manual()
    ...
    .onTouchesUp((e, manager) => {
      for (const touch of e.changedTouches) {
        trackedPointers[touch.id].value = {
          visible: false,
          x: touch.x,
          y: touch.y,
        };
      }

      if (e.numberOfTouches === 0) {
        manager.end();
      }
    })
```

### Step 7: Manage Gesture Activation

Control gesture activation state using shared values:

```typescript
const gesture = Gesture.Manual()
  ...
  .onStart(() => {
    active.value = true;
  })
  .onEnd(() => {
    active.value = false;
  });
```

Manual gestures offer powerful customization, enabling complex interactions. Additionally, existing gestures can be modified with `manualActivation` to control activation behavior, such as implementing drag after a long press by setting `manualActivation` on a `PanGesture`.

## Pressable

### Overview

The `Pressable` component is a versatile drop-in replacement for the standard `Pressable` component. It detects various stages of tap, press, and hover interactions on its children.

#### Importing

To use `Pressable`, import it as follows:

```typescript
import { Pressable } from "react-native-gesture-handler"
```

### Properties

|Property|Description|
|-|-|
|`children`|Accepts either children or a render function that receives a boolean indicating if the component is currently pressed.|
|`style`|Can be view styles or a function receiving a boolean reflecting the press state and returning view styles.|
|`onPress`|Triggered after `onPressOut` when a single tap gesture is detected.|
|`onPressIn`|Called before `onPress` when a touch is engaged.|
|`onPressOut`|Called before `onPress` when a touch is released.|
|`onLongPress`|Triggered immediately after the pointer has been down for at least `delayLongPress` milliseconds (default: 500 ms). After this, `onPressOut` will be called upon pointer lift and `onPress` won't trigger.|
|`cancelable`|Determines if a press gesture can be interrupted by a parent gesture like scrolling. Defaults to `true`.|
|`onHoverIn` (Web only)|Called when the pointer hovers over the element.|
|`onHoverOut` (Web only)|Triggered when the pointer stops hovering over the element.|
|`delayHoverIn` (Web only)|Duration to wait after hover in before calling `onHoverIn`.|
|`delayHoverOut` (Web only)|Duration to wait after hover out before calling `onHoverOut`.|
|`delayLongPress`|Time in milliseconds from `onPressIn` before `onLongPress` is called.|
|`disabled`|Disables the `Pressable` behavior if set to true.|
|`hitSlop` (Android & iOS only)|Additional distance outside of the view where a press is detected and `onPressIn` is triggered. Accepts `number` or `Rect`.|
|`pressRetentionOffset` (Android & iOS only)|Extra distance outside of the view (or `hitSlop` if present) to consider a touch as a press before `onPressOut` is triggered. Accepts `number` or `Rect`.|
|`android_disableSound` (Android only)|If true, prevents system sound on touch.|
|`android_ripple` (Android only)|Enables the Android ripple effect and configures its color, radius, etc. Accepts `RippleConfig`.|
|`testOnly_pressed`|Used for documentation or testing purposes (e.g., snapshot testing).|
|`unstable_pressDelay`|Duration in milliseconds to wait after press down before calling `onPressIn`.|

### Example

Below is an example demonstrating the use of `Pressable`:

```typescript
import { View, Text, StyleSheet } from 'react-native';
import { Pressable } from 'react-native-gesture-handler';

export default function Example() {
  return (
    <Pressable
      style={({ pressed }) => (pressed ? styles.highlight : styles.pressable)}
      hitSlop={20}
      pressRetentionOffset={20}>
      <View style={styles.textWrapper}>
        <Text style={styles.text}>Pressable!</Text>
      </View>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  pressable: {
    width: 120,
    height: 120,
    backgroundColor: 'mediumpurple',
    borderWidth: StyleSheet.hairlineWidth,
  },
  highlight: {
    width: 120,
    height: 120,
    backgroundColor: 'red',
    borderWidth: StyleSheet.hairlineWidth,
  },
  textWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: 'black',
  },
});
```

## Gesture composition & interactions

Composing gestures in RNGH2 is straightforward. You don't need to create a ref for each gesture that depends on another one. Instead, use `Race`, `Simultaneous`, and `Exclusive` methods provided by the `Gesture` object.

### Race

The `Race` method allows only one of the provided gestures to become active at any time. The first gesture to activate will cancel the others. It accepts a variable number of arguments and is equivalent to having multiple gesture handlers without defining `simultaneousHandlers` or `waitFor` props.

#### Example: Draggable Component with Long Press

Consider a component that should be draggable, but also show additional options on long press. You can use `Race` to ensure the component doesn't move after a long press activates:

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

function App() {
  const offset = useSharedValue({ x: 0, y: 0 });
  const start = useSharedValue({ x: 0, y: 0 });
  const popupPosition = useSharedValue({ x: 0, y: 0 });
  const popupAlpha = useSharedValue(0);

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [
      { translateX: offset.value.x },
      { translateY: offset.value.y },
    ],
  }));

  const animatedPopupStyles = useAnimatedStyle(() => ({
    transform: [
      { translateX: popupPosition.value.x },
      { translateY: popupPosition.value.y },
    ],
    opacity: popupAlpha.value,
  }));

  const dragGesture = Gesture.Pan()
    .onStart((_e) => {
      popupAlpha.value = withTiming(0);
    })
    .onUpdate((e) => {
      offset.value = {
        x: e.translationX + start.value.x,
        y: e.translationY + start.value.y,
      };
    })
    .onEnd(() => {
      start.value = { x: offset.value.x, y: offset.value.y };
    });

  const longPressGesture = Gesture.LongPress().onStart((_event) => {
    popupPosition.value = { x: offset.value.x, y: offset.value.y };
    popupAlpha.value = withTiming(1);
  });

  const composed = Gesture.Race(dragGesture, longPressGesture);

  return (
    <Animated.View>
      <Popup style={animatedPopupStyles} />
      <GestureDetector gesture={composed}>
        <Component style={animatedStyles} />
      </GestureDetector>
    </Animated.View>
  );
}
```

### Simultaneous

The `Simultaneous` method allows all provided gestures to activate at the same time. Activation of one does not cancel the others, similar to having gesture handlers with each set to `simultaneousHandlers`.

#### Example: Gallery App with Zoom, Rotate, and Pan

For a gallery app where users can zoom, rotate, and pan photos simultaneously:

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

function App() {
  const offset = useSharedValue({ x: 0, y: 0 });
  const start = useSharedValue({ x: 0, y: 0 });
  const scale = useSharedValue(1);
  const savedScale = useSharedValue(1);
  const rotation = useSharedValue(0);
  const savedRotation = useSharedValue(0);

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [
      { translateX: offset.value.x },
      { translateY: offset.value.y },
      { scale: scale.value },
      { rotateZ: `${rotation.value}rad` },
    ],
  }));

  const dragGesture = Gesture.Pan()
    .averageTouches(true)
    .onUpdate((e) => {
      offset.value = {
        x: e.translationX + start.value.x,
        y: e.translationY + start.value.y,
      };
    })
    .onEnd(() => {
      start.value = { x: offset.value.x, y: offset.value.y };
    });

  const zoomGesture = Gesture.Pinch()
    .onUpdate((event) => {
      scale.value = savedScale.value * event.scale;
    })
    .onEnd(() => {
      savedScale.value = scale.value;
    });

  const rotateGesture = Gesture.Rotation()
    .onUpdate((event) => {
      rotation.value = savedRotation.value + event.rotation;
    })
    .onEnd(() => {
      savedRotation.value = rotation.value;
    });

  const composed = Gesture.Simultaneous(
    dragGesture,
    Gesture.Simultaneous(zoomGesture, rotateGesture)
  );

  return (
    <Animated.View>
      <GestureDetector gesture={composed}>
        <Photo style={animatedStyles} />
      </GestureDetector>
    </Animated.View>
  );
}
```

### Exclusive

The `Exclusive` method allows only one of the provided gestures to become active at a time, with priority given in order. It is equivalent to having gesture handlers where each subsequent handler has its `waitFor` prop set to all preceding ones.

#### Example: Single Tap and Double Tap

To create a component that responds to both single tap and double tap:

```typescript
import { GestureDetector, Gesture } from 'react-native-gesture-handler';

function App() {
  const singleTap = Gesture.Tap().onEnd((_event, success) => {
    if (success) {
      console.log('single tap!');
    }
  });

  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onEnd((_event, success) => {
      if (success) {
        console.log('double tap!');
      }
    });

  const composed = Gesture.Exclusive(singleTap, doubleTap);

  return (
    <GestureDetector gesture={composed}>
      <Component />
    </GestureDetector>
  );
}
```

### Cross-Component Gesture Interactions

#### blocksExternalGesture

`blocksExternalGesture` is used to make a component wait for gestures from other components. It's useful in lists where the `ScrollView` needs to wait for gestures on its children.

```typescript
import React, { useRef } from 'react';
import { StyleSheet } from 'react-native';
import {
  GestureDetector,
  Gesture,
  GestureHandlerRootView,
  ScrollView,
} from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

const ITEMS = ['red', 'green', 'blue', 'yellow'];

function Item({ backgroundColor, scrollRef }) {
  const scale = useSharedValue(1);
  const zIndex = useSharedValue(1);

  const pinch = Gesture.Pinch()
    .blocksExternalGesture(scrollRef)
    .onBegin(() => {
      zIndex.value = 100;
    })
    .onChange((e) => {
      scale.value *= e.scaleChange;
    })
    .onFinalize(() => {
      scale.value = withTiming(1, undefined, (finished) => {
        if (finished) {
          zIndex.value = 1;
        }
      });
    });

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    zIndex: zIndex.value,
  }));

  return (
    <GestureDetector gesture={pinch}>
      <Animated.View
        style={[
          { backgroundColor: backgroundColor },
          styles.item,
          animatedStyles,
        ]}
      />
    </GestureDetector>
  );
}

export default function Example() {
  const scrollRef = useRef();

  return (
    <GestureHandlerRootView style={styles.container}>
      <ScrollView style={styles.container} ref={scrollRef}>
        {ITEMS.map((item) => (
          <Item backgroundColor={item} key={item} scrollRef={scrollRef} />
        ))}
      </ScrollView>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  item: {
    flex: 1,
    aspectRatio: 1,
  },
});
```

#### simultaneousWithExternalGesture

`simultaneousWithExternalGesture` allows gestures across different components to be recognized simultaneously.

```typescript
import React from 'react';
import { View, StyleSheet } from 'react-native';
import {
  GestureDetector,
  Gesture,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';

export default function Example() {
  const innerTap = Gesture.Tap().onStart(() => {
    console.log('inner tap');
  });

  const outerTap = Gesture.Tap()
    .onStart(() => {
      console.log('outer tap');
    })
    .simultaneousWithExternalGesture(innerTap);

  return (
    <GestureHandlerRootView style={styles.container}>
      <GestureDetector gesture={outerTap}>
        <View style={styles.outer}>
          <GestureDetector gesture={innerTap}>
            <View style={styles.inner} />
          </GestureDetector>
        </View>
      </GestureDetector>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  outer: {
    width: 250,
    height: 250,
    backgroundColor: 'lightblue',
  },
  inner: {
    width: 100,
    height: 100,
    backgroundColor: 'blue',
    alignSelf: 'center',
  },
});
```

## Reanimated Drawer Layout

A cross-platform alternative to React Native's `DrawerLayoutAndroid`. For standard parameter usage, refer to the React Native documentation.

### Usage:

Import as follows:

```typescript
import ReanimatedDrawerLayout from "react-native-gesture-handler/ReanimatedDrawerLayout"
```

### Properties:

#### `drawerType`

Defines how the drawer is displayed. Accepts values from the `DrawerPosition` enum. Defaults to `FRONT`.

- **`FRONT`**: Drawer appears above the content view.
- **`BACK`**: Drawer appears below the content view, revealed by sliding away the content view.
- **`SLIDE`**: Drawer slides with the content view.

|`FRONT`|`BACK`|`SLIDE`|
|-|-|-|

#### `edgeWidth`

Specifies the width of the invisible, draggable area on the edge of the content view to open the drawer.

#### `hideStatusBar`

A boolean value. When set to `true`, hides the OS status bar when the drawer is dragged or idle in the `open` position using the StatusBar API.

#### `statusBarAnimation`

Defines the animation for hiding the status bar, with possible values: `slide`, `none`, or `fade`. Defaults to `slide`. Used with `hideStatusBar`.

#### `overlayColor`

Sets the background overlay color on top of the content window when the drawer is open. The opacity animates from 0% to 100% as the drawer transitions from closed to open. Defaults to `rgba(0, 0, 0, 0.7)`.

#### `renderNavigationView`

A function renderer for the drawer component, provided with a `progress` parameter:

- **`progress`**: A `SharedValue` indicating the progress of the drawer's opening/closing animation (0 when closed, 1 when open).

#### `onDrawerClose`

Function called when the drawer is closed.

#### `onDrawerOpen`

Function called when the drawer is opened.

#### `onDrawerSlide`

Function called during drawer movement or animation, provided with a `progress` parameter:

- **`progress`**: A `SharedValue` indicating the progress of the drawer's opening/closing animation (0 when closed, 1 when open).

#### `onDrawerStateChanged`

Function called when the drawer's status changes. Takes two arguments:

- **`newState`**: Interaction state of the drawer (`DrawerState.IDLE`, `DrawerState.DRAGGING`, or `DrawerState.SETTLING`).
- **`drawerWillShow`**: `true` if the drawer is animating to open, otherwise `false`.

#### `enableTrackpadTwoFingerGesture` (iOS only)

Enables two-finger gestures on supported devices. Without this, a click + drag gesture is required.

#### `children`

Either a component rendered in the content view or a function provided with a `progress` parameter:

- **`progress`**: A `SharedValue` indicating the progress of the drawer's opening/closing animation (0 when closed, 1 when open).

#### `mouseButton(value: MouseButton)` (Web & Android only)

Allows selection of mouse button for gesture handling. The enum `MouseButton` includes:

- `LEFT`
- `RIGHT`
- `MIDDLE`
- `BUTTON_4`
- `BUTTON_5`
- `ALL`

Values can be combined using the `|` operator, defaulting to `MouseButton.LEFT`.

#### `enableContextMenu(value: boolean)` (Web only)

Specifies if a context menu should appear after right-clicking on the underlying view. Defaults to `false`.

### Methods:

#### `openDrawer(options)`

Opens the drawer with optional parameters:

- **`initialVelocity`**: Initial velocity of the spring object, default is `0`.
- **`animationSpeed`**: Controls animation speed, default is `1`.

#### `closeDrawer(options)`

Closes the drawer with optional parameters:

- **`initialVelocity`**: Initial velocity of the spring object, default is `0`.
- **`animationSpeed`**: Controls animation speed, default is `1`.

### Example:

```typescript
import React, { useRef } from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

import ReanimatedDrawerLayout, {
  DrawerType,
  DrawerPosition,
  DrawerLayoutMethods,
} from 'react-native-gesture-handler/ReanimatedDrawerLayout';

const DrawerPage = () => (
  <View style={styles.drawerContainer}>
    <Text>Lorem ipsum</Text>
  </View>
);

export default function ReanimatedDrawerExample() {
  const drawerRef = useRef<DrawerLayoutMethods>(null);
  const tapGesture = Gesture.Tap()
    .runOnJS(true)
    .onStart(() => drawerRef.current?.openDrawer());

  return (
    <ReanimatedDrawerLayout
      ref={drawerRef}
      renderNavigationView={() => <DrawerPage />}
      drawerPosition={DrawerPosition.LEFT}
      drawerType={DrawerType.FRONT}>
      <View style={styles.innerContainer}>
        <GestureDetector gesture={tapGesture}>
          <View style={styles.box}>
            <Text>Open drawer</Text>
          </View>
        </GestureDetector>
      </View>
    </ReanimatedDrawerLayout>
  );
}

const styles = StyleSheet.create({
  drawerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'pink',
  },
  innerContainer: {
    flex: 1,
    backgroundColor: 'white',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 20,
  },
  box: {
    padding: 20,
    backgroundColor: 'pink',
  },
});
```

## Introduction

Gesture Handler offers a declarative API that taps into the native platform's touch and gesture systems, providing an alternative to React Native's built-in Gesture Responder System. By leveraging native touch handling, it addresses performance limitations inherent in the Gesture Responder System while offering enhanced control over native components capable of managing gestures independently. For further insights, consider watching a talk by Krzysztof Magiera that delves into issues with the responder system.

The primary advantages of using React Native Gesture Handler include:

- Utilizing the platform's native touch handling for gesture recognition (e.g., pinch, rotation, pan).
- Defining relationships between gestures to prevent conflicts among gestures and native components.
- Mechanisms for employing touchable components that operate on a native thread while adhering to default platform behaviors; for instance, delaying the pressed state in scrollable components to avoid highlighting during flinging.
- Seamless integration with `react-native-reanimated` for processing touch events on the UI thread.
- Support for various input devices such as touch screens, pens, and mice.
- Capability to incorporate any native component into Gesture Handler's touch system, allowing it to function alongside custom gestures.

**Info:** It is recommended to use Reanimated for implementing gesture-driven animations with Gesture Handler. Its advanced features heavily depend on worklets and the UI runtime provided by Reanimated.

### Learning Resources

#### Apps

- **Gesture Handler Example App**: The official showcase app for Gesture Handler.

#### Talks and Workshops

- **Declarative Future of Gestures and Animations in React Native** by Krzysztof Magiera: This talk explains the motivation behind creating the gesture handler library, along with an introduction to react-native-reanimated and its use cases with Gesture Handler.

- **React Native Workshop with Expo Team @ReactEurope 2018** by Brent Vatne: A comprehensive workshop detailing Gesture Handler and offering exercises for beginners.

- **Living in an Async World of React Native** by Krzysztof Magiera: This talk highlights issues with React Native's touch system that Gesture Handler aims to resolve, explaining the motivation behind its development.

- **React Native Touch & Gesture** by Krzysztof Magiera: A presentation on the limitations of the JS responder system and core features of Gesture Handler.

### Contributing

If you're interested in contributing or supporting this project, feel free to reach out to any team member via Twitter or Bluesky (links below). All pull requests are welcome; however, please discuss with us before embarking on significant projects.

To start contributing code:

- Review open issues and tackle one that seems manageable.
- Update documentation when you find information unclear, missing, or outdated.

Contributions aren't limited to code. Consider responding to issues if you can offer assistance.

### Community

We are proud of the community built around this package and appreciate all forms of help, whether it's a pull request, issue report, comments on existing issues, or sharing demos and tutorials on social media. If you've created something with this library that you'd like to share, please contact usâ€”we're eager to promote your work.

#### Gesture Handler Team ðŸš€

- Jakub Piasecki
- MichaÅ‚ Bert
- Ignacy ÅÄ…tka
- Krzysztof Magiera

#### Sponsors

We are grateful for our sponsors who enable the development of this library and contribute to enhancing the React Native ecosystem. Special thanks to all our supporters!

## Troubleshooting

### Seeking Help with Issues

Thank you for trying out this library! If you encounter any issues, here's how to get assistance:

1. **Check GitHub Issues**: Look through existing issues on GitHub; someone might have already resolved a similar problem.
1. **Report New Issues**: Follow our guidelines if your issue is new or unresolved by previous solutions.
1. **Join Expo Developers Discord**: Engage with the community for support and discussions.
1. **Read Source Code**: For in-depth understanding, reviewing the source code can provide insights into potential bugs.
1. **Contribute Solutions**: If you find a fix, consider contributing to improve documentation or library functionality.

### Reporting Issues

This library is maintained by a small team. Hereâ€™s how you can help us address issues efficiently:

- Provide complete issue descriptions, including environment details (library version, RN version, device OS).
- Share an example app that reproduces the issue via gist, snack, or GitHub.
- Describe steps to reproduce the issue in your repro app.
- Minimize dependencies and isolate the problem in a minimal repro app.
- Note any findings about the root cause of the issue.

**Note**: Avoid commenting on closed issues. If a solution doesn't work for you, open a new issue with all necessary details and reference previous solutions.

### Feature Clarifications

- **Gesture Prop Changes**: The `enabled` prop only affects gestures at their start (when a finger touches the screen).
- **Native Gesture Behavior**: May differ from standard due to platform-specific integrations.
- **Touchables Styling**: Requires separate styling for `style` and `containerStyle` props.
- **Gesture Composition**: All composed gestures must be attached to the same `GestureHandlerRootView`.

#### Multiple Instances of Gesture Handler

This error occurs when multiple instances of Gesture Handler are detected, often due to dependencies installing it in their own `node_modules`. To resolve:

1. Identify libraries using Gesture Handler:

   - Use `npm ls react-native-gesture-handler` or `yarn why react-native-gesture-handler`.

1. Ensure a single version is used by adding resolutions (Yarn) or overrides (NPM):

   **For Yarn:**

   ```json
   "resolutions": {
     "react-native-gesture-handler": "<Gesture Handler version>"
   }
   ```

   **For NPM:**

   ```json
   "overrides": {
     "react-native-gesture-handler": "<Gesture Handler version>"
   }
   ```

1. Reinstall dependencies:
   - Run `yarn` or `npm install`.

#### Automatic Workletization of Gesture Callbacks

Reanimated's Babel plugin automatically marks gesture callbacks as worklets if defined in a single chain, eliminating the need for `'worklet';` directives:

```typescript
const gesture = Gesture.Tap().onBegin(() => {
  console.log(_WORKLET)
})
```

For callbacks not in a single chain, add `'worklet';` at the start:

```typescript
const callback = () => {
  "worklet"
  console.log(_WORKLET)
}
const gesture = Gesture.Tap().onBegin(callback)
```

This ensures proper workletization for asynchronous operations within gestures.

## Tap gesture

A tap gesture recognizes one or multiple taps. It detects brief touches on the screen by fingers, which must remain relatively stationary from their initial positions. You can configure tap gestures to recognize single, double, or triple taps based on specific requirements such as `minPointers`, `numberOfTaps`, `maxDist`, `maxDuration`, and `maxDelayMs`.

### Example

```typescript
import { View, StyleSheet } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

export default function App() {
  const singleTap = Gesture.Tap()
    .maxDuration(250)
    .onStart(() => {
      console.log('Single tap!');
    });

  const doubleTap = Gesture.Tap()
    .maxDuration(250)
    .numberOfTaps(2)
    .onStart(() => {
      console.log('Double tap!');
    });

  return (
    <GestureDetector gesture={Gesture.Exclusive(doubleTap, singleTap)}>
      <View style={styles.box} />
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
    borderRadius: 20,
    marginBottom: 30,
  },
});
```

### Configuration

#### Properties Specific to `TapGesture`:

- **minPointers(value: number)**\
  Minimum number of fingers required for gesture activation. Default is 1.

- **maxDuration(value: number)**\
  Maximum time in milliseconds for a finger release after touch. Default is 500 ms.

- **maxDelay(value: number)**\
  Maximum delay in milliseconds before the next tap if multiple taps are needed. Default is 500 ms.

- **numberOfTaps(value: number)**\
  Number of taps required to activate the gesture. Default is 1.

- **maxDeltaX(value: number)**\
  Maximum distance allowed along the X-axis during a tap. Exceeding this distance will cause the gesture to fail.

- **maxDeltaY(value: number)**\
  Maximum distance allowed along the Y-axis during a tap. Exceeding this distance will cause the gesture to fail.

- **maxDistance(value: number)**\
  Maximum distance allowed in any direction during a tap. Exceeding this distance will cause the gesture to fail.

- **mouseButton(value: MouseButton) (Web & Android only)**\
  Specifies which mouse button should trigger the handler. Options include `LEFT`, `RIGHT`, `MIDDLE`, `BUTTON_4`, `BUTTON_5`, and `ALL`. Default is `MouseButton.LEFT`.

#### Properties Common to All Gestures:

- **enabled(value: boolean)**\
  Determines if the gesture handler analyzes touch events. Default is `true`.

- **shouldCancelWhenOutside(value: boolean)**\
  Cancels or fails recognition when a finger leaves the view area. Defaults vary by gesture type.

- **hitSlop(settings)**\
  Controls the active area for gesture recognition, allowing adjustments to each boundary side or overall dimensions.

- **withRef(ref)**\
  Sets a reference to the gesture object for interoperability with older APIs.

- **withTestId(testID)**\
  Assigns a `testID` property for querying in tests.

- **cancelsTouchesInView(value) (iOS only)**\
  Cancels touches on native UI components when active. Default is `true`.

- **runOnJS(value: boolean)**\
  Determines if callbacks run on the JS thread instead of the UI thread. Defaults to `false`.

- **simultaneousWithExternalGesture(otherGesture1, otherGesture2, ...)**\
  Marks gestures for simultaneous recognition without composing them.

- **requireExternalGestureToFail(otherGesture1, otherGesture2, ...)**\
  Requires another gesture to fail before activation.

- **blocksExternalGesture(otherGesture1, otherGesture2, ...)**\
  Delays activation of other gestures until this one fails or doesn't start.

#### Callbacks Common to All Gestures:

- **onBegin(callback)**\
  Called when the handler starts receiving touches but hasn't yet recognized a gesture.

- **onStart(callback)**\
  Triggered when the gesture is recognized and transitions to an active state.

- **onEnd(callback)**\
  Invoked when a recognized gesture finishes, provided it was previously active.

- **onFinalize(callback)**\
  Called upon finalizing gesture handling, whether successful or failed.

- **onTouchesDown(callback)**\
  Triggered every time a finger touches the screen.

- **onTouchesMove(callback)**\
  Activated whenever a finger moves on the screen.

- **onTouchesUp(callback)**\
  Invoked when a finger is lifted from the screen.

- **onTouchesCancelled(callback)**\
  Called when a touch stops being tracked, such as when a gesture ends.

### Event Data Specific to `TapGesture`:

- **x**\
  X coordinate of the pointer relative to the attached view.

- **y**\
  Y coordinate of the pointer relative to the attached view.

- **absoluteX**\
  Absolute X coordinate of the pointer relative to the window. Use this for transformed views.

- **absoluteY**\
  Absolute Y coordinate of the pointer relative to the window. Use this for transformed views.

### Event Attributes Common to All Gestures:

- **state**\
  Current state of the handler, expressed as a constant from the `State` object.

- **numberOfPointers**\
  Number of fingers currently on the screen.

- **pointerType**\
  Type of pointer device in use, represented by the `PointerType` enum (`TOUCH`, `STYLUS`, `MOUSE`, `KEY`, `OTHER`).

## Reanimated Swipeable

### Overview

This component serves as a replacement for the `Swipeable` component, utilizing `Reanimated`. It facilitates swipe interactions on rows or similar elements by rendering children within a panable container that supports horizontal swiping. Depending on the swipe direction (left or right), one of two "action" containers can be displayed using the `renderLeftActions` or `renderRightActions` props.

### Usage

To use this component, import it as follows:

```typescript
import Swipeable from "react-native-gesture-handler/ReanimatedSwipeable"
```

### Properties

|Property|Description|
|-|-|
|`friction`|A number specifying the delay in visual interaction relative to gesture distance. E.g., `1` means no delay, `2` doubles it.|
|`leftThreshold`|Distance from the left edge for panel animation to open or close state. Defaults to half of the panel's width.|
|`rightThreshold`|Distance from the right edge for panel animation to open or close state. Defaults to half of the panel's width.|
|`dragOffsetFromLeftEdge`|Minimum drag distance from the left edge to consider a swipe (default: 10).|
|`dragOffsetFromRightEdge`|Minimum drag distance from the right edge to consider a swipe (default: 10).|
|`overshootLeft`|Boolean indicating if swiping beyond the left action panel's width is allowed. Defaults to `true` if `renderLeftActions` is provided.|
|`overshootRight`|Boolean indicating if swiping beyond the right action panel's width is allowed. Defaults to `true` if `renderRightActions` is provided.|
|`overshootFriction`|Number specifying delay in visual interaction at overshoot (default: 1). For a native feel, try `8` or above.|

### Callbacks

- **`onSwipeableOpen(direction)`**: Called when the swipeable opens.
- **`onSwipeableClose(direction)`**: Called when the swipeable closes.
- **`onSwipeableWillOpen(direction)`**: Called when opening animation starts.
- **`onSwipeableWillClose(direction)`**: Called when closing animation starts.
- **`onSwipeableOpenStartDrag(direction)`**: Called when a drag to open starts.
- **`onSwipeableCloseStartDrag(direction)`**: Called when a drag to close starts.

### Render Functions

#### `renderLeftActions`

Returns a component rendered under the swipeable after swiping right. Arguments:

- `progress`: Swiping progress relative to the width of the returned element.
- `translation`: Horizontal offset from closed position.
- `swipeableMethods`: Object with methods for interaction.

Must return a `ReactNode`. Use `flexDirection` for RTL layouts.

#### `renderRightActions`

Returns a component rendered under the swipeable after swiping left. Arguments are similar to `renderLeftActions`.

### Styles

- **`containerStyle`**: Style object for the container (`Animated.View`).
- **`childrenContainerStyle`**: Style object for the children container (`Animated.View`).

### Gesture Configuration

#### `simultaneousWithExternalGesture`

Allows recognition of another gesture simultaneously with the swipeable gesture. Useful for enabling other gestures like pan.

Example:

```typescript
const panGesture = Gesture.Pan();

<GestureDetector gesture={panGesture}>
  <ReanimatedSwipeable simultaneousWithExternalGesture={panGesture} />
</GestureDetector>
```

#### `enableTrackpadTwoFingerGesture` (iOS only)

Enables two-finger gestures on supported devices, like iPads with trackpads.

#### `mouseButton(value: MouseButton)` (Web & Android only)

Specifies which mouse button should trigger the handler. Options include `LEFT`, `RIGHT`, `MIDDLE`, `BUTTON_4`, `BUTTON_5`, and `ALL`. Default is `MouseButton.LEFT`.

#### `enableContextMenu(value: boolean)` (Web only)

Determines if a context menu should be enabled after right-clicking on the underlying view. Default is `false`.

### Methods

Using a reference to `Swipeable`, you can trigger actions:

- **`close`**: Closes the component.
- **`openLeft`**: Opens the component on the left side.
- **`openRight`**: Opens the component on the right side.
- **`reset`**: Resets swiping states without animation.

### Example

```typescript
import React from 'react';
import { Text, StyleSheet } from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import ReanimatedSwipeable from 'react-native-gesture-handler/ReanimatedSwipeable';
import Reanimated, {
  SharedValue,
  useAnimatedStyle,
} from 'react-native-reanimated';

function RightAction(prog: SharedValue<number>, drag: SharedValue<number>) {
  const styleAnimation = useAnimatedStyle(() => {
    console.log('showRightProgress:', prog.value);
    console.log('appliedTranslation:', drag.value);

    return {
      transform: [{ translateX: drag.value + 50 }],
    };
  });

  return (
    <Reanimated.View style={styleAnimation}>
      <Text style={styles.rightAction}>Text</Text>
    </Reanimated.View>
  );
}

export default function Example() {
  return (
    <GestureHandlerRootView>
      <ReanimatedSwipeable
        containerStyle={styles.swipeable}
        friction={2}
        enableTrackpadTwoFingerGesture
        rightThreshold={40}
        renderRightActions={RightAction}>
        <Text>Swipe me!</Text>
      </ReanimatedSwipeable>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  rightAction: { width: 50, height: 50, backgroundColor: 'purple' },
  swipeable: {
    height: 50,
    backgroundColor: 'papayawhip',
    alignItems: 'center',
  },
});
```

## Swipeable

**Caution:** This component facilitates the implementation of swipeable rows or similar interactions. It renders its children within a panable container, allowing for horizontal swiping left and right. Depending on whether the user swipes left or right, one of two "action" containers can be displayed, rendered by `renderLeftActions` or `renderRightActions` props.

### Usage

The `Swipeable` component is not exported by default from the `react-native-gesture-handler` package. To use it, import as follows:

```typescript
import Swipeable from "react-native-gesture-handler/Swipeable"
```

### Properties

|Property|Description|
|-|-|
|`friction`|A number specifying how much the visual interaction will be delayed compared to the gesture distance. For example, a value of `1` means the swipeable panel follows the gesture exactly; `2` makes it two times "slower".|
|`leftThreshold`|Distance from the left edge at which the released panel animates to the open state (or vice versa). Default is half of the panel's width.|
|`rightThreshold`|Distance from the right edge for similar behavior as `leftThreshold`. Default is also half of the panel's width.|
|`dragOffsetFromLeftEdge`|Minimum distance that must be dragged from the left edge to consider it a swipe. Default value: `10`.|
|`dragOffsetFromRightEdge`|Similar to `dragOffsetFromLeftEdge`, but for the right edge. Default value: `10`.|
|`overshootLeft`|Boolean indicating if the panel can be pulled further than the left actions panel's width. Defaults to `true` if a left panel render method is present.|
|`overshootRight`|Similar to `overshootLeft`, but for the right side. Defaults to `true` if a right panel render method is present.|
|`overshootFriction`|Number specifying visual interaction delay at overshoot. Default value: `1`. For a native feel, try `8` or above.|

**Deprecated Callbacks:**

- `onSwipeableLeftOpen`: Deprecated; use `onSwipeableOpen(direction)`.
- `onSwipeableRightOpen`: Deprecated; use `onSwipeableOpen(direction)`.

|Property|Description|
|-|-|
|`onSwipeableOpen`|Called when an action panel gets open (either right or left). Takes swipe direction as an argument.|
|`onSwipeableClose`|Called when the action panel is closed, with swipe direction as an argument.|
|`onSwipeableWillOpen`|Called when an action panel starts animating on open (either right or left), taking swipe direction as an argument.|
|`onSwipeableWillClose`|Called when an action panel starts animating on close, with swipe direction as an argument.|

**Rendering Methods:**

- `renderLeftActions`: Returns the left-side action panel revealed upon a right swipe.

  - **Interpolation Values:**
    - `progressAnimatedValue`: `[0, 1]`
    - `dragAnimatedValue`: `[0, +]`
  - Use `flexDirection` for RTL flexbox layouts.

- `renderRightActions`: Returns the right-side action panel revealed upon a left swipe.
  - **Interpolation Values:**
    - `progressAnimatedValue`: `[0, 1]`
    - `dragAnimatedValue`: `[0, -]`
  - Use `flexDirection` for RTL flexbox layouts.

**Additional Styles:**

- `containerStyle`: Style object for the container (Animated.View), e.g., to override `overflow: 'hidden'`.
- `childrenContainerStyle`: Style object for the children container (Animated.View), e.g., to apply `flex: 1`.

**Platform-Specific Properties:**

- `enableTrackpadTwoFingerGesture` (iOS only): Enables two-finger gestures on supported devices.
- `mouseButton(value: MouseButton)` (Web & Android only): Chooses which mouse button should trigger the handler. Options include:
  - `LEFT`
  - `RIGHT`
  - `MIDDLE`
  - `BUTTON_4`
  - `BUTTON_5`
  - `ALL` (default is `MouseButton.LEFT`)
- `enableContextMenu(value: boolean)` (Web only): Specifies if a context menu should be enabled after right-clicking. Default is `false`.

### Methods

Using a reference to `Swipeable`, you can trigger actions:

|Method|Description|
|-|-|
|`close`|Closes the component with animation.|
|`openLeft`|Opens the component on the left side.|
|`openRight`|Opens the component on the right side.|
|`reset`|Resets swiping states without triggering any animation.|

### Example

```typescript
import React, { Component } from 'react';
import { Animated, StyleSheet, View, Text } from 'react-native';
import { RectButton } from 'react-native-gesture-handler';
import Swipeable from 'react-native-gesture-handler/Swipeable';

class AppleStyleSwipeableRow extends Component {
  renderLeftActions = (progress, dragX) => {
    const trans = dragX.interpolate({
      inputRange: [0, 50, 100, 101],
      outputRange: [-20, 0, 0, 1],
    });
    return (
      <RectButton style={styles.leftAction} onPress={() => this.close()}>
        <Animated.Text
          style={[
            styles.actionText,
            {
              transform: [{ translateX: trans }],
            },
          ]}>
          Archive
        </Animated.Text>
      </RectButton>
    );
  };

  render() {
    return (
      <Swipeable renderLeftActions={this.renderLeftActions}>
        <Text>"hello"</Text>
      </Swipeable>
    );
  }
}

const styles = StyleSheet.create({
  leftAction: {
    // Define your styles here
  },
  actionText: {
    // Define your styles here
  },
});
```

## Touchables

**Warning:**\
Touchables will be deprecated in future versions of Gesture Handler. It is recommended to use `Pressable` instead.

The Gesture Handler library offers an implementation of React Native's (RN) touchable components that are based on native buttons, avoiding reliance on the JavaScript responder system used by RN. This touchable implementation follows the same API and aims to be a direct replacement for the touchables available in React Native.

React Native's touchables API includes:

- Touchable Native Feedback
- Touchable Highlight
- Touchable Opacity
- Touchable Without Feedback

All major properties of these touchables (except `pressRetentionOffset`) have been adopted, ensuring similar behavior to RN's touchables.

The motivation for using RNGH touchables as a replacement is to more closely follow native behavior by utilizing the platform's native touch system instead of relying on the JS responder system. These touchables and their feedback behaviors are deeply integrated with the native gesture ecosystem, allowing easy connection with other native components (e.g., `ScrollView`) and Gesture Handlers in a predictable manner that aligns with native apps' behavior.

The intention was to make switching to these touchables as straightforward as possible. To use RNGH's touchables, you only need to change the library from which you import the touchable components.

**Info:**\
Gesture Handler's `TouchableOpacity` uses a native driver for animations by default. If this causes issues, you can set the `useNativeAnimations` prop to false.

#### Example:

Replace imports like so:

```typescript
import {
  TouchableNativeFeedback,
  TouchableHighlight,
  TouchableOpacity,
  TouchableWithoutFeedback,
} from "react-native"
```

with:

```typescript
import {
  TouchableNativeFeedback,
  TouchableHighlight,
  TouchableOpacity,
  TouchableWithoutFeedback,
} from "react-native-gesture-handler"
```

For a comparison of both touchable implementations, refer to our touchables example.

## Handler State

Gesture handlers are conceptualized as "state machines" according to the description provided in "About Gesture Handlers". This means they operate through a series of states, transitioning between them based on specific inputs or events.

## How does it work?

### Units

All properties and event attributes in handler components representing onscreen dimensions are expressed in screen density-independent units called "points." These units align with those used in the React Native ecosystem, such as iOS's points and Android's dp (density-independent pixels). Points do not directly correspond to physical pixels.

### iOS Implementation

Gestures on iOS utilize UIGestureRecognizers. Some recognizers have been customized for enhanced customization and to adhere to the state flow of RNGH (React Native Gesture Handler). When a gesture configuration is assigned to `GestureDetector`, it creates all necessary recognizers and assigns them to the child view of the detector. Subsequently, most processing is managed by UIKit, with assistance from our implementation to ensure correct interactions between gestures.

### Android Implementation

Android lacks an easy method for handling gestures, necessitating custom implementations, including a system for managing gesture interactions. Here's how it functions:

1. **GestureHandlerRootView**: Wrapping a component in `GestureHandlerRootView` allows RNGH to intercept all touch events on that component and determine whether they should be handled by gesture handlers or passed to the underlying view.

1. **Touch Event Handling**:

   - Gesture handlers are initialized when a gesture configuration is assigned to `GestureDetector`.
   - Each `GestureHandlerRootView` has a handler to decide if touch events should be consumed or passed through.
   - This handler cannot activate but can begin, end, or be cancelled.

1. **State Transitions**:

   - In the `UNDETERMINED` state, no touch is in progress. Upon touch start, it transitions to the `BEGAN` state.
   - While in the `BEGAN` state, touch events are not consumed. If a handler activates (or gets cancelled), all incoming touch events are consumed, preventing them from reaching the underlying view.

1. **Gesture Recognition**:

   - When a pointer touches the screen, the view tree is traversed to extract handlers attached to views beneath the finger, including those on `GestureHandlerRootView`.
   - Extracted handlers transition to the `BEGAN` state, indicating a potential gesture start.
   - Touch events are delivered to all extracted handlers until one recognizes and attempts to activate the gesture.

1. **Orchestrator Role**:
   - The orchestrator checks if the activating gesture should wait for other gestures to fail.
   - If it waits, it is placed on a waiting list; otherwise, it activates, cancelling non-simultaneous gestures.
   - When a gesture handler finishes (gesture recognized, fails, or cancels), the orchestrator reviews waiting handlers. Those that waited for the failed gesture attempt activation again, with the process repeating as necessary.

This system ensures efficient and accurate gesture handling across both iOS and Android platforms.
