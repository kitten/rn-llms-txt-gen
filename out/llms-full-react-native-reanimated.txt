# React NativeReanimated

### Create smooth animations with an excellent developer experience.

### Why Reanimated?

#### Declarative

Reanimated comes with declarative API for creating animations. Complexity reduced from tens of methods to just a few. Define what the animation should look like and leave Reanimated to animate the styles and properties for you.

#### Performant

Reanimated lets you define animations in plain JavaScript which run natively on the UI thread by default. Smooth animations and interactions up to 120 fps and beyond. Reanimated delivers a native experience your users deserve.

#### Feature-rich

Reanimated’s power doesn’t end on animating only simple views or images. Hook your animations into device sensors or keyboard. Create amazing experiences using Layout Animations or animate elements between navigation screens with ease.

##### Learn more about the features in the newest article about Reanimated 3

##### Animations

Animate every React Native prop on iOS, Android and the Web up to 120 fps.

```
function App() {
  const width = useSharedValue(100);
  const handlePress = () => {
    width.value = withSpring(width.value + 50);
  };
  return <Animated.View style={{ ...styles.box, width }} />
}
```

##### Gestures

Gesture smoothly thanks to Reanimated’s integration with React Native Gesture Handler.

```
import { Gesture, GestureDetector } from ?"react-native-gesture-handler";

function App() {
  const pan = Gesture.Pan();

  return (
    <GestureDetector gesture={pan}>
      <Animated.View />
    </GestureDetector>
  );
}
```

##### Layout animations

Animate views when they are added and removed from the view hierarchy. Just like that.

```
function App() {
  return <Animated.View entering={FadeIn} exiting={FadeOut} />;
}
```

##### Sensor-based animations

Connect your animations to a gyroscope or accelerometer with just one hook. It’s that easy.

```
const gyroscope = useAnimatedSensor(SensorType.GYROSCOPE);

useDerivedValue(() => {
  const { x, y, z } = gyroscope.sensor.value;
});
```

##### Keyboard-based animations

Create animations based on the device keyboard state and position.

```
function App() {
  const keyboard = useAnimatedKeyboard();
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: -keyboard.height.value }],
  });
  //...
}
```

##### Shared Element Transitions

Seamlessly animate elements between navigation screens with a single line of code.

```
function App() {
  return <Animated.View sharedTransitionTag="hero-element" />
}
```

#### Sponsors

### We are Software Mansion

React Native Core Contributors and experts in dealing with all kinds of React Native issues. No matter if you need help with gestures, animations or React Native development we can help.

## useAnimatedStyle

`useAnimatedStyle` lets you create a styles object, similar to `StyleSheet` styles, which can be animated using shared values.

Styles defined using `useAnimatedStyle` have to be passed to `style` property of an Animated component. Styles are automatically updated whenever an associated shared value or React state changes.

In contrast to the inline styling, `useAnimatedStyle` allows to access values stored in shared values in the styles object it defines.

For animating properties use `useAnimatedProps` instead.

### Reference

```
import { useAnimatedStyle } from 'react-native-reanimated';

function App() {
  const animatedStyles = useAnimatedStyle(() => {
    return {
      opacity: sv.value ? 1 : 0,
    };
  });

  return <Animated.View style={[styles.box, animatedStyles]} />;
}
```

Type definitions

```
type DefaultStyle = ViewStyle | ImageStyle | TextStyle;
type DependencyList = Array<unknown> | undefined;

export function useAnimatedStyle<Style extends DefaultStyle>(
  updater: () => Style,
  dependencies?: DependencyList | null
): Style;
```

#### Arguments

##### `updater`

A function returning an object with style properties you want to animate. You can animate any style property available in React Native.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

### Returns

`useAnimatedStyle` returns an animated style object which has to be passed to the `style` property of an Animated component that you want to animate.

`useAnimatedStyle` mimics the behavior of `StyleSheet` as much as possible. `updater` callback returns a value that looks like a regular style object in which you can also use shared values.

### Example

### Remarks

- Animated styles take precedence over React Native's static styles. All values specified in animated styles override values from static styles.

```
function App() {
  const animatedStyles = useAnimatedStyle(() => ({
    width: sv.value,
  }));

  return (
    <Animated.View
      style={[
        animatedStyles, // ⚠️ overrides the static style width
        { width: 100 },
      ]}
    />
  );
}
```

- Animated styles don't follow the order in which they are specified in the style array. The last updated animated style is the one that takes effect.

- Removing the animated style from the view doesn't unset values that were applied in the animated style. To unset these values, you need to manually set them to `undefined` in the animated style.

- Mutating shared values in `useAnimatedStyle`'s callback is an undefined behavior which may lead to infinite loops.

```
function App() {
  const sv = useSharedValue(0);
  const animatedStyles = useAnimatedStyle(() => {
    sv.value = withTiming(1); // Don't do this!
    return { opacity: sv.value };
  });
}
```

- You can apply the value returned from `useAnimatedStyle` only to `Animated` components. Passing the animated styles to non-animated component will result in an error.

- Only define the dynamic part of your styles with `useAnimatedStyle` and keep the static ones separately using `StyleSheet` API or (if you really have to) with inline styles. That way you avoid lots of unnecessary style recalculations. Static and dynamic styles can be easily merged using the `[]` syntax:

```
function App() {
  const animatedStyles = useAnimatedStyle(() => ({
    offset: sv.value,
  }));

  return <Animated.View style={[styles.box, animatedStyles]} />;
}

const styles = StyleSheet.create({
  box: {
    height: 120,
    width: 120,
    backgroundColor: '#b58df1',
  },
});
```

- You can share animated styles between components to avoid code duplication.

- The callback passed to the `useAnimatedStyle` is first run on the JavaScript thread and immediately after on the UI thread. This may cause an error if you write your code as if it's running on UI thread only. To avoid this, you can use the `global._WORKLET` variable to check if the code is running on the UI thread:

```
function App() {
  const animatedStyles = useAnimatedStyle(() => {
    if (global._WORKLET) {
      // UI thread only code
    } else {
      // JS thread fallback code
    }
  });
}
```

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useAnimatedScrollHandler

`useAnimatedScrollHandler` is a hook that returns an event handler reference. It can be used with React Native's scrollable components.

### Reference

```
import { useAnimatedScrollHandler } from 'react-native-reanimated';

function App() {
  const offsetY = useSharedValue(0);

  const scrollHandler = useAnimatedScrollHandler((event) => {
    offsetY.value = event.contentOffset.y;
  });

  // ...

  return <Animated.ScrollView onScroll={scrollHandler} />;
}
```

Type definitions

```
function useAnimatedScrollHandler<Context extends Record<string, unknown>>(
  handlers: ScrollHandler<Context> | ScrollHandlers<Context>,
  dependencies?: DependencyList
): ScrollHandlerProcessed<Context>;

type ScrollHandler<
  Context extends Record<string, unknown> = Record<string, unknown>
> = (event: ReanimatedScrollEvent, context: Context) => void;

interface ScrollHandlers<Context extends Record<string, unknown>> {
  onScroll?: ScrollHandler<Context>;
  onBeginDrag?: ScrollHandler<Context>;
  onEndDrag?: ScrollHandler<Context>;
  onMomentumBegin?: ScrollHandler<Context>;
  onMomentumEnd?: ScrollHandler<Context>;
}

type DependencyList = Array<unknown> | undefined;
```

#### Arguments

##### `handlers`

Object containing custom keys matching native event names. Following keys are available:

- `onScroll`
- `onBeginDrag`
- `onEndDrag`
- `onMomentumBegin`
- `onMomentumEnd`

The values in the object should be individual worklets. Each of the worklet will be triggered when the corresponding event is dispatched on the connected Scrollable component.

Each of the event worklets will receive the following parameters when called:

- `event` - event object carrying the information about the scroll. The payload can differ depending on the type of the event. Please consult React Native's ScrollView documentation to learn about scroll event structure.

- `context` - plain JS object that can be used to store some state. This object will persist in between scroll event occurrences and you can read and write any data to it. When there are several event handlers provided in a form of an object of worklets, the `context` object will be shared in between the worklets allowing them to communicate with each other.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

The hook returns a handler object that can be hooked into a scrollable container. The returned handler should be passed under `onScroll` parameter regardless of whether it is configured to receive only scroll or also momentum or drag events. In order for the returned handler to be properly triggered, you should use containers that are wrapped with `Animated` (e.g. `Animated.ScrollView` and not just `ScrollView`).

### Example

### Remarks

- The returned handler may be passed to multiple components. In such situation, the handler will invoke for the given events each time any of the components dispatches them.
- If a single worklet function of type `(event) => void` is passed instead of a map of functions matched to event keys, it's treated as a handler for the `onScroll` event.
- Only `onScroll` event works on Web.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useEvent

`useEvent` is a low-level hook. It returns event handler that will be called when native event occurs. You can use it to create custom event handler hooks, like `useScrollViewOffset` or `useAnimatedScrollHandler`.

### Reference

```
import { useEvent } from 'react-native-reanimated';

function useAnimatedPagerScrollHandler(handlers, dependencies) {
  const { context, doDependenciesDiffer } = useHandler(handlers, dependencies);

  return useEvent(
    (event) => {
      'worklet';
      const { onPageScroll } = handlers;

      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {
        onPageScroll(event, context);
      }
    },
    ['onPageScroll'],
    doDependenciesDiffer
  );
}

return <Animated.View onScroll={useAnimatedPagerScrollHandler} />;
```

Type definitions

```
function useEvent<
  Event extends object,
  Context extends Record<string, unknown> = never
>(
  handler: EventHandler<Event, Context>,
  eventNames?: string[],
  rebuild?: boolean
): EventHandlerProcessed<Event, Context>;

type EventHandler<
  Event extends object,
  Context extends Record<string, unknown> = never
> = (event: ReanimatedEvent<Event>, context?: Context) => void;

type EventHandlerProcessed<
  Event extends object,
  Context extends Record<string, unknown> = never
> = (event: Event, context?: Context) => void;
```

#### Arguments

##### `handler`

Function that receives event object with native payload, that can be passed to custom handler hook's worklets.

- `event` - event object. The payload can differ depending on the type of the event.

##### `eventNames`Optional

Array of event names that will be handled by handler.

##### `rebuild`Optional

Value indicating whether handler should be rebuilt.

#### Returns

The hook returns event handler that will be invoked when native event is dispatched. That handler may be connected to multiple components and will be invoked for each one's specific events.

### Example

This example can be more easily implemented using `useScrollViewOffset`.

### Remarks

- Keep in mind that not all scroll events are supported on the web, only `onScroll` is available across browsers.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useHandler

`useHandler` is a low-level hook. It returns a context object and a value that tells you if the worklet needs to be rebuilt. You can use it to create custom event handler hooks, like `useScrollViewOffset` or `useAnimatedScrollHandler`.

### Reference

```
import { useEvent, useHandler } from 'react-native-reanimated';

function useAnimatedPagerScrollHandler(handlers, dependencies) {
  const { context, doDependenciesDiffer, useWeb } = useHandler(
    handlers,
    dependencies
  );

  return useEvent(
    (event) => {
      'worklet';
      const { onPageScroll } = handlers;

      if (onPageScroll && event.eventName.endsWith('onPageScroll')) {
        onPageScroll(event, context);
      }
    },
    ['onPageScroll'],
    doDependenciesDiffer
  );
}
```

Type definitions

```
function useHandler<
  Event extends object,
  Context extends Record<string, unknown>
>(
  handlers: GeneralHandlers<Event, Context>,
  dependencies?: DependencyList
): UseHandlerContext<Context>;

interface UseHandlerContext<Context extends Record<string, unknown>> {
  context: Context;
  doDependenciesDiffer: boolean;
  useWeb: boolean;
}

interface GeneralHandler<
  Event extends object,
  Context extends Record<string, unknown>
> {
  (event: ReanimatedEvent<Event>, context: Context): void;
}
```

#### Arguments

##### `handlers`

Object containing custom keys matching native event names. The values in the object should be individual worklets. Each of the worklets will be triggered when the corresponding event is dispatched on the connected animated component.

Each of the event worklets will receive the following parameters when called:

- `event` - event object. The payload can differ depending on the type of the event.

- `context` - plain JS object that can be used to store some state. This object will persist in between event occurrences and you can read and write any data to it. When there are several event handlers provided in a form of an object of worklets, the `context` object will be shared in between the worklets allowing them to communicate with each other.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

The hook returns a context that will be reused by event handlers and value that indicates whether worklets should be rebuilt. If different implementation is needed for web, `useWeb` boolean is returned to check for web environment

### Example

This example can be more easily implemented using `useScrollViewOffset`.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Keyframe animations

Keyframes are animation definition schemas that let you create complex animations. They allow you more flexibility than standard Entering and Exiting presets.

### Reference

```
import { Keyframe } from 'react-native-reanimated';

const keyframe = new Keyframe({
  0: {
    transform: [{ rotate: '0deg' }],
  },
  45: {
    transform: [{ rotate: '100deg' }],
    easing: Easing.exp,
  },
  100: {
    transform: [{ rotate: '45deg' }],
  },
});

function App() {
  return <Animated.View entering={keyframe} />;
}
```

Type definitions

```
type FirstFrame =
  | {
      0: KeyframeProps & { easing?: never };
      from?: never;
    }
  | {
      0?: never;
      from: KeyframeProps & { easing?: never };
    };

type LastFrame =
  | { 100?: KeyframeProps; to?: never }
  | { 100?: never; to: KeyframeProps };

export type ValidKeyframeProps = FirstFrame &
  LastFrame &
  Record<number, KeyframeProps>;

class Keyframe {
  constructor(definitions: ValidKeyframeProps;
  duration(durationMs: number): Keyframe;
  delay(delayMs: number): Keyframe;
  reduceMotion(reduceMotionV: ReduceMotion): Keyframe;
  withCallback(callback: (finished: boolean) => void): Keyframe;
}
```

#### Arguments

##### `definitions`

An object, that contains definitions of your animation. The object keys should be within range `0-100` and correspond to animation progress. The object values should consist of style props and optionally of an easing function. If easing property is not provided, it defaults to `Easing.linear`.

The keys take the following values:

- `0` or `from`: Initial state of the object.
- Middle points (e.g., `45`): Intermediate states of the object.
- `100` or `to`: Final state of the object.

The key `0` (or `from`) should be assigned the style that you want for your object at the beginning of the animation. The key `100` (or `to`) should be assigned the style that you want for your object at the end of the animation.

### Modifiers

```
keyframe
  .duration(1000)
  .delay(500)
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `500`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Remarks

- Providing keyframe `0` or `from` is required as it contains the initial state of the object you want to animate.
- Ensure you provide the initial value for all style properties you want to animate in other keyframes.
- If you want to add easing to an animation between two keyframes you have to pass it to the second one. As a result you should never provide any easing to keyframe `0`.
- Do not provide both `0` and `from`, or `100` and `to` keyframes, as it will result in a parsing conflict.
- If you want to animate transform style, make sure that all properties in the transformation array are in the same order in all keyframes.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Troubleshooting

### Initialization issues

Reanimated has four core components that compose its code:

- C++,
- Java,
- JavaScript,
- Reanimated Babel plugin.

All of them are supposed to work correctly only within the same minor version. Therefore, having any of those pieces in your code - directly or indirectly - separate from `react-native-reanimated`, especially having any code transpiled with a different version of the aforementioned plugin will result in undefined behavior and errors.

#### Failed to create a worklet

**Problem:** This usually happens when Reanimated is not properly installed, e.g. forgetting to include the Reanimated Babel plugin in `babel.config.js`.

**Solution:** See installation docs at <https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/getting-started/#step-2-add-reanimateds-babel-plugin> for more information.

#### Native part of Reanimated doesn't seem to be initialized

**Problem:** This issue happens when Reanimated fails to initialize its native side from JavaScript.

**Solution:**

1. If you recently installed or upgraded Reanimated, make sure to rebuild your app.

2. Check if your platform is supported by Reanimated. Currently we support:

   - Android
   - iOS
   - macOS
   - tvOS
   - visionOS
   - Web

3. If you are using Reanimated in a brownfield app, make sure to initialize the native library manually.

#### Unknown version of Reanimated Babel plugin

**Problem:** This happens when JavaScript side of Reanimated fails to get Reanimated Babel plugin version.

**Solution:**

1. Part of your code might be transpiled with an outdated version of Reanimated Babel plugin. See Mismatch between JavaScript code version and Reanimated Babel plugin version.
2. You use release bundle with debug build of the app. This is not supported. See Using dev bundle in release app build is not supported for more information.

#### Mismatch between JavaScript code version and Reanimated Babel plugin version

**Problem:** This can happen when you use code that was transpiled with an outdated version of Reanimated Babel plugin.

**Solution:** Try resetting your Metro bundler cache with `yarn start --reset-cache`, `npm start -- --reset-cache` or `expo start -c` and run the app again.

If this didn't help, you probably have a dependency that contains already transformed worklets bundled with an outdated version of the Reanimated Babel plugin. You can find the offending code that was given alongside the error to find that dependency.

#### Using dev bundle in a release app build is not supported

**Problem:** This happens when you use a release build of your app with a development JavaScript bundle.

**Solution:** See this post for more information.

#### Couldn't determine the version of the native part of Reanimated

**Problem:** This happens when Reanimated fails to determine the version of its native part.

**Solution:** Check if you have rebuilt your app after upgrading `react-native-reanimated`. If you use Expo Go, you must use the exact version which is bundled into Expo SDK.

#### Mismatch between JavaScript part and native part of Reanimated

**Problem:** This happens when Reanimated has different versions of its JavaScript and native parts.

**Solution:** Check if you have rebuilt your app after upgrading `react-native-reanimated`. If you use Expo Go, you must use the exact version which is bundled into Expo SDK.

#### C++ side failed to resolve JavaScript code version

See Couldn't determine the version of the native part of Reanimated and Unknown version of Reanimated Babel plugin.

#### Mismatch between C++ code version and JavaScript code version

See (Mismatch between JavaScript part and native part of Reanimated)\[#mismatch-between-javascript-part-and-native-part-of-reanimated] and (Mismatch between JavaScript code version and Reanimated Babel plugin version)\[#mismatch-between-javascript-code-version-and-reanimated-babel-plugin-version].

#### C++ side failed to resolve Java code version

**Problem:** This happens when Reanimated fails to determine the version of its Java part - most likely because Java part hasn't rebuilt after an upgrade.

**Solution:** Make sure to rebuild your app and see if the problem persists. If it does, feel free to create an issue on our GitHub.

#### Mismatch between C++ code version and Java code version

**Problem:** This happens when Reanimated has different versions of its C++ and Java parts.

**Solution:** See Native side failed to resolve Java code version.

#### Java side failed to resolve C++ code version

**Problem:** This happens when Reanimated fails to determine the version of its C++ part - most likely because for some reason C++ part hasn't rebuilt after an upgrade.

**Solution:** See Native side failed to resolve Java code version.

#### Mismatch between Java code version and C++ code version

**Problem:** This happens when Reanimated has different versions of its Java and C++ parts.

**Solution:** See Native side failed to resolve Java code version.

#### Multiple versions of Reanimated were detected

**Problem:** This error usually happens when in your project exists more than one instance of Reanimated. It can occur when some of your dependency has installed Reanimated inside their own `node_modules` instead of using it as a peer dependency. In this case two different versions of Reanimated JavaScript module might try to initialize its native part. You can check which libraries are using Reanimated e.g. with `yarn why react-native-reanimated` or `npm ls react-native-reanimated`.

**Solution:** Modify your `package.json` file accordingly:

- if you use `yarn`, you should add `resolution` property:

```
"resolutions": {
  "react-native-reanimated": <Reanimated version>
}
```

- if you use `npm`, you should add `overrides` property:

```
"overrides": {
  "react-native-reanimated": <Reanimated version>
}
```

After that make sure to run your package manager again, either `yarn` or `npm install`.

#### Another instance of Reanimated was detected

See Multiple versions of Reanimated were detected.

#### Outdated version of React Native for New Architecture

**Problem:** Reanimated supports New Architecture (Fabric) only on the latest minor release of React Native.

**Solution:** Please upgrade to a newer version of React Native or downgrade to an older version of Reanimated. See the compatibility table for a full list of supported versions of React Native.

### Warnings

#### Reduced motion setting is enabled on this device.

**Problem:** This warning is displayed to avoid confusion that could arise when Reduced motion is enabled.

**Solution:** Do nothing, this warning is safe to ignore as it is only displayed in development mode to avoid confusion. If you wish to disable it, you can add the following line to your project's root file:

```
LogBox.ignoreLogs([
  '[Reanimated] Reduced motion setting is enabled on this device.',
]);
```

See the accessibility overview to learn more about Reduced Motion.

#### Tried to modify key of an object which has been converted to a shareable.

**Problem:** This warning is displayed to inform the user that a shared value should be used or an object used in a worklet should be accessed more granularly.

##### 1. Not using shared values.

You might get this warning when you do something along the lines of:

```
const obj = { prop: 1 };

function worklet() {
  'worklet';
  console.log(obj.prop);
}

runOnUI(worklet)();
obj.prop = 2; // Warning: Tried to modify key `prop` of an object which has been already passed to a worklet.
runOnUI(worklet)();
```

and expect the results to be `1` and `2`. However, the results will be `1` and `1` because `obj` is not a shared value and is only copied to UI runtime once. Therefore, in development builds, we make the object immutable and add this warning after copying it to signal that it's not a valid use of Reanimated. To fix this, you should use a shared value instead:

**Solution:**

```
-const obj = { prop: 1 };
+const sv = useSharedValue({ prop: 1 });

 function worklet() {
   'worklet';
-  console.log(obj.prop);
+  console.log(sv.value.prop);
 }

 runOnUI(worklet)();
-obj.prop = 2; // Warning: Tried to modify key `prop` of an object which has been already passed to a worklet.
+sv.value = { prop: 2 }; // Everything is fine here.
+// Keep in mind that you cannot modify the property directly with `sv.value.prop = 2` unless you use the `modify` method.
 runOnUI(worklet)();
```

##### 2. Not accessing object properties granularly.

When you access an object property in a worklet, you might do something like this:

```
const obj = { propAccessedInWorklet: 1, propNotAccessedInWorklet: 2 };

function worklet() {
  'worklet';
  console.log(obj.propAccessedInWorklet);
}

runOnUI(worklet)();
obj.propNotAccessedInWorklet = 3; // Warning: Tried to modify key `prop` of an object which has been already passed to a worklet.
```

The warning is displayed due to the mechanism explained in the previous case. Since we copy the whole object `obj` instead its accessed properties, it's immutable.

**Solution:**

Assign accessed properties to variables beforehand and use those in the worklet:

```
 const obj = { propAccessedInWorklet: 1, propNotAccessedInWorklet: 2 };

+const propAccessedInWorklet = obj.propAccessedInWorklet;
+
 function worklet() {
   'worklet';
-  console.log(obj.propAccessedInWorklet);
+  console.log(propAccessedInWorklet);
 }

 runOnUI(worklet)();
-obj.propNotAccessedInWorklet = 3; // Warning: Tried to modify key `prop` of an object which has been already passed to a worklet.
+obj.propNotAccessedInWorklet = 3; // Everything is fine here.
```

### Threading issues

#### Tried to synchronously call a non-worklet function on the UI thread

**Problem:** This can happen when you try to call a function that is not marked as a worklet from a worklet. E.g.:

```
function callee() {
  console.log('hello');
}
function caller() {
  'worklet';
  callee(); // <- this will throw in `runOnUI`
}
runOnUI(caller)();
```

In this example, `callee` cannot be called from a worklet ran on UI thread because there is no corresponding UI function for `callee`.

**Solution:**

1. If you want to synchronously execute this method, mark it as a worklet using `worklet` directive:

```
 function callee() {
+  'worklet';
   console.log("hello");
 }
```

2. If you want to execute this function on the JS thread, wrap it using `runOnJS`:

```
 function caller() {
   'worklet';
-  callee();
+  runOnJS(callee)();
 }
```

Check this page to learn more about Reanimated and its worklets.

## Shared Element Transitions

caution

Shared Element Transitions is an experimental feature, not recommended for production use yet. We are waiting for your feedback to improve implementation.

Shared Element Transition allows you to smoothly transform a component from one screen into a component on another screen.

### Reference

```
import Animated from 'react-native-reanimated';

const Stack = createNativeStackNavigator();

function One({ navigation }) {
  return (
    <>
      <Animated.View
        sharedTransitionTag="sharedTag"
      />
      <Button title="Two" onPress={() => navigation.navigate('Two')} />
    </>
  );
}

function Two({ navigation }) {
  return (
    <>
      <Animated.View
        sharedTransitionTag="sharedTag"
      />
      <Button title="One" onPress={() => navigation.navigate('One')} />
    </>
  );
}

export default function SharedElementExample() {
  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: true }}>
        <Stack.Screen name="One" component={One} />
        <Stack.Screen name="Two" component={Two} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

### Overview

When Reanimated detects that a component with a `sharedTransitionTag` is being mounted or unmounted, it tries to find the last registered view with the same `sharedTransitionTag`.

If it finds two matching components, it takes a snapshot of the styles for both components, and both shared views are detached from their parent and attached to a temporary transition container for the duration of the animation.

After the animation is complete, they are attached back to their original parent.

If you don't create a custom animation, all snapshot properties, including `width`, `height`, `originX`, `originY`, and `transformMatrix`, are animated by default with a duration of 500ms using the `withTiming` animation.

### Implementation

To create a shared transition animation between two components on different screens, simply assign the same `sharedTransitionTag` to both components. When you navigate between screens, the shared transition animation will automatically play.

If you want to use more than one shared view on the same screen, be sure to assign a **unique** shared tag to each component.

**Screen A**

```
<View
  sharedTransitionTag="sharedTag"
  style={{ width: 150, height: 150, backgroundColor: 'green' }}
/>
```

**Screen B**

```
<View
  sharedTransitionTag="sharedTag"
  style={{ width: 100, height: 100, backgroundColor: 'green' }}
/>
```

### Custom animation

You can create a custom animation by using `SharedTransition.custom` for regular animations or `SharedTransition.progressAnimation` for progress-based animations.

```
import { SharedTransition } from 'react-native-reanimated';

const transition = SharedTransition.custom((values) => {
  'worklet';
  return {
    height: withSpring(values.targetHeight),
    width: withSpring(values.targetWidth),
  };
})
  .progressAnimation((values, progress) => {
    'worklet';
    const getValue = (
      progress: number,
      target: number,
      current: number
    ): number => {
      return progress * (target - current) + current;
    };
    return {
      width: getValue(progress, values.targetWidth, values.currentWidth),
      height: getValue(progress, values.targetHeight, values.currentHeight),
    };
  })
  .defaultTransitionType(SharedTransitionType.ANIMATION);
```

By combining these methods and setting `defaultTransitionType(SharedTransitionType.ANIMATION)`, you specify that the custom animation will be used for screen transitions, while the progress-based animation will be applied during swipe back gesture (**iOS only**).

Setting `defaultTransitionType(SharedTransitionType.PROGRESS_ANIMATION)` will apply progress-based animation in both scenarios.

Then, to use it, simply pass your custom animation as `sharedTransitionStyle` prop to both your screen's components.

If you want even more customization, you can pass two different custom animations to two different component, as long as the components share the same `sharedTransitionTag`. In that case animation passed to component A will run when switching from A -> B, and animations passed to component B will run when switching from B -> A.

```
<View
  sharedTransitionTag="reanimatedTransition"
  sharedTransitionStyle={transition}
  style={{ backgroundColor: 'blue', width: 200, height: 100 }}
/>
```

### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

Expand the full code

```
      <Pressable onPress={() => goToDetails('countryside')}>
        <Animated.View
          sharedTransitionTag={'countryside'}
          style={[
            styles.imageOne,
            { backgroundColor: gallery.countryside.color },
          ]}
        />
      </Pressable>
      <View style={styles.row}>
        <Pressable onPress={() => goToDetails('florence')}>
          <Animated.View
            sharedTransitionTag={'florence'}
            style={[
              { width: width / 2 - 35 },
              styles.imageTwo,
              { backgroundColor: gallery.florence.color },
            ]}
          />
        </Pressable>
        <Pressable onPress={() => goToDetails('dawn')}>
          <Animated.View
            sharedTransitionTag={'dawn'}
            style={[
              { width: width / 2 - 35 },
              styles.imageThree,
              { backgroundColor: gallery.dawn.color },
            ]}
          />
        </Pressable>
      </View>
```

### Remarks

- Only the native stack is supported.
- You can only animate `width`, `height`, `originX`, `originY`, and `transformMatrix` properties when using the shared transition.
- The layout for shared view children is not computed during the transition.
- The current implementation supports **only** the old React Native architecture (**Paper**).
- In the future we will introduce support for the new React Native architecture (Fabric).

### Platform Compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

## useAnimatedScrollHandler

`useAnimatedScrollHandler` is a hook that returns an event handler reference. It can be used with React Native's scrollable components.

### Reference

```
import { useAnimatedScrollHandler } from 'react-native-reanimated';

function App() {
  const offsetY = useSharedValue(0);

  const scrollHandler = useAnimatedScrollHandler((event) => {
    offsetY.value = event.contentOffset.y;
  });

  // ...

  return <Animated.ScrollView onScroll={scrollHandler} />;
}
```

Type definitions

```
function useAnimatedScrollHandler<Context extends Record<string, unknown>>(
  handlers: ScrollHandler<Context> | ScrollHandlers<Context>,
  dependencies?: DependencyList
): ScrollHandlerProcessed<Context>;

type ScrollHandler<
  Context extends Record<string, unknown> = Record<string, unknown>
> = (event: ReanimatedScrollEvent, context: Context) => void;

interface ScrollHandlers<Context extends Record<string, unknown>> {
  onScroll?: ScrollHandler<Context>;
  onBeginDrag?: ScrollHandler<Context>;
  onEndDrag?: ScrollHandler<Context>;
  onMomentumBegin?: ScrollHandler<Context>;
  onMomentumEnd?: ScrollHandler<Context>;
}

type DependencyList = Array<unknown> | undefined;
```

#### Arguments

##### `handlers`

Object containing custom keys matching native event names. Following keys are available:

- `onScroll`
- `onBeginDrag`
- `onEndDrag`
- `onMomentumBegin`
- `onMomentumEnd`

The values in the object should be individual worklets. Each of the worklet will be triggered when the corresponding event is dispatched on the connected Scrollable component.

Each of the event worklets will receive the following parameters when called:

- `event` - event object carrying the information about the scroll. The payload can differ depending on the type of the event. Please consult React Native's ScrollView documentation to learn about scroll event structure.

- `context` - plain JS object that can be used to store some state. This object will persist in between scroll event occurrences and you can read and write any data to it. When there are several event handlers provided in a form of an object of worklets, the `context` object will be shared in between the worklets allowing them to communicate with each other.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

The hook returns a handler object that can be hooked into a scrollable container. The returned handler should be passed under `onScroll` parameter regardless of whether it is configured to receive only scroll or also momentum or drag events. In order for the returned handler to be properly triggered, you should use containers that are wrapped with `Animated` (e.g. `Animated.ScrollView` and not just `ScrollView`).

### Example

### Remarks

- The returned handler may be passed to multiple components. In such situation, the handler will invoke for the given events each time any of the components dispatches them.
- If a single worklet function of type `(event) => void` is passed instead of a map of functions matched to event keys, it's treated as a handler for the `onScroll` event.
- Only `onScroll` event works on Web.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## scrollTo

`scrollTo` lets you synchronously scroll to a given X or Y offset.

### Reference

```
import { scrollTo } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();
  const scrollY = useSharedValue(0);

  useDerivedValue(() => {
    scrollTo(animatedRef, 0, scrollY.value, true);
  });

  return (
    <Animated.ScrollView ref={animatedRef}>{/* ... */}</Animated.ScrollView>
  );
}
```

Type definitions

```
function scrollTo<T extends Component>(
  animatedRef: AnimatedRef<T>,
  x: number,
  y: number,
  animated: boolean
): void;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the ScrollView (or other scrollable) component you'd want to scroll on. The animated ref has to be passed either to an Animated component or a React Native built-in component.

##### `x`

Value in pixels to scroll to on the horizontal X axis.

##### `y`

Value in pixels to scroll to on the vertical Y axis.

##### `animated`

Whether the scroll should be smooth (`true`) or instant (`false`).

#### Returns

`scrollTo` returns `undefined`.

### Example

### Remarks

- The `scrollTo` function can only be called from the UI thread.
- Supports `Animated.FlatList`.
- Usually works with other ScrollView-like and FlatList-like components if they use a `ScrollView` under the hood and are made animated.
- Scrollable components must implement `getScrollableNode` method (and `getNativeScrollRef` method for the New Architecture) to be compatible with `scrollTo`.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## getRelativeCoords

`getRelativeCoords` determines the location on the screen, relative to the given view.

### Reference

```
import { getRelativeCoords } from 'react-native-reanimated';

const Comp = () => {
  const animatedRef = useAnimatedRef();
  // ...

  const gestureHandler = useAnimatedGestureHandler({
    onEnd: (event) => {
      const coords = getRelativeCoords(
        animatedRef,
        event.absoluteX,
        event.absoluteY
      );
    },
  });

  return (
    <View ref={aref}>
      <PanGestureHandler onGestureEvent={gestureHandler}>
        <Animated.View style={[styles.box]} />
      </PanGestureHandler>
    </View>
  );
};
```

Type definitions

```
function getRelativeCoords(
  animatedRef: AnimatedRef<Component>,
  absoluteX: number,
  absoluteY: number
): ComponentCoords | null;

interface ComponentCoords {
  x: number;
  y: number;
}
```

#### Arguments

##### `animatedRef`

The product of `useAnimatedRef` is Reanimated's extension of a standard React ref (delivers the view tag on the UI thread). This ref should be passed as a prop to the view relative to which we want to know coordinates.

##### `absoluteX`

Number which is an absolute `x` coordinate.

##### `absoluteY`

Number which is an absolute `y` coordinate.

#### Returns

Object which contains relative coordinates

- `x`
- `y`

#### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useAnimatedGestureHandler

danger

`useAnimatedGestureHandler` lets you create animations based on gesture handlers.

You need to pass the object defined using `useAnimatedGestureHandler` to the `onGestureEvent` property of a gesture handler component.

This hook requires `react-native-gesture-handler` installed and configured in your project.

### Reference

```
import { useAnimatedGestureHandler } from 'react-native-reanimated';
import { PanGestureHandler } from 'react-native-gesture-handler';

function App() {
  const x = useSharedValue(0);

  const gestureHandler = useAnimatedGestureHandler({
    onStart: (_, ctx) => {
      ctx.startX = x.value;
    },
    onActive: (event, ctx) => {
      x.value = ctx.startX + event.translationX;
    },
  });

  return (
    <PanGestureHandler onGestureEvent={gestureHandler}>
      <Animated.View />
    </PanGestureHandler>
  );
}
```

Type definitions

```
interface GestureHandlers<
  Event extends NativeEventWrapper<PropsUsedInUseAnimatedGestureHandler>,
  Context extends Record<string, unknown>
> {
  [key: string]: GestureHandler<Event, Context> | undefined;
  onStart?: GestureHandler<Event, Context>;
  onActive?: GestureHandler<Event, Context>;
  onEnd?: GestureHandler<Event, Context>;
  onFail?: GestureHandler<Event, Context>;
  onCancel?: GestureHandler<Event, Context>;
  onFinish?: GestureHandler<Event, Context>;
}

function useAnimatedGestureHandler<
  Event extends NativeEventWrapper<PropsUsedInUseAnimatedGestureHandler> = DefaultEvent,
  Context extends Record<string, unknown> = Record<string, unknown>
>(handlers: GestureHandlers<Event, Context>, dependencies?: DependencyList);
```

#### Arguments

##### `gestureHandlers`

The first argument is an object that can carry one or more handlers. You can set the handlers under the following keys: `onStart`, `onActive`, `onEnd`, `onFail`, `onCancel`, `onFinish`.

Each of the specified handlers will be triggered depending on the current state of the attached gesture handler. Read more about gesture handling states in the Gesture Handler documentation. The handler receives the following arguments:

- `event` \[object] - an event object carrying the event payload. The payload will be different depending on the type of the gesture handler to which the callback is attached to (`PanGestureHandler`, `RotationGestureHandler`, etc.).

- `context` \[object] - a JavaScript object that can be used to store some state. You can read and write any data to it. This object persists between events and across handlers for all the selected states.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

`useAnimatedGestureHandler` returns a handler object that can be attached to one of the gesture handler components provided by the `react-native-gesture-handler` library. You need to pass this object to the `onGestureEvent` property of a gesture handler.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ⚠️  |

\* On Web, you have to pass returned handler object to both `onGestureEvent` and `onHandlerStateChange` parameters.

Version: 3.x

On this page

## useScrollViewOffset

`useScrollViewOffset` lets you to create animations based on the offset of a `ScrollView`. The hook automatically detects if the `ScrollView` is horizontal or vertical.

### Reference

```
import { useScrollViewOffset } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();
  const scrollOffset = useScrollViewOffset(animatedRef);
  return (
    <Animated.ScrollView ref={animatedRef}>{/* ... */}</Animated.ScrollView>
  );
}
```

Type definitions

```
function useScrollViewOffset(
  animatedRef: AnimatedRef<AnimatedScrollView>,
  initialRef?: SharedValue<number>
): SharedValue<number>;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the ScrollView component you'd want to scroll on. The animated ref has to be passed either to an Animated component or a React Native built-in component.

##### `initialRef`Optional

An optional shared value to be updated with the scroll offset. If not provided a new shared value will be created internally.

#### Returns

`useScrollViewOffset` returns a shared value which holds the current offset of the `ScrollView`.

### Example

### Remarks

- The `animatedRef` argument can be changed at will and the hook will correctly return values based on the ScrollView component it is connected to, for example:

  `useScrollViewOffset(someState ? someScrollRefA : someScrollRefB)`

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

## Advanced APIs

###

###

###

###

###

###

###

###

###

## Handling gestures

In this section, we'll learn how to handle gestures with Reanimated. To achieve this, Reanimated integrates tightly with React Native Gesture Handler, another library created by Software Mansion.

Gesture Handler comes with plentiful gestures like `Pinch` or `Fling`. Right now we'll start simple and get to know `Tap` and `Pan` gestures as well as how to use `withDecay` animation function.

Just make sure to go through the Gesture Handler installation steps first and come back here to learn how to use it with Reanimated.

### Handling tap gestures

Let's start with the simplest gesture - tapping. Tap gesture detects fingers touching the screen for a short period of time. You can use them to implement custom buttons or pressable elements from scratch.

In this example, we'll create a circle that will grow and change color on touch.

First, let's wrap our app with `GestureHandlerRootView`. Make sure to keep the `GestureHandlerRootView` as close to the actual root view as possible. That'll ensure that our gestures will work as expected with each other.

```
import { GestureHandlerRootView } from 'react-native-gesture-handler';

function App() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      {/* rest of the app */}
    </GestureHandlerRootView>
  );
}
```

New tap gestures are defined with `Gesture.Tap()` in your component's body. You can define the behavior of the gesture by chaining methods like `onBegin`, `onStart`, `onEnd`, or `onFinalize` on the gesture. We'll use them to update a shared value just after the gesture begins and return to the initial value when the gesture finishes.

Expand the full code

```
export default function App() {
  const pressed = useSharedValue<boolean>(false);

  const tap = Gesture.Tap()
    .onBegin(() => {
      pressed.value = true;
    })
    .onFinalize(() => {
      pressed.value = false;
    });
```

You can safely access the shared values because callbacks passed to gestures are automatically workletized for you.

We'd like our circle to change color from violet to yellow and smoothly scale by 20% on tap. Let's define that animation logic using `withTiming` in the `useAnimatedStyle`:

Expand the full code

```
  const animatedStyles = useAnimatedStyle(() => ({
    backgroundColor: pressed.value ? '#FFE04B' : '#B58DF1',
    transform: [{ scale: withTiming(pressed.value ? 1.2 : 1) }],
  }));
```

You need to pass your defined gesture to the `gesture` prop of the `GestureDetector` component. That component should wrap the view you'd like to handle gestures on. Also, remember to pass the defined `animatedStyles` to the view you want to animate like so:

Expand the full code

```
  return (
    <GestureHandlerRootView style={styles.container}>
      <View style={styles.container}>
        <GestureDetector gesture={tap}>
          <Animated.View style={[styles.circle, animatedStyles]} />
        </GestureDetector>
      </View>
    </GestureHandlerRootView>
  );
}
```

And that's it! Pretty straightforward, isn't it? Let's see it in its full glory in an interactive example:

You can make use of composing gestures to more complex behaviors. But what if we'd like to create something a bit more interesting?

### Handling pan gestures

Let's spice things up a bit by making the circle draggable and have it bounce back to its starting position when released. Let's also keep the color highlight and scale effect we've added in the previous example. Implementing this behavior it's not possible with just a simple tap gesture. We need to reach for a pan gesture instead.

Luckily, all the gestures share a similar API so implementing this is nearly as easy as renaming the `Tap` gesture to `Pan` and chaining an additional `onChange` method.

Expand the full code

```

  const offset = useSharedValue<number>(0);

  const pan = Gesture.Pan()
    .onBegin(() => {
      pressed.value = true;
    })
    .onChange((event) => {
      offset.value = event.translationX;
    })
    .onFinalize(() => {
      offset.value = withSpring(0);
      pressed.value = false;
```

The callback passed to `onChange` comes with some event data that has a bunch of handy properties. One of them is `translationX` which indicates how much the object has moved on the X axis. We stored that in a shared value to move the circle accordingly. To make the circle come back to its initial place all you have to do is to reset the `offset.value` in the `onFinalize` method. We can use `withSpring` or `withTiming` functions to make it come back with an animation.

All that's left to do is to adjust the logic in `useAnimatedStyle` to handle the offset.

Expand the full code

```

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [
      { translateX: offset.value },
      { scale: withTiming(pressed.value ? 1.2 : 1) },
    ],
    backgroundColor: pressed.value ? '#FFE04B' : '#b58df1',
  }));
```

You can play around with the example below and see how the circle changes and reacts to the gesture:

### Using `withDecay`

Remember when some time ago we said that we'll come back to `withDecay`? Now this is the time!

`withDecay` lets you retain the velocity of the gesture and animate with some deceleration. That means when you release a grabbed object with some velocity you can slowly bring it to stop. Sounds complicated but it really isn't!

Simply pass the final velocity in `onFinalize` method to the `velocity` property of `withDecay` function and let Reanimated handle it for you. To retain the new position of an object update the change on the X axis in `onChange` method like so:

Expand the full code

```

  const pan = Gesture.Pan()
    .onChange((event) => {
      offset.value += event.changeX;
    })
    .onFinalize((event) => {
      offset.value = withDecay({
        velocity: event.velocityX,
        rubberBandEffect: true,
        clamp: [
          -(width.value / 2) + SIZE / 2 + BOUNDARY_OFFSET,
          width.value / 2 - SIZE / 2 - BOUNDARY_OFFSET,
```

The rest of the code is just to make sure the square stays inside the screen.

Play around and see how the square decelerates when let go with some speed!

Make sure to check the full `withDecay` API reference to get to know the rest of the configuration options.

### Summary

In this section, we went through the basics of handling gestures with Reanimated and Gesture Handler. We learned about `Tap` and `Pan` gestures and `withDecay` function. To sum up:

- Reanimated integrates with a different package called React Native Gesture Handler to provide seamless interactions.
- We create new gestures, such as `Gesture.Pan()` or `Gesture.Tap()`, and pass them to `GestureDetector`, which has to wrap the element we want to handle interactions on.
- You can access and modify shared values inside gesture callbacks without any additional boilerplate.
- `withDecay` lets you create decelerating animations based on velocity coming from a gesture.

### What's next?

In this article, we've barely scratched the surface of what's possible with gestures in Reanimated. Besides Tap and Pan gestures Gesture Handler comes with many more e.g. Pinch or Fling. We welcome you to dive into the Quick start section of the React Native Gesture Handler documentation and explore all the possibilities that this library comes with.

In the next section, Let's explore a glossary of terms together!

## withRepeat

`withRepeat` is an animation modifier that lets you repeat an animation given number of times or run it indefinitely.

### Reference

```
import { withRepeat } from 'react-native-reanimated';

function App() {
  sv.value = withRepeat(withSpring(0), 5);
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

function withRepeat<T extends AnimatableValue>(
  animation: T,
  numberOfReps?: number,
  reverse?: boolean,
  callback?: (finished?: boolean, current?: AnimatableValue) => void,
  reduceMotion?: ReduceMotion
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `animation`

An animation object you want to repeat.

##### `numberOfReps`Optional

The number of times the animation is going to be repeated. Defaults to `2`.

A non-positive value (e.g. `0` or `-1`) will cause the animation to repeat indefinitely until it is cancelled or torn down. For example, if the component unmounts or `cancelAnimation` was called.

##### `reverse`Optional

Whether the animation should run in reverse every other repetition. Defaults to `false`.

This option only supports animation functions (eg. `withSpring`) and doesn't work with animation modifiers (eg. `withSequence`).

##### `callback`Optional

A function called on animation complete. In case the animation is cancelled, the callback will receive `false` as the argument, otherwise it will receive `true`.

##### `reduceMotion`Optional

A parameter that determines how the animation responds to the device's reduced motion accessibility setting.

#### Returns

`withRepeat` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Remarks

- The callback passed to the 4th argument is automatically workletized and ran on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## measure

`measure` lets you synchronously get the dimensions and position of a view on the screen, all on the UI thread.

### Reference

```
import { measure } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();

  const handlePress = () => {
    runOnUI(() => {
      const measurement = measure(animatedRef);
      if (measurement === null) {
        return;
      }
      // ...
    })();
  };

  return <Animated.View ref={animatedRef} />;
}
```

Type definitions

```
interface MeasuredDimensions {
  x: number;
  y: number;
  width: number;
  height: number;
  pageX: number;
  pageY: number;
}

function measure<T extends Component>(
  animatedRef: AnimatedRef<T>
): MeasuredDimensions | null;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the component you'd want to get the measurements from. The animated ref has to be passed either to an Animated component or a React Native built-in component.

#### Returns

`measure` returns an object containing these fields:

- `x` a number representing X coordinate relative to the parent component,
- `y` a number representing Y coordinate relative to the parent component,
- `width` a number representing the width of the component,
- `height` a number representing the height of the component,
- `pageX` a number representing X coordinate relative to the screen,
- `pageY` a number representing Y coordinate relative to the screen,

or returns `null` when the measurement couldn't be performed.

### Example

### Remarks

- `measure` is implemented only on the UI thread. When using `measure` inside event handlers, it has to be wrapped with the `runOnUI` function.

- The `useAnimatedStyle` function is first evaluated on the JavaScript thread just before the views are attached to the native side. For this reason, to safely use the measure within `useAnimatedStyle`, a condition similar to the one below must be added to the code:

```
function App() {
  const animatedStyles = useAnimatedStyle(() => {
    if (_WORKLET) {
      // safely use measure
      const measurement = measure(animatedRef);
    }
  });
}
```

Consecutive runs of `useAnimatedStyle` are executed on the UI thread.

- When you only need the dimensions of the component and won't use the measurements during animation, consider using the `onLayout` property instead.

- Sometimes, `measure` returns `null` (e.g., when the `ref` hasn't yet attached to the view). It's best to add a `null` check after the measurement for added safety.

```
const animatedRef = useAnimatedRef();

const handlePress = () => {
  runOnUI(() => {
    const measurement = measure(animatedRef);

    if (measurement === null) {
      return;
    }
    // ...
  })();
};
```

- `measure` can be used only on rendered components. For instance, attempting to `measure` off-screen items in a `FlatList` will return a `null` value.

- `measure` isn't available with the Remote JS Debugger. We highly recommend using Chrome DevTools (also known as `chrome://inspect`) for debugging React Native apps.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useAnimatedReaction

`useAnimatedReaction` allows you to respond to changes in a shared value. It's especially useful when comparing values previously stored in the shared value with the current one.

### Reference

```
import { useAnimatedReaction } from 'react-native-reanimated';

function App() {
  useAnimatedReaction(
    () => {
      return sv.value;
    },
    (currentValue, previousValue) => {
      if (currentValue !== previousValue) {
        // do something ✨
      }
    }
  );

  // ...
}
```

Type definitions

```
type DependencyList = ReadonlyArray<any>;

function useAnimatedReaction<T>(
  prepare: () => T,
  react: (prepareResult: T, preparePreviousResult: T | null) => void,
  dependencies?: DependencyList
): void;
```

#### Arguments

##### `prepare`

A function that should return a value to which you'd like to react. The value returned from this function is used as the first parameter of the `react` argument.

```
function App() {
  useAnimatedReaction(
    () => {
      return Math.floor(sv.value);
    },
    (currentValue, previousValue) => {
      // ...
    }
  );
}
```

##### `react`

A function that reacts to changes in the value returned by the `prepare` function. The `react` function has two parameters: the current value from the `prepare` function and the previous value, which is initially set to `null`.

```
function App() {
  useAnimatedReaction(
    () => {
      return Math.floor(sv.value);
    },
    (currentValue, previousValue) => {
      // ...
    }
  );
}
```

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

`useAnimatedReaction` returns `undefined`.

### Example

### Remarks

- Ensure you do not mutate the same shared value in the `result` function that you've used in the `prepare` function, as this will lead to an infinite loop.

```
function App() {
  useAnimatedReaction(
    () => {
      return width.value;
    },
    (currentValue) => {
      // 🚨 An infinite loop!
      width.value += currentValue;
    }
  );
}
```

- Callbacks passed to the `prepare` and `result` arguments are automatically workletized and run on the UI thread.

- You can technically react to any stateful React value using `useAnimatedReaction` but you should probably use a `useEffect` for that instead.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## withSequence

`withSequence` is an animation modifier that lets you run animations in a sequence.

### Reference

```
import { withSequence } from 'react-native-reanimated';

function App() {
  sv.value = withSequence(withTiming(50), withTiming(0));
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

function withSequence<T extends AnimatableValue>(
  reduceMotion?: ReduceMotion,
  ...animations: [T, ...T[]]
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `reduceMotion`Optional

A parameter that determines how the animation responds to the device's reduced motion accessibility setting.

##### `...animations`

Any number of animation objects to be run in a sequence.

#### Returns

`withSequence` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## useFrameCallback

`useFrameCallback` lets you run a function on every frame update.

### Reference

```
import { useFrameCallback } from 'react-native-reanimated';

function App() {
  const frameCallback = useFrameCallback((frameInfo) => {
    // Increment a value on every frame update
    sv.value += 1;
  });

  return (
    <Button
      title="Start/Stop"
      onPress={() => frameCallback.setActive(!frameCallback.isActive)}
    />
  );
}
```

Type definitions

```
type FrameInfo = {
  timestamp: number;
  timeSincePreviousFrame: number | null;
  timeSinceFirstFrame: number;
};

type FrameCallback = {
  setActive: (isActive: boolean) => void;
  isActive: boolean;
  callbackId: number;
};

function useFrameCallback(
  callback: (frameInfo: FrameInfo) => void,
  autostart = true
): FrameCallback;
```

#### Arguments

##### `callback`

A function executed on every frame update. This function receives a `frameInfo` object containing the following fields:

- `timestamp` a number indicating the system time (in milliseconds) when the last frame was rendered.
- `timeSincePreviousFrame` a number indicating the time (in milliseconds) since last frame. This value will be null on the first frame after activation. Starting from the second frame, it should be \~16 ms on 60 Hz, and \~8 ms on 120 Hz displays (provided there are no frame dropped).
- `timeSinceFirstFrame` a number indicating the time (in milliseconds) since the callback was activated.

##### `autostart`Optional

Whether the callback should start automatically. Defaults to `true`.

#### Returns

`useFrameCallback` returns an object containing these fields:

- `setActive` a function that lets you start the frame callback or stop it from running
- `isActive` a boolean indicating whether a callback is running
- `callbackId` a number indicating a unique identifier of the frame callback

### Example

### Remarks

- A function passed to the `callback` argument is automatically workletized and ran on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
  -

-

-

-

##

## Glossary of terms

### Animated component

Animated components are components which Reanimated can animate. Reanimated comes with just a handful of built-in components like `Animated.View`, `Animated.Text`, or `Animated.ScrollView`.

```
import Animated from 'react-native-reanimated';

function App() {
  return (
    <Animated.View
      style={{
        width: 100,
        height: 100,
        backgroundColor: 'violet',
      }}
    />
  );
}
```

For components which aren't a part of Reanimated, to make their props and styles animatable, you have to wrap them with `createAnimatedComponent`:

```
import Animated from 'react-native-reanimated';
import { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
```

### Shared value

Shared values are a driving factor of all your animations in Reanimated.

They are defined using `useSharedValue` hook:

```
import { useSharedValue } from 'react-native-reanimated';
```

and accessed and modified by their `.value` property:

```
function App() {
  const sv = useSharedValue(0);

  const handlePress = () => {
    sv.value += 10;
  };

  // rest of your glamorous code ✨
}
```

It can be a value of any type. When used, the data stored in a shared value is automatically synchronized between the JavaScript thread and the UI thread.

### Animatable value

An animatable value refers to a type of value that can be used for animations. These values include numbers, strings, and arrays of numbers.

String values can be animated if they are in a specific format, such as `"10deg"`, `"21%"`, or even colors like `"#ffaabb"` or `"rgba(100, 200, 100, 0.7)"`.

### Animation function

Animation functions are functions which let you create animations. They are building blocks that describe how your animations should behave.

Reanimated comes with 3 built-in animation functions:

- `withSpring` lets you create spring-based animation
- `withTiming` lets you create an animation based on duration and easing
- `withDecay` lets you create animations that mimic objects in motion that move with a given deceleration rate

These functions can be combined with animation modifiers to create rich and complex animations.

### Animation modifier

Animation modifiers are functions used to customize animations. Also known as higher-order animations.

Reanimated comes with 3 built-in modifiers:

- `withDelay` lets you add a delay before the animation starts
- `withRepeat` lets you repeat an animation certain number of times
- `withSequence` lets you chain animation one after the other
- `withClamp` lets you limit the animation boundaries to a specified range

### Animation object

An animation object is a value returned from animation functions and modifiers which holds the current state of the animation including its start and end conditions, as well as a `onFrame` function. These values allow to calculate the animation state for each frame.

When you pass an animation object to a shared value it is automatically treated as an animatable value.

For example, consider this code:

```
sv.value = withSpring(100);
```

Even though, the `withSpring` returns an animation object the final result that is stored in a shared value is just a number.

### Animations in inline styling

Passing shared values directly to `style` property without the use of `useAnimatedStyle`.

For example:

```
function App() {
  const width = useSharedValue(100);

  return <Animated.View style={{ width }} />;
}
```

### Layout animation modifier

Layout animation modifiers are methods used to customize layout animations.

```
<Animated.View entering={FadeOutLeft.duration(500).easing(Easing.ease)} />
```

Reanimated comes with plenty of built-in layout animation modifiers. Some of them are:

- `.duration(durationMs: number)` - the length of the animation (in milliseconds).
- `.easing(easingFunction: EasingFunction)` - an easing function which defines the animation curve.
- `.springify()` - enables the spring-based animation configuration.
- `.damping(value: number)` - decides how quickly a spring stops moving.
- `.withCallback(callback: (finished: boolean) => void)` - the callback that will fire after the animation ends.

For a list of all available modifiers for each animation refer to the documentation of individual layout animation.

### Worklet

Worklets are short-running JavaScript functions that can be run on the UI thread. They can also be run on a JavaScript thread just as you would run a function in your code.

Most of the time when working with Reanimated the code is automatically workletized and run on the UI thread by default.

```
const style = useAnimatedStyle(() => {
  console.log('Running on the UI thread');
  return { opacity: 0.5 };
});
```

You can create your own worklets using the `"worklet";` directive at the top of a function.

```
function myWorklet() {
  'worklet';
  console.log('Running on the UI thread');
}
```

`runOnUI` lets you manually run worklets on the UI thread:

```
function myWorklet(greeting) {
  'worklet';
  console.log(`${greeting} from the UI thread`);
}

function onPress() {
  runOnUI(myWorklet)('Howdy');
}
```

### to workletize

To convert a JavaScript function into a serializable object which can be copied and run over on UI thread.

Functions marked with `"worklet";` directive are automatically picked up and workletized by the Reanimated Babel plugin.

### JavaScript thread

JavaScript thread (or JS thread for short) is responsible for handling JavaScript code execution in the app.

This is the primary place where the React Native app code is executed.

### UI thread

UI thread is responsible for handling user interface updates. Also known as Main thread.

You can learn more about it by reading the Threading model article in the official React Native docs.

### Reanimated Babel plugin

The plugin performs automatic workletization of certain functions used with Reanimated to reduce the amount of boilerplate code.

You can learn the details by reading the Reanimated Babel plugin README.

Version: 3.x

On this page

## withDelay

`withDelay` is an animation modifier that lets you start an animation with a delay.

### Reference

```
import { withDelay } from 'react-native-reanimated';

function App() {
  sv.value = withDelay(500, withTiming(0));
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

function withDelay<T extends AnimatableValue>(
  delayMs: number,
  delayedAnimation: T,
  reduceMotion?: ReduceMotion
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `delayMs`

Duration (in milliseconds) before the animation starts.

##### `delayedAnimation`

Animation to delay.

##### `reduceMotion`Optional

A parameter that determines how the animation responds to the device's reduced motion accessibility setting.

#### Returns

`withDelay` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## useAnimatedKeyboard

`useAnimatedKeyboard` lets you create animations based on state and height of the virtual keyboard.

caution

Android implementation of `useAnimatedKeyboard` has drawbacks on Android SDK < 30, for more details see remarks section.

### Reference

```
import { useAnimatedKeyboard, useAnimatedStyle } from 'react-native-reanimated';

export default function App() {
  const keyboard = useAnimatedKeyboard();

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [{ translateY: -keyboard.height.value }],
  }));
}
```

Type definitions

```
// --- Function declaration ---

function useAnimatedKeyboard(
  options: AnimatedKeyboardOptions
): AnimatedKeyboardInfo;

// --- Configuration types ---

export interface AnimatedKeyboardOptions {
  isStatusBarTranslucentAndroid?: boolean;
}

// --- Return types ---

export type AnimatedKeyboardInfo = {
  height: SharedValue<number>;
  state: SharedValue<KeyboardState>;
};

export enum KeyboardState {
  UNKNOWN = 0,
  OPENING = 1,
  OPEN = 2,
  CLOSING = 3,
  CLOSED = 4,
}
```

#### Arguments

##### `options`Optional

Optional object containing additional configuration:

- `isStatusBarTranslucentAndroid` - removes top inset on Android i.e. to use translucent status bar on Android, set this option to `true`. Defaults to `false`. Ignored on iOS.

#### Returns

Hook `useAnimatedKeyboard` returns an object containing these fields:

| Name | Type | Description |
| --- | --- | --- |
| height | `SharedValue<number>` | A shared value containing current height of the keyboard. |
| state | `SharedValue<KeyboardState>` | A shared value containing current state of the keyboard. Possible states: `{ CLOSED, OPEN, CLOSING, OPENING }` |

### Example

### Remarks

- On Android, make sure to set `android:windowSoftInputMode` in your `AndroidManifest.xml` to `adjustResize`. Then, using the `useAnimatedKeyboard` hook disables the default Android behavior (resizing the view to accommodate keyboard) in the whole app. Using values from `useAnimatedKeyboard` hook you can handle the keyboard yourself. Unmounting all components that use `useAnimatedKeyboard` hook brings back the default Android behavior.

- On Android, using the `useAnimatedKeyboard` hook expands root view to full screen (immersive mode) and takes control over insets management.

  - When `isStatusBarTranslucentAndroid` is `false` it applies the top margin according to the insets.

  - When `isStatusBarTranslucentAndroid` is `true` it sets top margin to `0`.

  - When `isNavigationBarTranslucentAndroid` is `false` it applies the bottom margin according to the insets.

  - When `isNavigationBarTranslucentAndroid` is `true` it sets bottom margin to `0`.

- On Android, when using navigation with native header, `isStatusBarTranslucentAndroid` doesn't affect the top inset.

- On Android SDK < 30, when status bar is hidden, the keyboard reverts to the default Android behavior.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

- -
  -

-

-

-

## useComposedEventHandler

This is a hook that lets you compose useEvent-based event handlers (such as useAnimatedScrollHandler or your own custom ones) into a single, combined event handler.

### Reference

```
import Animated, {
  useAnimatedScrollHandler,
  useComposedEventHandler,
} from 'react-native-reanimated';

function ComposedEventHandlerExample() {
  const onScrollHandler1 = useAnimatedScrollHandler({
    onScroll(e) {
      console.log('Scroll handler 1 onScroll event');
    },
  });

  const onScrollHandler2 = useAnimatedScrollHandler({
    onScroll(e) {
      console.log('Scroll handler 2 onScroll event');
    },
  });

  const composedHandler = useComposedEventHandler([
    onScrollHandler1,
    onScrollHandler2,
  ]);

  return (
    <View style={styles.container}>
      <Animated.ScrollView style={styles.scroll} onScroll={composedHandler}>
        <Content />
      </Animated.ScrollView>
    </View>
  );
}
```

Type definitions

```
function useComposedEventHandler(
  handlers: (EventHandlerProcessed<Event, Context> | null)[]
): ComposedHandlerProcessed<Event, Context>;
```

#### Arguments

##### `handlers`

An array of event handlers created using useEvent hook. `useComposedEventHandler` hook reacts to any changes in given handlers and rebuilds whenever it is needed.

#### Returns

The hook returns a handler object that can be hooked into any `Animated component`. The handler should be passed to a corresponding `onEvent` prop (e.g. `onScroll` when working with scroll-related handlers). If your composed handler aggregates multiple events that have little in common, put it into a new property, e.g. "composedHandler". It will still work, but the best practice here would be to use several composed handlers for code clarity.

### Remarks

- The hook returns a handler that combines functionalities of all the handlers given as an argument. This way, you can have more than one handler responding to a given event, as well as handle many different type events using just one object.
- It will still work well when passed to multiple `Animated components`, firing event callbacks for each connected component.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## dispatchCommand

`dispatchCommand` allows you to run commands on a native component from the UI thread directly.

### Reference

```
import { dispatchCommand } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();

  const gesture = Gesture.Tap().onStart(() => {
    dispatchCommand(animatedRef, 'focus');
  });

  return (
    <>
      <AnimatedTextInput ref={animatedRef} style={styles.input} />
      <GestureDetector gesture={gesture}>
        <Button title="Focus" />
      </GestureDetector>
    </>
  );
}
```

Type definitions

```
function dispatchCommand<T extends Component>(
  animatedRef: AnimatedRef<T>,
  commandName: string,
  args?: unknown[]
) => void;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the component you'd want to update. The animated ref has to be passed either to an Animated component or a React Native built-in component.

##### `commandName`

The name of the command to execute, e.g. `'focus'` or `'scrollToEnd'`.

##### `args`Optional

The array of command arguments. Defaults to an empty array.

### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

Expand the full code

```
  const goDown = Gesture.Tap().onStart(() => {
    dispatchCommand(tosRef, 'scrollToEnd', [true]);
    dispatchCommand(loginRef, 'focus');
  });
```

### Remarks

- Commands differ from component to component. Check relevant sources i.e. React Native documentation on components to see which commands are available.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

## withClamp

`withClamp` is an animation modifier that lets you limit the scope of movement of your animation to make it stay within some predefined range. Use it with withSpring animation.

### Reference

```
import { withClamp } from 'react-native-reanimated';

function App() {
  sv.value = withClamp({ min: -1, max: 1 }, withSpring(0));
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

function withClamp<T extends number | string>(
  config: {
    min?: T;
    max?: T;
  },
  clampedAnimation: T
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `config`

An object with following properties:

\| Name | Type Description | | ---------------- | ---------------- | ------------------------------------------------ | | min

Optional

\| `number` | The lowest value your animation can ever reach | | max

Optional

\| `number` | The greatest value your animation can ever reach |

##### `animation`

The spring animation you want to clamp.

```
const clampedStyleWithDelay = useAnimatedStyle(() => {
  return {
    width: withClamp({ min: 0, max: 100 }, withSpring(randomWidth.value)),
  };
});
```

#### Returns

`withClamp` returns an animation object. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useAnimatedSensor

`useAnimatedSensor` lets you create animations based on data from the device's sensors. You can access:

- **Accelerometer** - the device acceleration (without gravity).
- **Gyroscope** - the rotation rate of the device.
- **Gravity** - the current gravity vector.
- **Magnetic field** - the magnetic field vector.
- **Rotation** - the device orientation in three dimensions.

For a full, in depth documentation follow the Sensors guide on Android Developers and the Device motion in the Apple Developer documentation.

The playground below mimics the behaviour and returned values of selected sensors:

### Reference

```
import { useAnimatedSensor, SensorType } from 'react-native-reanimated';

function App() {
  const gyroscope = useAnimatedSensor(SensorType.GYROSCOPE);

  useDerivedValue(() => {
    const { x, y, z } = gyroscope.sensor.value;
  });
}
```

Type definitions

```
// --- Function declaration ---

function useAnimatedSensor(
  sensorType: SensorType,
  config?: Partial<SensorConfig>
): AnimatedSensor<ValueRotation | Value3D>;

// --- Configuration types ---

enum SensorType {
  ACCELEROMETER = 1,
  GYROSCOPE = 2,
  GRAVITY = 3,
  MAGNETIC_FIELD = 4,
  ROTATION = 5,
}

type SensorConfig = {
  interval: number | 'auto';
  adjustToInterfaceOrientation: boolean;
  iosReferenceFrame: IOSReferenceFrame;
};

enum IOSReferenceFrame {
  XArbitraryZVertical,
  XArbitraryCorrectedZVertical,
  XMagneticNorthZVertical,
  XTrueNorthZVertical,
  Auto,
}

// --- Return types ---

type AnimatedSensor<T extends Value3D | ValueRotation> = {
  sensor: SharedValue<T>;
  unregister: () => void;
  isAvailable: boolean;
  config: SensorConfig;
};

type Value3D = {
  x: number;
  y: number;
  z: number;
  interfaceOrientation: InterfaceOrientation;
};

type ValueRotation = {
  qw: number;
  qx: number;
  qy: number;
  qz: number;
  yaw: number;
  pitch: number;
  roll: number;
  interfaceOrientation: InterfaceOrientation;
};

enum InterfaceOrientation {
  ROTATION_0 = 0,
  ROTATION_90 = 90,
  ROTATION_180 = 180,
  ROTATION_270 = 270,
}
```

#### Arguments

##### `sensorType`

A type of a sensor to use. You specify the sensor type using a `SensorType` enum containing fields:

- `ACCELEROMETER` - measures the device acceleration along x, y, and z axes (excluding gravity) in m/s2.
- `GYROSCOPE` - measures the rate of rotation along x, y, and z axes in radians per second.
- `GRAVITY` - measures acceleration due to gravity along x, y, and z axes in m/s2.
- `MAGNETIC_FIELD` - measures the strength and direction of the Earth's magnetic field in microtesla (μT).
- `ROTATION` - measures the device orientation in three dimensions. This sensor represents the rotation by both Euler angles (roll, pitch, and yaw) and a quaternion.

##### `config`Optional

Available properties:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| interval | `number｜"auto"` | `"auto"` | Time in milliseconds between sensor readings. `"auto"` matches the device's screen refresh rate. |
| adjustToInterfaceOrientation | `boolean` | `true` | Whether to adjust measurements to the current interface orientation. |
| iosReferenceFrame | `IOSReferenceFrame` | `IOSReferenceFrame.Auto` | The frame of reference for device's sensors on iOS. |

You can specify the iOS reference frame using an `IOSReferenceFrame` enum containing fields:

- `xArbitraryZVertical` a reference frame where the Z axis is vertical and the X axis points in an arbitrary direction in the horizontal plane.
- `xArbitraryCorrectedZVertical` a reference frame where the Z axis is vertical and has improved rotation accuracy, and the X axis points in an arbitrary direction in the horizontal plane.
- `XMagneticNorthZVertical` a reference frame where the Z axis is vertical and the X axis points to the magnetic north pole.
- `XTrueNorthZVertical` a reference frame where the Z axis is vertical and the X axis points to the geographic north pole.
- `Auto` on iOS devices without magnetometer (eg. iPods) `XArbitraryZVertical`, on devices with magnetometer `XArbitraryCorrectedZVertical`

#### Returns

`useAnimatedSensor` returns an object containing these fields:

| Name | Type | Description |
| --- | --- | --- |
| sensor | `SharedValue<Value3D｜ValueRotation>` | A shared value containing the sensor measurements. The values returned by the sensor depend on the type of sensor you choose with sensorType argument. |
| unregister | `() => void` | Allows to stop listening to sensor updates on call. |
| isAvailable | `boolean` | Indicates whether sensor is available to use. You won't be able to use a sensor when it's missing from the device or the app doesn't have permission to access it. |
| config | `SensorConfig` | An object containing sensor configuration. |

The shared value returned from the **rotation sensor** is an object contain Euler angles, a quaternion and an interface orientation:

Euler angles are:

- `roll: number` - a rotation in radians along an axis that goes from the top to the bottom of the device.
- `pitch: number` - a rotation in radians along an axis that goes from side to side of the device.
- `yaw: number` - a rotation in radians along an axis that goes from the front to the back of the device.

Roll

Pitch

Yaw

Quaternion is a convenient way to represent rotations. Quaternion is based on complex numbers and isn't easy to understand intuitively. They simplify interpolation between two rotations. Quaternions are oftentimes used in computer graphics because they don't suffer from a gimbal lock. Rotation sensor returns a quaternion in form of its components which are:

- `qw: number` - W component of the quaternion.
- `qx: number` - X component of the quaternion.
- `qy: number` - Y component of the quaternion.
- `qz: number` - Z component of the quaternion.

and

- `interfaceOrientation: InterfaceOrientation`.

**All other sensors** return an object with measurements in the x, y and z axes and the interface orientation:

- `x` - sensor measurement on the X axis.
- `y` - sensor measurement on the Y axis.
- `z` - sensor measurement on the Z axis.
- `interfaceOrientation: InterfaceOrientation`.

Depending on the sensor type the measurement is a number in radians per second, m/s2 or microtesla (μT).

`InterfaceOrientation` is an enum containing these properties:

- `ROTATION_0` - default rotation on Android, portrait orientation on iOS.
- `ROTATION_90` - 90 degrees rotation on Android, landscape right orientation on iOS (landscape and home button on the right).
- `ROTATION_180` - 180 degrees rotation on Android, upside down orientation on iOS.
- `ROTATION_270` - 270 degrees rotation on Android, landscape left orientation on iOS (landscape and home button on the left).

### Example

Expand the full code

```
export default function App() {
  const gravity = useAnimatedSensor(SensorType.GRAVITY);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: withSpring(gravity.sensor.value.x * 20) },
        { translateY: withSpring(gravity.sensor.value.y * 20) },
      ],
    };
  });

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyle]} />
    </View>
  );
}
```

### Remarks

- On iOS, if you want to read sensor data you need to enable location services on your device (`Settings > Privacy > Location Services`).

- On Web, the device needs to support sensors and your web application has to be connected over HTTPS.

- Most of the sensors operate in resolutions up to 100Hz.

- You can read the sensor data on both UI thread and JavaScript thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## setNativeProps

`setNativeProps` lets you imperatively update component properties.

caution

`setNativeProps` is an escape hatch for specific edge-cases.

You should always reach for `useAnimatedStyle` and `useAnimatedProps` first when animating styles or properties.

### Reference

```
import { setNativeProps } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();

  const tap = Gesture.Tap().onEnd(() => {
    setNativeProps(animatedRef, { text: '' });
  });

  return <TextInput ref={animatedRef} />;
}
```

Type definitions

```
function setNativeProps<T extends Component>(
  animatedRef: AnimatedRef<T>,
  updates: StyleProps
) => void;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the component you'd want to update. The animated ref has to be passed either to an Animated component or a React Native built-in component.

##### `updates`

An object with properties you want to update. These could be both style props (eg. `width`, `backgroundColor`) and regular props (eg. `text`).

#### Returns

`setNativeProps` returns `undefined`.

### Example

### Remarks

- You should always reach for `useAnimatedStyle` and `useAnimatedProps` first when animating styles or properties.

- `setNativeProps` is supposed to only be used on the UI thread.

- `setNativeProps` function was created to allow updating props imperatively from gesture handlers. Because in other cases, you need to wrap `setNativeProps` with an additional `runOnUI` call, React Native's built-in `setNativeProps` proves to work better with fewer jumps between runtimes.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## useReducedMotion

`useReducedMotion` lets you query the reduced motion system setting. You can use it to disable animations.

### Reference

```
import { useReducedMotion } from 'react-native-reanimated';

function App() {
  const reduceMotion = useReducedMotion();

  if (reduceMotion) {
    // display static content ✨
  } else {
    // run animations ✨
  }

  // ...
}
```

#### Returns

`useReducedMotion` returns a boolean indicating whether the reduced motion setting was enabled when the app started.

### Example

### Remarks

- Changing the reduced motion system setting doesn't cause your components to rerender.
- In contrast to `AccessibilityInfo.isReduceMotionEnabled()` the `useReducedMotion` hook lets you get the value synchronously.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
-
-
-

## makeMutable

caution

The usage of `makeMutable` is discouraged in most cases. It's recommended to use the `useSharedValue` hook instead unless you know what you're doing and you are aware of the consequences (see the Remarks section).

`makeMutable` is used internally and its behavior may change over time.

`makeMutable` is a function internally used by the `useSharedValue` hook to create a shared value.

It makes it possible to create mutable values without the use of the hook, which can be useful in some cases (e.g. in the global scope, as an array of mutable values, etc.).

The created object is, in fact, the same as the one returned by `useSharedValue` hook, so the further usage is the same.

### Reference

```
import { makeMutable } from 'react-native-reanimated';

const mv = makeMutable(100);
```

Type definitions

```
interface SharedValue<Value = unknown> {
  value: Value;
  get(): Value;
  set(value: Value | ((value: Value) => Value)): void;
  addListener: (listenerID: number, listener: (value: Value) => void) => void;
  removeListener: (listenerID: number) => void;
  modify: (
    modifier?: <T extends Value>(value: T) => T,
    forceUpdate?: boolean
  ) => void;
}

function makeMutable<Value>(initial: Value): SharedValue<Value>;
```

#### Arguments

##### `initial`

The value you want to be initially stored in the mutable. It can be any JavaScript value like `number`, `string` or `boolean` but also data structures such as `array` and `object`.

#### Returns

`makeMutable` returns a mutable value initially set to the `initial`.

You can access data stored in the mutable with either its `value` property or `get` and `set` methods.

### Example

### Remarks

info

We use _mutable value_ name for an object created by `makeMutable` to distinguish it from the _shared value_ created by `useSharedValue`. Technically, _shared value_ is a _mutable value_ with an automatic cleanup.

- All remarks from the useSharedValue hook apply to `makeMutable` as well.

- Don't call `makeMutable` directly in the component scope. When component re-renders, it will create the completely new object (with the new `initial` value if it was changed) and the state of the previous mutable value will be lost.

```
function App() {
  const [counter, setCounter] = useState(0);
  const mv = makeMutable(counter); // 🚨 creates a new mutable value on each render

  useEffect(() => {
    const interval = setInterval(() => {
      setCounter((prev) => prev + 1); // updates the counter stored in the component state
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [mv]);

  useAnimatedReaction(
    () => mv.value,
    (value) => {
      console.log(value); // prints 0, 1, 2, ...
    }
  );
}
```

- Use `cancelAnimation` to stop all animations running on the mutable value if it's no longer needed and there are still some animations running. Be super careful with infinite animations, as they will never stop unless you cancel them manually.

```
function App() {
  const mv = useMemo(() => makeMutable(0), []);

  useEffect(() => {
    mv.value = withRepeat(withSpring(100), -1, true); // creates an infinite animation

    return () => {
      cancelAnimation(mv); // ✅ stops the infinite animation on component unmount
    };
  }, []);
}
```

- You don't have to use `cancelAnimation` when the value is not animated. It will be garbage collected automatically when no more references to it exist.

```
const someFlag = makeMutable(false);

function App() {
  someFlag.value = true; // ✅ no need to cancel the animation later on
}
```

- When you decide to use `makeMutable`, ensure that you follow Rules of React and avoid common `useRef` pitfalls, such as modifying the reference during rendering (see the **Pitfall** section in the useRef documentation for more details).

#### Comparison with `useSharedValue`

| `makeMutable` | `useSharedValue` |
| --- | --- |
| Creates a new object on each call | Reuses the same object on each call |
| If `initial` value changes, a new object with the new value is created | If `initialValue` value changes, the initially created object is returned without any changes |
| Can be used outside of the component scope | Can be used only inside the component scope |
| Can be used in loops (also when the number of iterations is not constant) | Can be used in loops only if the number of rendered hooks (`useSharedValue` calls) is constant |
| Doesn't automatically cancel animations when the component is unmounted | Automatically cancels animations when the component is unmounted |

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

##

## Animating styles and props

In the last section, we learned how to make simple animations, what shared values are and how to use them. Now, we'll learn a different way of passing animation styles to components. We'll also go over the difference between animating styles and props and how to handle them using `useAnimatedStyle` and `useAnimatedProps`.

### Animating styles

As we learned in the previous section we can animate styles by passing shared values inline to the elements' `style` property:

```
import Animated, { useSharedValue } from 'react-native-reanimated';

function App() {
  const width = useSharedValue(100);

  return <Animated.View style={{ width }} />;
}
```

In basic cases, this syntax works well but it has one big downside. It doesn't allow to access the value stored in a shared value. For example, it's not possible to build more complex animations by using inline styling to multiply this value (or do any other mathematical operation) before assigning it to the `style` prop.

```
<Animated.View style={{ width: width * 5 }} /> // this won't work
```

Let's suppose we have an example with a box which moves to the right on every button press:

```
import { View, Button } from 'react-native';
import Animated, { useSharedValue, withSpring } from 'react-native-reanimated';

function App() {
  const translateX = useSharedValue(0);

  const handlePress = () => {
    translateX.value = withSpring(translateX.value + 50);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, { transform: [{ translateX }] }]} />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

If we would like to customize how our shared value changes based on some user input, (e.g. multiplying it by 2 or following some other mathematical equation) we couldn't use inline styling.

Luckily, the `useAnimatedStyle` hook comes to the rescue. It adds additional control and flexibility over your animation. This can be really useful when creating a bit more complicated animations which include conditional statements or loops.

Let's see it in action:

Expand the full code

```
export default function App() {
  const translateX = useSharedValue<number>(0);

  const handlePress = () => {
    translateX.value += 50;
  };

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [{ translateX: withSpring(translateX.value * 2) }],
  }));

  return (
    <>
      <Animated.View style={[styles.box, animatedStyles]} />
      <View style={styles.container}>
        <Button onPress={handlePress} title="Click me" />
      </View>
    </>
  );
```

`useAnimatedStyle` lets you access the value stored in a shared value. Thanks to that we could multiply the value by `2` before assigning it to `style`. This hook has one more advantage over passing animations to inline styles. It allows you to keep all the animation-related logic in one place.

You can see it in action in the example below:

### Animating props

Most of the values that developers animate (`width`, `color`, `transform` etc.) are modified by passing them as an object to the `style` property of an element. But that's not always the case.

Sometimes we'd like to animate not just styles but also the props which are passed to the component.

For example, let's say we would like to animate SVG elements. Instead of passing values to the `style` property, values are defined as props:

```
<Circle cx="50" cy="50" r="10" fill="blue" />
```

Reanimated comes with just a handful of built-in components like `Animated.View` or `Animated.ScrollView`. For components which aren't a part of Reanimated, to make their props animatable, we need to wrap them with `createAnimatedComponent`:

```
import Animated from 'react-native-reanimated';
import { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
```

To animate the radius of the SVG circle we can simply pass the shared value as a prop:

```
import { useSharedValue } from 'react-native-reanimated';
import { Svg } from 'react-native-svg';

function App() {
  const r = useSharedValue(10);

  return (
    <Svg>
      <AnimatedCircle cx="50" cy="50" r={r} fill="blue" />
    </Svg>
  );
}
```

This approach works just fine but same as `useAnimatedStyle` for animating styles we can encapsulate the animation logic and gain access to the `.value` property of a shared value by using `useAnimatedProps`.

So if we'd like to smoothly increase the radius of a circle by `10px` on each button press we could use `useAnimatedProps`:

Expand the full code

```
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

export default function App() {
  const r = useSharedValue<number>(20);

  const handlePress = () => {
    r.value += 10;
  };

  const animatedProps = useAnimatedProps(() => ({
    r: withTiming(r.value),
  }));

  return (
    <View style={styles.container}>
      <Svg style={styles.svg}>
        <AnimatedCircle
          cx="50%"
          cy="50%"
          fill="#b58df1"
          animatedProps={animatedProps}
        />
      </Svg>
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

In a function which `useAnimatedProps` takes as an argument, we return an object with all the props we'd like to animate. Then we can pass the value which `useAnimatedProps` returns to the `animatedProps` prop of an Animated component.

Check out the full example below:

### Summary

In this section, we went through the differences between animating styles and props and how to use `useAnimatedStyle` and `useAnimatedProps`. To sum up:

- Passing shared values to inline styles is a simple way of creating animations but it has some limitations.
- Difference between animating `props` and `styles` is that props are not passed to the `style` object, but rather as separate props of the component.
- By using `useAnimatedStyle` and `useAnimatedProps`, you can access the value stored in a shared value. This can add additional control over the animation.
- You can make your own animatable components by wrapping them with `Animated.createAnimatedComponent`.

### What's next?

In the next section, we'll learn more about animation functions and how to customize their behavior.

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## ReducedMotionConfig

`ReducedMotionConfig` component let's you change behavior in response to the device's reduced motion accessibility setting. By default it disables all animation when the reduced motion is enabled on a device. You can adjust it for your specific use case. You can learn more about Accessibility and `useReducedMotion` in Reanimated.

caution

The new configuration will be applied globally across the entire application.

### Reference

```
import { ReducedMotionConfig, ReduceMotion } from 'react-native-reanimated';

function App() {
  return (
    // ...
    <ReducedMotionConfig mode={ReduceMotion.Never} />
    // ...
  );
}
```

Type definitions

```
interface ReducedMotionConfigProps {
  mode: ReduceMotion;
}

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `mode`

A parameter that determines how animations should behave in response to the device's reduce motion accessibility setting.

- `ReduceMotion.System` - This value adjusts the animation behavior based on whether the reduced motion accessibility setting is activated on the device. When enabled, the animation is disabled; otherwise, it remains active.
- `ReduceMotion.Always` - With this setting, the animation is consistently disabled, regardless of the device's accessibility configuration.
- `ReduceMotion.Never` - This option ensures that the animation remains enabled at all times.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
-
-

## Accurate Call Stacks

When debugging Reanimated code, you may encounter error or warning call stacks that don't clearly indicate the root cause of the problem. These stacks can be misleading, as they often highlight code from Reanimated's internals rather than the misuse of the Reanimated API that is the source of the problem.

To address this, Reanimated provides a Metro configuration wrapper called `wrapWithReanimatedMetroConfig`. This wrapper automatically adjusts your Metro config to improve the accuracy of call stacks in warnings and errors generated by the Reanimated library.

How does it work?

By default, React Native displays the entire call stack up to the point where an error is thrown or a warning is logged, including all stack frames except those from the React Native source code.

To modify this behavior, we can use the `symbolicator` field in the Metro config, which allows customization of the displayed stack frames. Reanimated leverages this feature to adjust which stack frames are **hidden** (**collapsed**) in the stack trace. By doing so, stack frames from Reanimated internals are hidden, ensuring that the stack trace only highlights the relevant parts of the call stack.

### Reference

To enable more accurate call stacks, simply import `wrapWithReanimatedMetroConfig` from `react-native-reanimated/metro-config` and wrap your existing Metro configuration in the `metro.config.js` file with it.

```
// metro.config.js
const {
  wrapWithReanimatedMetroConfig,
} = require('react-native-reanimated/metro-config');

const config = {
  // Your existing Metro configuration options
};

module.exports = wrapWithReanimatedMetroConfig(config);
```

### Example

The following example shows the difference in call stacks before and after applying the Reanimated Metro config wrapper. The **Before** image displays Reanimated source code as the error source, while the **After** image shows the actual incorrect code that caused the error.

| Before | After |
| ------ | ----- |
|        |       |

### Remarks

- The `wrapWithReanimatedMetroConfig` doesn't remove any stack frames from the call stack; it only collapses irrelevant frames from Reanimated. If you want to inspect them, you can expand collapsed stack frames by pressing on the **See N more frames** text at the bottom of the **Call Stack**.

| Collapsed | Expanded |
| --------- | -------- |
|           |          |

- Some errors, particularly from asynchronous code, may still result in stack traces pointing to Reanimated internals instead of the exact problematic line in your code. This occurs because stack traces lose track of the original code that initiated the asynchronous operation. In such a case, you'll need to manually debug the issue based on the error message to identify the potential cause of the problem.

## Logger configuration

Reanimated shows warnings that indicate misuses of the library API, such as modifying the shared value during component re-render. These logs can be configured to be more or less verbose.

The **default** logger configuration doesn't require any user setup and displays **all warnings and errors**. If you want to change this behavior, use the `configureReanimatedLogger` function.

### Reference

To modify the default Reanimated logger configuration, import `configureReanimatedLogger` from `react-native-reanimated` and call it with the desired configuration.

```
import {
  configureReanimatedLogger,
  ReanimatedLogLevel,
} from 'react-native-reanimated';

// This is the default configuration
configureReanimatedLogger({
  level: ReanimatedLogLevel.warn,
  strict: true, // Reanimated runs in strict mode by default
});
```

Type definitions

```
function configureReanimatedLogger(config: LoggerConfig): void;

type LoggerConfig = {
  level?: ReanimatedLogLevel;
  strict?: boolean;
};

enum ReanimatedLogLevel {
  warn = 1,
  error = 2,
}
```

#### Configuration options

##### `level`

A value of the `ReanimatedLogLevel` enum that defines the **minimum level** of the logs that will be shown.

##### `strict`

A boolean value that enables or disables **strict** mode. When **strict** mode is enabled, Reanimated will show more warnings that can help you to catch potential issues in your code.

### Remarks

- The logger configuration is global and affects all warnings and errors displayed by Reanimated. There's no option to configure the logger per file/component.

- The `configureReanimatedLogger` function should be called before any Reanimated animations are created, e.g. in the root file of your app.

- The `configureReanimatedLogger` function is intended for application developers. If you are creating a library that relies on Reanimated, don't include this function call in your library source code - users will inherit the configuration which will override the default configuration in the Reanimated library.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

## Guides

###

###

###

###

###

###

###

###

###

###

###

Version: 3.x

## Core

###

###

###

###

###

###

###

Version: 3.x

## Layout Animations

###

###

###

###

###

###

## Worklets

Worklets are short-running JavaScript functions that can run on the UI thread. Reanimated uses worklets to calculate view styles and react to events on the UI thread.

You can create your own worklets using the `'worklet';` directive at the top of a function.

```
function myWorklet() {
  'worklet';
  console.log('Hello from a worklet');
}
```

The Reanimated Babel Plugin looks for functions marked with the `'worklet'` directive and converts them into serializable objects. We call this process workletization. These objects can then be copied and run over on the UI thread.

Most of the time when working with Reanimated and Gesture Handler the code is automatically workletized and run on the UI thread by default.

```
import { useAnimatedStyle } from 'react-native-reanimated';

function App() {
  const style = useAnimatedStyle(() => {
    // Running on the UI thread
    return { opacity: 0.5 };
  });
}
```

Functions marked with `'worklet';` aren't hoisted. Besides affecting hoisting, the `'worklet';` directive has no effect on the JavaScript thread.

You can use `runOnUI` to manually schedule worklet execution on the UI thread:

```
function myWorklet() {
  'worklet';
  console.log('Hello from the UI thread');
}

function onPress() {
  runOnUI(myWorklet)();
}
```

You can pass arguments to worklets.

```
function myWorklet(greeting) {
  'worklet';
  console.log(`${greeting} from the UI thread`);
}

function onPress() {
  runOnUI(myWorklet)('Howdy');
}
```

Worklets are closures. They can access variables declared outside of their own scope. Only variables referenced in the worklet body will be captured inside the worklet scope.

```
const width = 135.5;

function otherWorklet() {
  'worklet';
  console.log('Captured width is', width);
}
```

Capturing large JavaScript objects inside of a worklet can lead to performance issues.

```
const theme = {...}; // theme is a large object

function myWorklet() {
  'worklet';
  console.log(theme.color); // 🚨 referenced `color` but captured the whole `theme` object
}
```

You can get around this problem by first assigning the prop you want to use to a separate variable.

```
const theme = {...};
const color = theme.color;

function myWorklet() {
  'worklet';
  console.log(color); // ✅ captured only `color`
}
```

Worklets can return data within the same thread.

```
function returningWorklet() {
  'worklet';
  return "I'm back"; // on the UI thread
}

function someWorklet() {
  'worklet';
  const what = returningWorklet(); // still on the UI thread
  console.log('On the UI thread, other worklet says', what);
}
```

To pass data between UI and JS thread we use shared values.

```
import { useSharedValue } from 'react-native-reanimated';

function App() {
  const width = useSharedValue(100);

  function myWorklet() {
    'worklet';
    width.value += 50;
  }

  useEffect(() => {
    console.log(width.value); // available on both JS and UI thread
  }, []);
}
```

You can run functions on the JS thread from the UI thread with `runOnJS`. Most frequently used to call functions that aren't marked with a `'worklet';` directive (i.e. most third-party libraries) or to update the React state.

```
import { router } from 'expo-router';
import { Gesture } from 'react-native-gesture-handler';

function App() {
  const tap = Gesture.Tap().onEnd(() => {
    // i'm a worklet too!
    runOnJS(router.back)();
  });
}
```

Functions passed to `runOnJS` must be defined in the JavaScript thread scope, i.e. in the component body or the global scope. This code won't work because `myFunction` is defined in the `withTiming` callback, which is only executed in the UI thread:

```
function App() {
  const tap = Gesture.Tap().onEnd(() => {
    // myFunction is defined on the UI thread 🚨
    const myFunction = () => {};
    runOnJS(myFunction)(); // 💥
  });
}
```

Worklets can run in other runtimes than the one provided by Reanimated. For example VisionCamera and LiveMarkdown create their own worklet runtimes.

You can create your own worklet runtimes with `createWorkletRuntime` function.

## Accessibility

In this section, we will explore how Reanimated provides support for enhanced accessibility in animations, particularly through its reduced motion functionality. This feature ensures a smoother experience for users who may have motion sensitivities or prefer less movement.

The reduced motion configuration can be used to define how animations should respond to the system's reduced motion setting. For a given animation, the value can be set to:

- `ReduceMotion.System` - This value adjusts the animation behavior based on whether the reduced motion accessibility setting is activated on the device. When enabled, the animation is disabled; otherwise, it remains active.
- `ReduceMotion.Always` - With this setting, the animation is consistently disabled, regardless of the device's accessibility configuration.
- `ReduceMotion.Never` - This option ensures that the animation remains enabled at all times.

By default all animations are configured with `ReduceMotion.System`.

### Reduced motion in animations

```
import { withDelay, withTiming } from 'react-native-reanimated';

function App() {
  sv1.value = withTiming(0, { reduceMotion: ReduceMotion.System });
  sv2.value = withDelay(
    1000,
    withTiming(toValue, { duration }),
    ReduceMotion.System
  );
  // ...
}
```

When reduced motion is enabled:

- `withSpring` and `withTiming` return the `toValue` immediately

- `withDecay` returns the current value immediately, taking into account the clamp parameter

- `withDelay` initiates the next animation immediately

- `withRepeat`

  - when the `numberOfReps` is infinite or even and the animation is reversed, then the repeated animation does not start
  - otherwise, the repeated animation runs once

- `withSequence` exclusively starts animations that have reduced motion disabled

Higher-order animations pass the configuration to their children, only if the children have not been configured by the user.

For example, this animation will instantaneously reach the `toValue`:

```
import { withDelay, withTiming } from 'react-native-reanimated';

function App() {
  sv.value = withDelay(
    1000,
    withTiming(toValue, { duration }),
    ReduceMotion.Always
  );
  // ...
}
```

This animation will execute as usual even if reduced motion is enabled on the device:

```
import { withDelay, withTiming } from 'react-native-reanimated';

function App() {
  sv.value = withDelay(
    1000,
    withTiming(toValue, { duration }),
    ReduceMotion.Never
  );
  // ...
}
```

And here `withTiming` will be executed as usual and with no delay:

```
import { withDelay, withTiming } from 'react-native-reanimated';

function App() {
  sv.value = withDelay(
    1000,
    withTiming(toValue, { duration, reduceMotion: ReduceMotion.Never }),
    ReduceMotion.Always
  );
  // ...
}
```

### Reduced motion in Layout Animations

```
import { BounceIn } from 'react-native-reanimated';

function App() {
  const entering = BounceIn.reduceMotion(ReduceMotion.System);
  // ...
}
```

When reduced motion is enabled:

- entering, keyframe, and layout animations instantaneously reach their endpoints.
- exiting animations and shared transitions are omitted.

### `useReducedMotion`

This hook returns a boolean indicating whether the reduced motion setting was enabled when the app started. It can be used in conjunction with other libraries or to conditionally display animations that are less intrusive.

```
import { BounceIn } from 'react-native-reanimated';

function App() {
  const reduceMotion = useReducedMotion();
  const entering = reduceMotion
    ? FadeIn.reduceMotion(ReduceMotion.Never)
    : BounceIn;
  // ...
}
```

## Entering/Exiting animations

Entering/Exiting animations let you animate elements when they are added to or removed from the view hierarchy.

Reanimated comes with a bunch of predefined animations you can customize. For more advanced use-cases, you can use Keyframes or create your own custom entering/exiting animations.

info

Spring-based animations are yet to be introduced to the web. Due to that, playground doesn't cover `springify()` options but they can be applied to your animations on iOS and Android platforms.

### Remarks

- We recommend using layout animation builders outside of components or with `useMemo` to ensure the best performance.

- On the New Architecture:

  - `nativeID` is used internally to configure entering animations, so overwriting it will result in entering animations not running. Some components (e.g. TouchableWithoutFeedback) overwrite `nativeID` of its children. To work around this issue wrap your animated children with a `View`.
  - removing a non-animated view will trigger exiting animations in its children, but the non-animated view will not wait for the children's animations to finish. This is due to view flattening and can be mitigated by using `collapsable={false}`.

### Fade

`FadeX` lets you create a fading animation.

```
import { FadeIn, FadeOut } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={FadeIn} exiting={FadeOut} />;
}
```

Available fade animations:

#### Entering

- `FadeIn`

- `FadeInRight`

- `FadeInLeft`

- `FadeInUp`

- `FadeInDown`

#### Exiting

- `FadeOut`

- `FadeOutRight`

- `FadeOutLeft`

- `FadeOutUp`

- `FadeOutDown`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name           | Config                                           |
| -------------- | ------------------------------------------------ |
| `FadeIn`       | `{opacity: 0}`                                   |
| `FadeInDown`   | `{opacity: 0, transform: [{ translateY: 25 }]}`  |
| `FadeInLeft`   | `{opacity: 0, transform: [{ translateX: -25 }]}` |
| `FadeInRight`  | `{opacity: 0, transform: [{ translateX: 25 }]}`  |
| `FadeInUp`     | `{opacity: 0, transform: [{ translateY: -25 }]}` |
| `FadeOut`      | `{opacity: 1}`                                   |
| `FadeOutDown`  | `{opacity: 1, transform: [{ translateY: 0 }]}`   |
| `FadeOutLeft`  | `{opacity: 1, transform: [{ translateX: 0 }]}`   |
| `FadeOutRight` | `{opacity: 1, transform: [{ translateX: 0 }]}`   |
| `FadeOutUp`    | `{opacity: 1, transform: [{ translateY: 0 }]}`   |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
FadeOutLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
FadeInUp.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
FadeInDown.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ translateY: 420 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Bounce

`BounceX` lets you create a bouncing animation.

```
import { BounceIn, BounceOut } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={BounceIn} exiting={BounceOut} />;
}
```

Available bounce animations:

#### Entering

- `BounceIn`

- `BounceInRight`

- `BounceInLeft`

- `BounceInUp`

- `BounceInDown`

#### Exiting

- `BounceOut`

- `BounceOutRight`

- `BounceOutLeft`

- `BounceOutUp`

- `BounceOutDown`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name             | Config                                                |
| ---------------- | ----------------------------------------------------- |
| `BounceIn`       | `{transform: [{ scale: 0 }]}`                         |
| `BounceInRight`  | `{transform: [{ translateX: values.windowWidth }]}`   |
| `BounceInLeft`   | `{transform: [{ translateX: -values.windowWidth }]}`  |
| `BounceInUp`     | `{transform: [{ translateY: -values.windowHeight }]}` |
| `BounceInDown`   | `{transform: [{ translateY: values.windowHeight}]}`   |
| `BounceOut`      | `{transform: [{ scale: 1 }]}`                         |
| `BounceOutRight` | `{transform: [{ translateX: 0 }]}`                    |
| `BounceOutLeft`  | `{transform: [{ translateX: 0 }]}`                    |
| `BounceOutUp`    | `{transform: [{ translateY: 0 }]}`                    |
| `BounceOutDown`  | `{transform: [{ translateY: 0 }]}`                    |

#### ModifiersOptional

```
BounceInDown.duration(500)
  .delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ translateY: -420 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `600`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Flip

`FlipX` lets you create animation based on rotation over specific axis.

```
import { FlipInEasyX, FlipOutEasyX } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={FlipInEasyX} exiting={FlipOutEasyX} />;
}
```

Available flip animations:

#### Entering

- `FlipInEasyX`

- `FlipInEasyY`

- `FlipInXDown`

- `FlipInXUp`

- `FlipInYLeft`

- `FlipInYRight`

#### Exiting

- `FlipOutEasyX`

- `FlipOutEasyY`

- `FlipOutXDown`

- `FlipOutXUp`

- `FlipOutYLeft`

- `FlipOutYRight`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name | Config |
| --- | --- |
| `FlipInEasyX` | `{transform: [{ perspective: 500 }, { rotateX: '90deg' }]}` |
| `FlipInEasyY` | `{transform: [{ perspective: 500 }, { rotateY: '90deg' }]}` |
| `FlipInXDown` | `{transform: [{ perspective: 500 }, { rotateX: '-90deg' }, { translateY: targetValues.targetHeight }]}` |
| `FlipInXUp` | `{transform: [{ perspective: 500 }, { rotateX: '90deg' }, { translateY: -targetValues.targetHeight }]}` |
| `FlipInYLeft` | `{transform: [{ perspective: 500 }, { rotateY: '-90deg' }, { translateX: -targetValues.targetWidth } ]}` |
| `FlipInYRight` | `{transform: [{ perspective: 500 }, { rotateY: '90deg' }, { translateX: targetValues.targetWidth } ]}` |
| `FlipOutEasyX` | `{transform: [{ perspective: 500 }, { rotateX: '0deg' }]}` |
| `FlipOutEasyY` | `{transform: [{ perspective: 500 }, { rotateY: '0deg' }]}` |
| `FlipOutXDown` | `{transform: [{ perspective: 500 }, { rotateX: '0deg' }, { translateY: 0 }]}` |
| `FlipOutXUp` | `{transform: [{ perspective: 500 }, { rotateX: '0deg' }, { translateY: 0 }]}` |
| `FlipOutYLeft` | `{transform: [{ perspective: 500 }, { rotateY: '0deg' }, { translateX: 0 }]}` |
| `FlipOutYRight` | `{transform: [{ perspective: 500 }, { rotateY: '0deg' }, { translateX: 0 }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
FlipOutYLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
FlipInXUp.springify()
  .damping(2)
  .mass(3)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
FlipInEasyY.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({
    transform: [{ perspective: 100 }, { rotateY: '123deg' }],
  })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### LightSpeed

`LightSpeedX` lets you create an animation of a horizontally moving object with a change of opacity and skew.

```
import { LightSpeedInRight, LightSpeedOutLeft } from 'react-native-reanimated';

function App() {
  return (
    <Animated.View entering={LightSpeedInRight} exiting={LightSpeedOutLeft} />
  );
}
```

Available lightspeed animations:

#### Entering

- `LightSpeedInRight`

- `LightSpeedInLeft`

#### Exiting

- `LightSpeedOutRight`

- `LightSpeedOutLeft`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name | Config |
| --- | --- |
| `LightSpeedInLeft` | `{opacity: 0, transform: [{ translateX: -values.windowWidth }, { skewX: '45deg' }]}` |
| `LightSpeedInRight` | `{opacity: 0, transform: [{ translateX: values.windowWidth }, { skewX: '-45deg' }]}` |
| `LightSpeedOutLeft` | `{opacity: 1, transform: [{ translateX: 0 }, { skewX: '0deg' }]}` |
| `LightSpeedOutRight` | `{opacity: 1, transform: [{ translateX: 0 }, { skewX: '0deg' }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
LightSpeedOutLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
LightSpeedInLeft.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
LightSpeedInRight.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({
    transform: [{ translateX: -100 }, { skewX: '-10deg' }],
  })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Pinwheel

`PinwheelX` lets you create an animation based on rotation, scale, and opacity.

```
import { PinwheelIn, PinwheelOut } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={PinwheelIn} exiting={PinwheelOut} />;
}
```

Available pinwheel animations:

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name          | Config                                                   |
| ------------- | -------------------------------------------------------- |
| `PinwheelIn`  | `{opacity: 0, transform: [{ scale: 0 }, {rotate: '5'}]}` |
| `PinwheelOut` | `{opacity: 1, transform: [{ scale: 1 }, {rotate: '0'}]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
PinwheelOut.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
PinwheelIn.springify()
  .damping(2)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
PinwheelIn.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({
    transform: [{ scale: 0.8 }, { rotate: '3' }],
  })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Roll

`RollX` lets you create an animation of a horizontally moving object with a rotation.

```
import { RollInRight, RollOutLeft } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={RollInRight} exiting={RollOutLeft} />;
}
```

Available roll animations:

#### Entering

- `RollInRight`

- `RollInLeft`

#### Exiting

- `RollOutRight`

- `RollOutLeft`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name | Config |
| --- | --- |
| `RollInLeft` | `{transform: [{ translateX: -values.windowWidth }, { rotate: '-180deg' }]}` |
| `RollInRight` | `{transform: [{ translateX: values.windowWidth }, { rotate: '180deg' }]}` |
| `RollOutLeft` | `{transform: [{ translateX: 0 }, { rotate: '0deg' }]}` |
| `RollOutRight` | `{transform: [{ translateX: 0 }, { rotate: '0deg' }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
RollOutLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
RollInLeft.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
RollInRight.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ translateX: 100 }, { rotate: '-45deg' }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Rotate

`RotateX` lets you create a rotation animation.

```
import { RotateInDownLeft, RotateOutDownLeft } from 'react-native-reanimated';

function App() {
  return (
    <Animated.View entering={RotateInDownLeft} exiting={RotateOutDownLeft} />
  );
}
```

Available rotate animations:

#### Entering

- `RotateInDownLeft`

- `RotateInDownRight`

- `RotateInUpLeft`

- `RotateInUpRight`

#### Exiting

- `RotateOutDownLeft`

- `RotateOutDownRight`

- `RotateOutUpLeft`

- `RotateOutUpRight`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name | Config |
| --- | --- |
| `RotateInDownLeft` | `{opacity: 0, transform: [{ rotate: '-90deg' }, { translateX: values.targetWidth / 2 - values.targetHeight / 2 }, { translateY: -(values.targetWidth / 2 - values.targetHeight / 2) }]}` |
| `RotateInDownRight` | `{opacity: 0, transform: [{ rotate: '90deg' }, { translateX: -(values.targetWidth / 2 - values.targetHeight / 2) }, { translateY: -(values.targetWidth / 2 - values.targetHeight / 2) }]}` |
| `RotateInUpLeft` | `{opacity: 0, transform: [{ rotate: '90deg' }, { translateX: values.targetWidth / 2 - values.targetHeight / 2 }, { translateY: values.targetWidth / 2 - values.targetHeight / 2 }]}` |
| `RotateInUpRight` | `{opacity: 0, transform: [{ rotate: '-90deg' }, { translateX: -(values.targetWidth / 2 - values.targetHeight / 2) }, { translateY: values.targetWidth / 2 - values.targetHeight / 2 }]}` |
| `RotateOutDownLeft` | `{opacity: 1, transform: [{ rotate: '0deg' }, { translateX: 0 }, { translateY: 0 }]}` |
| `RotateOutDownRight` | `{opacity: 1, transform: [{ rotate: '0deg' }, { translateX: 0 }, { translateY: 0 }]}` |
| `RotateOutUpLeft` | `{opacity: 1, transform: [{ rotate: '0deg' }, { translateX: 0 }, { translateY: 0 }]}` |
| `RotateOutUpRight` | `{opacity: 1, transform: [{ rotate: '0deg' }, { translateX: 0 }, { translateY: 0 }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
RotateOutDownRight.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
RotateInUpLeft.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
RotateInDownLeft.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({
    transform: [{ rotate: '-90deg' }, { translateX: 100 }, { translateY: 100 }],
  })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Slide

`SlideX` lets you create an animation of horizontal or vertical moving object.

```
import { SlideInRight, SlideOutLeft } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={SlideInRight} exiting={SlideOutLeft} />;
}
```

Available slide animations:

#### Entering

- `SlideInRight`

- `SlideInLeft`

- `SlideInUp`

- `SlideInDown`

#### Exiting

- `SlideOutRight`

- `SlideOutLeft`

- `SlideOutUp`

- `SlideOutDown`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name            | Config                                                  |
| --------------- | ------------------------------------------------------- |
| `SlideInDown`   | `{originY: values.targetOriginY + values.windowHeight}` |
| `SlideInLeft`   | `{originX: values.targetOriginX - values.windowWidth}`  |
| `SlideInRight`  | `{originX: values.targetOriginX + values.windowWidth}`  |
| `SlideInUp`     | `{originY: -values.windowHeight}`                       |
| `SlideOutDown`  | `{originY: values.currentOriginY}`                      |
| `SlideOutLeft`  | `{originX: values.currentOriginX}`                      |
| `SlideOutRight` | `{originX: values.currentOriginX}`                      |
| `SlideOutUp`    | `{originY: values.currentOriginY}`                      |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
SlideOutLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
SlideInUp.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
SlideInDown.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ translateY: 420 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Stretch

`StretchX` lets you create an animation based on scaling in X or Y axis.

```
import { StretchInX, StretchOutY } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={StretchInX} exiting={StretchOutY} />;
}
```

Available stretch animations:

#### Entering

- `StretchInX`

- `StretchInY`

#### Exiting

- `StretchOutX`

- `StretchOutY`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name          | Config                         |
| ------------- | ------------------------------ |
| `StretchInX`  | `{transform: [{ scaleX: 0 }]}` |
| `StretchInY`  | `{transform: [{ scaleY: 0 }]}` |
| `StretchOutX` | `{transform: [{ scaleX: 1 }]}` |
| `StretchOutY` | `{transform: [{ scaleY: 1 }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
StretchOutX.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
StretchInX.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
StretchInY.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ scaleY: 0.5 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Zoom

`ZoomX` lets you create an animation based on scale.

```
import { ZoomIn, ZoomOut } from 'react-native-reanimated';

function App() {
  return <Animated.View entering={ZoomIn} exiting={ZoomOut} />;
}
```

Available zoom animations:

#### Entering

- `ZoomIn`

- `ZoomInDown`

- `ZoomInEasyDown`

- `ZoomInEasyUp`

- `ZoomInLeft`

- `ZoomInRight`

- `ZoomInRotate`

- `ZoomInUp`

#### Exiting

- `ZoomOut`

- `ZoomOutDown`

- `ZoomOutEasyDown`

- `ZoomOutEasyUp`

- `ZoomOutLeft`

- `ZoomOutRight`

- `ZoomOutRotate`

- `ZoomOutUp`

Initial values

These are the initial values for each animation that can be customized with the `withInitialValues` modifier.

| Name | Config |
| --- | --- |
| `ZoomIn` | `{transform: [{ scale: 0 }]}` |
| `ZoomInDown` | `{transform: [{ translateY: values.windowHeight }, { scale: 0 }]}` |
| `ZoomInEasyDown` | `{transform: [{ translateY: values.targetHeight }, { scale: 0 }]}` |
| `ZoomInEasyUp` | `{transform: [{ translateY: -values.targetHeight }, { scale: 0 }]}` |
| `ZoomInLeft` | `{transform: [{ translateX: -values.windowWidth }, { scale: 0 }]}` |
| `ZoomInRight` | `{transform: [{ translateX: values.windowWidth }, { scale: 0 }]}` |
| `ZoomInRotate` | `{transform: [{ scale: 0 }, { rotate: rotate }]}` |
| `ZoomInUp` | `{transform: [{ translateY: -values.windowHeight }, { scale: 0 }]}` |
| `ZoomOut` | `{transform: [{ scale: 1 }]}` |
| `ZoomOutDown` | `{transform: [{ translateY: 0 }, { scale: 1 }]}` |
| `ZoomOutEasyDown` | `{transform: [{ translateY: 0 }, { scale: 1 }]}` |
| `ZoomOutEasyUp` | `{transform: [{ translateY: 0 }, { scale: 1 }]}` |
| `ZoomOutLeft` | `{transform: [{ translateX: 0 }, { scale: 1 }]}` |
| `ZoomOutRight` | `{transform: [{ translateX: 0 }, { scale: 1 }]}` |
| `ZoomOutRotate` | `{transform: [{ scale: 1 }, { rotate: '0' }]}` |
| `ZoomOutUp` | `{transform: [{ translateY: 0 }, { scale: 1 }]}` |

#### Modifiers

##### Time-basedOptional

Time-based modifiers relay on `withTiming` function.

```
ZoomOutLeft.duration(500).easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

Time-based modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function.

```
ZoomInRotate.springify()
  .damping(30)
  .mass(5)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(0.1);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.stiffness(value: number)` decides how bouncy the spring is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second from which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
ZoomIn.delay(500)
  .randomDelay()
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ scale: 0.5 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(durationMs: number)` is the length of the animation (in milliseconds). Defaults to `300`.
- `.delay(durationMs: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.randomDelay()` randomizes the delay of the animation between `0` and the provided delay. Uses 1000 ms if delay wasn't provided.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

This article provides basic troubleshooting steps for issues that may happen when building React Native apps with Reanimated for Android devices on Windows host machine.

There are many possible errors including, but not limited to:

- `Execution failed for task ':react-native-reanimated:buildCMakeDebug[x86_64]`
- `Execution failed for task ':react-native-reanimated:buildCMakeRelWithDebInfo[arm64-v8a]'`
- `Task :react-native-reanimated:buildCMakeDebug[x86_64] FAILED`
- `C/C++: ninja: error: mkdir(...): No such file or directory`
- `C++ build system [build] failed while executing`
- `Picked up _JAVA_OPTIONS`

## What should you definitely not do?

If you stumble across any of the above errors or similar, please don't disable or downgrade any features or dependencies. Here are some of examples of what **not** to do:

#### ❌ Do not disable New Architecture if it's already enabled

Starting from React Native 0.76, New Architecture is enabled by default. Disabling it manually by changing `newArchEnabled=...` in `gradle.properties` does not fix the problem, it just postpones it as the legacy architecture will be removed in a future release of React Native.

#### ❌ Do not downgrade Android Gradle Plugin

It is not recommended to change the version of Android Gradle Plugin (AGP) by modifying `distributionUrl=...` in `gradle.properties`. You should use the version of AGP used in the official app template. Changing the AGP version will lead to other problems, including version conflicts and unsupported features.

#### ❌ Do not downgrade Reanimated or any other dependency

Downgrading the dependencies increases the technical debt of your project. Newer version of Reanimated contain various bug fixes and are more stable than previous releases. You should always try to use the latest supported version of Reanimated in your app. In fact, you should try upgrading all the dependencies to the latest available rather than downgrading them.

#### ❌ Do not post another "same issue" comment

Before you report an error, search for similar issues on GitHub, Stack Overflow, Google, etc. Instead posting another "same issue" comment which will be marked as spam, just add a reaction under the original issue. This way we know how many developers are affected which lets us prioritize our work.

### What should you do then?

#### ✅ Make sure your environment is set up correctly

First all, make sure that you have followed all instructions in Set Up Your Environment. Run `npx react-native doctor` to see if there are any problems. Make sure to open a new terminal, restart Visual Studio Code or your IDE, or even reboot your computer if changes have been applied.

#### ✅ Use appropriate version of Reanimated

Make sure to use latest supported version of Reanimated, depending on the setup of your app.

**If your app uses Expo SDK**, you must use a specific major and minor version of Reanimated (first and second number). For instance, Expo SDK 52 supports only Reanimated 3.16.x. Make sure to update to the latest available patch version (third number), for instance 3.16.7.

| Expo SDK version | Reanimated version |
| ---------------- | ------------------ |
| `52`             | `~3.16.1`          |
| `51`             | `~3.10.1`          |
| `50`             | `~3.6.2`           |

tip

**If your project uses Expo prebuild or React Native without a framework (e.g. React Native Community CLI)**, you should use a version of Reanimated that is compatible with the version of React Native according to the Compatibility table.

For instance, Reanimated 3.15.x works only with React Native 0.72, 0.73, 0.74 or 0.75 and **is not** compatible with React Native 0.76. If you want to use Reanimated with React Native 0.76, you need to upgrade to at least 3.16.0. It is recommended to use the latest available version (in this case, 3.16.7).

#### ✅ Use appropriate version of CMake

CMake is a build system used to compile the C++ part of Reanimated on your machine. Make sure to use CMake `3.22.1` or newer. CMake version can be customized with `CMAKE_VERSION` environmental variable, e.g. using `set CMAKE_VERSION=3.31.1`. If not set, CMake `3.22.1` is used.

tip

CMake will be installed automatically during app build. You can install a specific version of CMake directly from Android Studio (Tools → SDK Manager → SDK Tools → CMake).

#### ✅ Use appropriate version of Ninja

Ninja is a build system used to compile the C++ part of Reanimated on your machine. Make sure to use Ninja `1.12.0` or newer (current latest is `1.12.1`) as some older versions of Ninja do not handle long paths correctly (see this issue on GitHub).

tip

#### ✅ Use appropriate version of Android NDK

Android NDK (Native Development Kit) is a set of tools used for building the native part of the app. You should use the same version of NDK as used in the official app template.

tip

Android NDK should be installed automatically during app build. You can install a specific version of Android NDK directly from Android Studio (Tools → SDK Manager → SDK Tools → "NDK (Side by side)").

#### ✅ Make sure `_JAVA_OPTIONS` environmental variable is not set

Some developers stated that unsetting `_JAVA_OPTIONS` environmental variable fixes the errors and makes the build pass.

#### ✅ Enable long paths support in Windows registry

See this page for instructions on how to enable support for long paths on Windows.

#### ✅ Make sure that project path doesn't contain any whitespace

The build process may not work properly for paths with space characters. Spaces often appear in usernames, for example `C:\Users\Szczepan Czekan`, or project names, for instance `D:\Mobile Apps\My Awesome Project`. In such case, move the project to another directory that does not contain whitespace.

#### ✅ Make sure that project path is not too long

The build process may not work properly for paths that are too long. Actually, CMake will raise a warning when it comes across a path longer than 240 characters. In such case, move the project or clone the repository again to a location with shorter path, for example `D:\AwesomeProject`.

tip

On Windows, you can mount a specific directory (e.g. `C:\Users\Tomek\AwesomeProject`) as a drive (e.g. `H:`) using the following command: `subst H: C:\Users\Tomek\AwesomeProject`

#### ✅ Remove or invalidate caches

During app build, multiple compilation artifacts are saved in various paths, for instance:

- `android\build`
- `android\.cxx`
- `android\.gradle`
- `android\app\build`
- `android\app\.cxx`
- `node_modules\react-native-reanimated\android\build`
- `node_modules\react-native-reanimated\android\.cxx`
- `C:\Users\Tomek\.gradle\caches`

Make sure to remove these directories and their contents before trying to build the app again.

It is also recommended to invalidate Android Studio caches (File → Invalidate Caches… → Select all checkboxes → Invalidate and Restart).

tip

You can remove all untracked files in your repository using `git clean -fdX` command. Note that this command will remove all untracked files including hidden files like `.env` so please be extra careful and proceed with caution when doing so. You will also need to reinstall `node_modules` afterwards using your chosen package manager and rebuild the app.

#### ⚠️ I have followed all of the above steps and it still doesn't work

If you still have problems with building for Android device on a Windows machine, please submit an issue in our repository. Make sure to provide full build logs and preferably a minimal viable reproducible example so we can replicate and investigate your issue.

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## Compatibility table

#### Currently supported React Native versions (Paper)

|  | 0.63 | 0.64 | 0.65 | 0.66 | 0.67 | 0.68 | 0.69 | 0.70 | 0.71 | 0.72 | 0.73 | 0.74 | 0.75 | 0.76 | 0.77 | 0.78 | 0.79 | 0.80 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 3.18.0 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | yes | yes |
| 3.17.4 - 3.17.5 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | yes | no |
| 3.17.1 – 3.17.3 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no |
| 3.17.0 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | no | no | no |
| 3.16.7 | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no | no |
| 3.16.0 – 3.16.6 | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | no | no | no | no |
| 3.15.x | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no | no | no | no |
| 3.9.x – 3.14.x | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no | no | no | no | no |
| 3.6.x – 3.8.x | no | no | no | yes | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no |
| 3.5.x | no | no | no | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no |
| 3.3.x – 3.4.x | yes | yes | yes | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no |
| 3.0.x – 3.2.x | yes | yes | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no |
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| 2.14.x – 2.17.x | yes | yes | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no |
| 2.11.x – 2.13.x | yes | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no | no |
| 2.10.x | yes | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no | no | no |
| 2.5.x – 2.9.x | yes | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no | no | no | no |
| 2.3.x – 2.4.x | yes | yes | yes | yes | yes | no | no | no | no | no | no | no | no | no | no | no | no | no |

info

Reanimated 2 won't receive support for newest React Native versions. To get the latest React Native features and updates, upgrade to Reanimated 3.

#### Supported React Native versions on the New Architecture (Fabric)

To use Reanimated with the experimental New Architecture, update the package to at least version 3.0.0. Due to the vast number of breaking-changes related to the New Architecture in each React Native version, as a rule of thumb Reanimated supports the latest stable version of React Native.

Reanimated supports the bridgeless mode.

|  | 0.63 | 0.64 | 0.65 | 0.66 | 0.67 | 0.68 | 0.69 | 0.70 | 0.71 | 0.72 | 0.73 | 0.74 | 0.75 | 0.76 | 0.77 | 0.78 | 0.79 | 0.80 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 3.18.0 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | yes | yes |
| 3.17.4 - 3.17.5 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | yes | no |
| 3.17.1 – 3.17.3 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no |
| 3.17.0 | no | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | no | no | no |
| 3.16.7 | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | yes | no | no | no |
| 3.16.0 – 3.16.6 | no | no | no | no | no | no | no | no | no | no | no | yes | yes | yes | no | no | no | no |
| 3.15.x | no | no | no | no | no | no | no | no | no | no | no | yes | yes | no | no | no | no | no |
| 3.9.x – 3.14.x | no | no | no | no | no | no | no | no | no | no | no | yes | no | no | no | no | no | no |
| 3.6.x – 3.8.x | no | no | no | no | no | no | no | no | no | yes | yes | no | no | no | no | no | no | no |
| 3.1.x – 3.5.x | no | no | no | no | no | no | no | no | no | yes | no | no | no | no | no | no | no | no |
| 3.0.x | no | no | no | no | no | no | no | no | yes | no | no | no | no | no | no | no | no | no |

-
-

##

## useSharedValue

`useSharedValue` lets you define shared values in your components.

### Reference

```
import { useSharedValue } from 'react-native-reanimated';

function App() {
  const sv = useSharedValue(100);

  // read a shared value
  console.log(sv.value);

  // and modify it
  sv.value += 50;
}
```

Type definitions

```
interface SharedValue<Value = unknown> {
  value: Value;
  get(): Value;
  set(value: Value | ((value: Value) => Value)): void;
  addListener: (listenerID: number, listener: (value: Value) => void) => void;
  removeListener: (listenerID: number) => void;
  modify: (
    modifier?: <T extends Value>(value: T) => T,
    forceUpdate?: boolean
  ) => void;
}

function useSharedValue<Value>(initialValue: Value): SharedValue<Value>;
```

#### Arguments

##### `initialValue`

The value you want to store initially in the shared value. It can be any JavaScript value like `number`, `string` or `boolean` but also data structures such as `array` and `object`.

#### Returns

`useSharedValue` returns a shared value initially set to the `initialValue`.

You can access data stored in the shared value with either its `value` property or `get` and `set` methods.

##### React Compiler support

When working with the React Compiler, you should refrain from accessing and modifying the `value` property directly. Instead, use the `get` and `set` methods. They're the alternative API for `useSharedValue`, compliant with the React Compiler standards.

```
function App() {
  const sv = useSharedValue(100);

  const animatedStyle = useAnimatedStyle(() => {
    'worklet';
    return { width: sv.get() * 100 };
  });

  const handlePress = () => {
    sv.set((value) => value + 1);
  };
}
```

### Example

### Remarks

- Don't read or modify the value of a shared value during a component's render. Access to `value` property or calling `get`/`set` methods is a side-effect. Triggering side-effects during render violates the Rules of React. All reads from and writes to a shared value should happen in relevant callbacks which aren't executed during render, i.e. in `useAnimatedStyle` or `useEffect` hooks.

- When you change the `sv.value` Reanimated will update the styles and keep the shared value in sync between the threads. However, this won't trigger a typical React re-render because a shared value is a plain JavaScript object.

- When you read the `sv.value` on the JavaScript thread, the thread will get blocked until the value is fetched from the UI thread. In most cases it will be negligible, but if the UI thread is busy or you are reading a value multiple times, the wait time needed to synchronize both threads may significantly increase.

- When you change the `sv.value` the update will happen synchronously on the UI thread. On the other hand, on the JavaScript thread the update is asynchronous. This means when you try to immediately log the `value` after the change it will log the previously stored value.

```
function App() {
  const sv = useSharedValue(100); // initially set 100

  sv.value += 50; // changing value stored in a shared value

  console.log(sv.value); // will still log 100
}
```

- Stay away from destructuring assignment when working with shared values. While this is a completely valid JavaScript code it will make Reanimated unable to keep the reactivity of a shared value.

```
function App() {
  let { value } = sv; // don't do this

  console.log(value); // you can read the value just fine

  value += 50; // but this won't update the styles
}
```

- When storing objects in a shared value, make sure to reassign an object instead of changing the properties individually.

```
function App() {
  const sv = useSharedValue({ x: 0, y: 0 });

  sv.value.x = 50; // Reanimated loses reactivity 🚨

  sv.value = { x: 50, y: 0 }; // ✅
}
```

- When storing large arrays or complex objects in a shared value, you can use `.modify` method to alter the existing value instead of creating a new one.

```
function App() {
  const sv = useSharedValue([1, 2, 3]);

  sv.value.push(1000); // Reanimated loses reactivity 🚨

  sv.value = [...sv.value, 1000]; // works, but creates a new copy ⚠️

  sv.modify((value) => {
    'worklet';
    value.push(1000); // ✅
    return value;
  });
}
```

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Contributing

Thank you for your interest in contributing to Reanimated! From triaging and commenting on issues, through extending the documentation, to reviewing and sending Pull Requests, all contributions are more than welcome.

### Ways to Contribute

1. **Answering and handling open issues** – great way to contribute without writing a single line of code is triaging the issues. We often get issues that have generic errors, occur only in very specific cases, do not have proper example or reproducible repository. One of the ways to help is by preparing and filling the details, which will help other contributors get up to speed with the issue faster.

2. **Helping with documentation** – helping with documentation can be as simple as checking for spelling and grammar. If you encounter situations that can be explained better or in more details, click **Edit this page** at the bottom of most pages to get started with your own contribution. You can also help updating the page structures from old versions, as some of them are still ported from Reanimated v2 docs. Read more about helping with documentation.

3. **Reviewing Pull Requests** – reviewing Pull Requests is crucial as it may help catch corner cases or bugs that the contributor may have missed. Every review matters, as it helps us polish the quality of the library.

4. **Contributing to the Code** – contributions to the source code generally come in the form of Pull Requests. By contributing to the code you help us with solving issues, fixing bugs or introducing new, amazing features. If you want to start your adventure with open source it's good idea to take a look at good first issue on GitHub. Read more about contributing to code here.

#### Repository overview

The React Native Reanimated repository is a monorepo with the following structure:

```
├── apps
│   ├── common-app // shared source code of example apps
│   ├── paper-example // React Native app wrapper running the Old Architecture for shared examples
│   ├── fabric-example // React Native app wrapper running the New Architecture for shared examples
│   ├── macos-example // React Native for MacOS app wrapper for shared example code
│   ├── next-example // Next.js wrapper for shared example code
│   ├── tvos-example // React Native for TVOS app wrapper for shared examples
│   └── web-example // React Native for Web app wrapper for shared examples
└── packages
    ├── docs-reanimated // documentation described further in Helping with documentation
    ├── eslint-plugin-reanimated // source of eslint plugin
    └── react-native-reanimated
        ├── android // source code of Android native implementation
        ├── apple // source code of iOS native implementation
        ├── Common // shared C++ code
        ├── scripts // JavaScript and bash scripts used in the CI pipeline
        ├── src // reanimated source code
        └── plugin // source code of the babel plugin
```

### Handling open issues

Understanding and reproducing the problem can be a very time consuming task. A great way to help other contributors quickly get up to the speed with solving an issue is providing a detailed description and a _reproducible_ example. GitHub already has a template for creating issues, nevertheless we still encounter ones that don't have all the necessary details, like:

- a missing repository that we can clone to quickly see the problem,
- very generic reproduction steps,
- an incomplete or missing description,
- unrelated or truncated stack trace.

To help, you can ask the owner for these missing details or try to provide them yourself. You can try reproducing the issue and filling the description so that other developers can work on solving it right away! 🎉

### Helping with documentation

One of the many ways you can contribute to this project is by improving the documentation. We try to keep it up to date, but there is still plenty of room for improvement. It is also important to update the docs whenever you introduce changes to the API or you discover any inconsistencies in the current API or behaviour. This is one of the most straightforward ways to contribute. Some of the pages are still in old, v2 format and you can help us convert them to the Reanimated 3 structure.

The Reanimated documentation uses Docusaurus and is hosted on GitHub Pages. The easiest way to start adding your changes is by clicking **Edit this page** located at the bottom of most pages.

#### Editing source locally

If you want to contribute more complicated changes, it's a good idea to edit them locally. That way you can run the changes on your setup to make sure everything looks as expected. To get started, follow the steps below:

1. Read How to Open a Pull Request
2. Clone react-native-reanimated
3. `cd react-native-reanimated`
4. `yarn`
5. `cd packages/docs-reanimated`
6. `yarn && yarn start`

This will start your local Docusaurus server running the documentation.

#### Project structure

Here you can find the most important parts of the `react-native-reanimated/packages/docs-reanimated` project. Not all folders are listed for brevity.

```
├── docs // contains folder with md/mdx files, each folder is a section in the side navigation, and each file is documentation page
├── src
│   ├── components // contains components used to make the pages interactive
│   └── examples // contains examples that are later presented in the documentation
└── static
    ├── img // contains images used in the docs
    └── recordings // contains video recordings of the examples
```

#### Documentation page structure

It's important to maintain a consistent structure for the site, as this helps developers navigate easily and quickly find what they are looking for. In v3 documentation, we follow this page structure:

1. **Introduction** – short introduction what given feature does.
2. **Reference** – simplest possible usage showcase and type definitions, make sure that example code runs when someone copies it to quickly prototype.
3. **Arguments** – details about the arguments that given method accepts.
4. **Returns** – details of returned values.
5. **Example** – video, gif or interactive demo with source code. It is good practice to provide resources in both light and dark mode.
6. **Remarks** – make sure to highlight everything that might not be obvious i.e. platform specific quirks, compatibility issues, additional setups required.
7. **Platform compatibility** – information about platforms that given feature supports.

The structure may vary depending on the given feature. If the one above doesn't seem to be a good fit for you, try to find a similar feature and see how it is documented.

#### Documentation writing style guide

Developers want to find the solutions to their problems as fast as possible. To address this, we optimize our documentation for skimming. We believe that improvements to documentation have a direct impact on the overall developer experience. This section outlines some best practices for writing technical documentation. Treat these guidelines as recommendations rather than absolute rules.

If you can spare 2 hours, we highly recommend taking a free Technical Writing One course by Google.

###### Avoid passive voice

Most sentences in technical documentation should use active voice. Sentences in active voice are usually simpler than those in passive voice.

See the following examples:

- The arguments **are provided to** the function.
- A worklet **is generated by** the babel plugin.
- UI thread **is being used by** Reanimated.

which if we rewrite these sentences to active voice become simpler:

- The function **receives** the arguments.
- The babel plugin **generates** a worklet.
- Reanimated **runs** on the UI thread.

###### Prefer short, clear sentences

When it comes to technical documentation, simplicity is key. Prefer writing short and simple sentences.

Oftentimes you can split long sentences into shorter ones by repeating the sentence subject.

Keep in mind that many readers aren't native English speakers.

###### Split paragraphs into organized lists

People tend to skip over long paragraphs of text. Organized lists are usually easier to read. They help developers get the information they are looking for faster.

Remember to introduce the list first.

```
The Reanimated installation steps:

- Add Reanimated package form npm
- Add babel plugin to babel.config.js
- Reset cache
```

###### Avoid acronyms and abbreviations

Acronyms can often lead to confusion.

For example, in the context of libraries, abbreviations like `REA`, `RNGH`, `RNS`, may be obvious to developers proficient in the React Native open source space, but completely unknown to beginners.

Some acronyms, such as RN, can mean both React Native and React Navigation.

When explaining topics that often use domain-specific acronyms, such as `JSI`, `JNI`, `JSC`, you should first introduce them. For example, JavaScript Core (JSC) or JavaScript Interface (JSI).

The following rule doesn't apply to globally established abbreviations like `UI`, `API`, `HTML`, `TS` etc.

##### Use contractions

Prefer writing using contractions like `don't`, `doesn't`, `it's` instead of full forms like `do not`, `does not`, `it is`.

#### Embedding interactive examples

We try to make the code examples as easy as possible. This is why good, interactive examples are crucial. To create interactive examples in the documentation you can use `InteractiveExample` component. It takes `src` prop that expects source of a component that you can declare in `src/examples`, and a `component` prop that showcases given code.

##### Example with a video

```
import AnimatedKeyboardSrc from '!!raw-loader!@site/src/examples/AnimatedKeyboard';

<InteractiveExample
  src={AnimatedKeyboardSrc}
  component={
    <ThemedVideo
      center
      width={300}
      sources={{
        light: '/recordings/useAnimatedKeyboard_light.mov',
        dark: '/recordings/useAnimatedKeyboard_dark.mov',
      }}
    />
  }
/>;
```

##### Example with an interactive component

```
import DecayTrain from '@site/src/examples/DecayTrain';
import DecayTrainSrc from '!!raw-loader!@site/src/examples/DecayTrain';

<InteractiveExample
  src={DecayTrainSrc}
  component={<DecayTrain />}
  label="Grab and drag the train"
/>;
```

### Contributing to the Code

Posting Pull Requests to the issues is a great way to contribute to Reanimated. If you are eager to start contributing right away, we have a list of good first issues that contain bugs which have limited scope. In this section we'll describe how to play around with Reanimated setup in more detail.

caution

We have shared code of example app, that is run on different platforms and architectures. When working on an issue the most important destinations will be:

- `apps/common-app` – shared source code with example app
- `packages/react-native-reanimated/src/reanimated2` – containing source code related to JS part of Reanimated features
- `packages/react-native-reanimated/android/src/main/java/com/swmansion/reanimated` – containing source code related to Android native part of Reanimated features
- `packages/react-native-reanimated/apple` – containing source code related to iOS native part of Reanimated features

Our workflow usually starts from editing `apps/common-app/src/examples/EmptyExample.tsx` with testing example for our new feature or a bug. This is the part that we often attach to PR so other developers can test the same use-case (remember not to commit your changes from `EmptyExample` file!). Next, we run the `apps/paper-example` (or `apps/fabric-example` depending on the architecture) app and start development.

info

If you want to implement a new feature or fix a bug, but still are unsure after reading through this section or could use some guidance, you can reach out to the Reanimated Team on Discord.

#### Working with Android

To start with, let's install all dependencies:

1. `yarn && yarn build`
2. `cd apps/paper-example`
3. `yarn start` – make sure to start metro bundler before building the app in Android Studio.

and open `react-native-reanimated/apps/paper-example/android` with Android Studio.

The native source code of Reanimated can be found in `react-native-reanimated` module, in `/packages/react-native-reanimated/android/src/main/java/com/swmansion/reanimated`. Make sure the Metro bundler is running. You can now build React Native app or debug native code.

#### Working with iOS

To begin with, let's install all the necessary dependencies:

1. `yarn && yarn build`
2. `(cd apps/paper-example/ios && bundle install && bundle exec pod install)` – install Pods for iOS
3. `cd apps/paper-example && yarn start` – make sure to start metro bundler before building the app in Xcode.

and open `react-native-reanimated/apps/paper-example/ios/ReanimatedExample.xcworkspace` with Xcode.

To find the native source code of Reanimated navigate to `Pods > Development Pods > RNReanimated > Example > ... > ... > node_modules > react-native-reanimated > apple`. Make sure the Metro bundler is running. You can now build React Native app or debug native code.

#### Preparing a Pull Request

When the code changes are ready, it's time to open a Pull Request. We configured the repository to come with a template to help you post your changes properly. The most important of these are:

1. **Summary**:

- If you're solving a specific issue, start by linking it, for example: Fixes #2137 (here goes a full link to an issue and GitHub shortens it into a #number format).
- Write what are your motivations and how you solved the problem.
- If applicable, it's a good idea to include a screenshot or a video of before and after making changes.

2. **Test plan** – Describe how others can test your changes, here we usually attach the code from your modified `EmptyExample`, that you used for testing.

#### Testing changes in your project

If you want to test changes in your own project, the best way is to create a patch using `git diff` or by pointing to a specific commit in `package.json`.

See you on GitHub! 🎉

## Layout transitions

Layout transitions allows you to replace layout changes with smooth transitions. Each layout change may include changes of size and position and both of them can be animated.

### Predefined Transitions

Below we listed all of the currently available predefined layout transitions with their layout animation modifiers.

### Linear transition

Linear transition animates both position and dimension in the same way.

#### Reference

```
import { LinearTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={LinearTransition} />;
}
```

#### Modifiers

##### EasingOptional

Easing modifiers are time-based modifiers that relay on `withTiming` function.

```
LinearTransition.easing(Easing.ease);
```

- `.easing(easingFunction: EasingFunction)` is an easing function which defines the animation curve. Defaults to `Easing.inOut(Easing.quad)`

note

The `.easing(...)` modifiers have no effect when `.springify()` is used.

##### Spring-basedOptional

Spring-based modifiers relay on `withSpring` function. Just as in `withSpring` config, spring-based modifiers can be physics-based (have `mass` and `damping` modifiers) or duration-based (have `duration` and `dampingRatio` modifiers).

info

The `mass` and `damping` (physics-based) properties can't be used at the same time as `duration` and `dampingRatio` (duration-based).

When used together `duration` and `dampingRatio` overrides `mass` and `damping` props.

```
LinearTransition.springify()
  .damping(30)
  .mass(5)
  .rotate(20)
  .stiffness(10)
  .overshootClamping(false)
  .restDisplacementThreshold(0.1)
  .restSpeedThreshold(5);
```

- `.springify()` enables the spring-based animation configuration.
- `.damping(value: number)` decides how quickly a spring stops moving. Higher damping means the spring will come to rest faster. Defaults to `10`.
- `.dampingRatio(value: number)` decides how damped the spring is. Value `1` means the spring is critically damped, and value `>1` means the spring is overdamped. Defaults to `0.5`.
- `.mass(value: number)` is the weight of the spring. Reducing this value makes the animation faster. Defaults to `1`.
- `.rotate(degree: string)` lets you rotate the element.
- `.stiffness(value: number)` decides how bouncy the spring is - the higher the number, the less bouncy it is. Defaults to `100`.
- `.overshootClamping(value: boolean)` decides whether a spring can bounce over the designated position. Defaults to `false`.
- `.restDisplacementThreshold(value: number)` is the displacement below which the spring will snap to the designated position without further oscillations. Defaults to `0.001`.
- `.restSpeedThreshold(value: number)` is the speed in pixels per second below which the spring will snap to the designated position without further oscillations. Defaults to `2`.

##### CommonOptional

```
LinearTransition.delay(500)
  .reduceMotion(ReduceMotion.Never)
  .withInitialValues({ transform: [{ translateY: 420 }] })
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Defaults to '300'.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withInitialValues(values: StyleProps)` allows to override the initial config of the animation.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Remarks

- The animation will end if **both** the animation speed is below `restSpeedThreshold` and the distance to its end is less than `restDisplacementThreshold`. Keep in mind that if you haven't set one of the thresholds, its value will be set to the default.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Sequenced Transition

Sequenced transition animates x-position and width first, then y-position and height.

#### Reference

```
import { SequencedTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={SequencedTransition} />;
}
```

#### Modifiers

```
SequencedTransition.duration(1000)
  .delay(500)
  .reverse()
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Defaults to '500'.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reverse()` determines if the animation should run in reverse. Defaults to `false`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Fading Transition

Fading transition animates the opacity of component. It will disappear while having previous position and dimensions and appear with new ones.

#### Reference

```
import { FadingTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={FadingTransition} />;
}
```

#### Modifiers

```
FadingTransition.duration(1000)
  .delay(500)
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Defaults to '500'.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Jumping Transition

Jumping transition makes components "jump" to the new position.

#### Reference

```
import { JumpingTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={JumpingTransition} />;
}
```

#### Modifiers

```
JumpingTransition.duration(1000)
  .delay(500)
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Defaults to '300'.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Curved Transition

Curved transition enables animation of all parameters (`X`, `Y`, `width`, `height`) with different easing each. It makes component movement path look curved.

#### Reference

```
import { CurvedTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={CurvedTransition} />;
}
```

#### Modifiers

```
CurvedTransition.duration(1000)
  .delay(500)
  .easingX(Easing.in(Easing.exp))
  .easingY(Easing.out(Easing.quad))
  .easingWidth(Easing.in(Easing.ease))
  .easingHeight(Easing.out(Easing.exp))
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Defaults to '300'.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.easingX(easing: EasingFunction)` defines easing animation for x-position.
- `.easingY(easing: EasingFunction)` defines easing animation for y-position.
- `.easingWidth(easing: EasingFunction)` defines easing animation for width.
- `.easingHeight(easing: EasingFunction)` defines easing animation for height.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Remarks

- Length of the duration is shared for all of the easings.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Entry/Exit Transition

Entry/Exit transition lets you choose layout animations for entering and exiting. It combines both of them into a one and applies to the layout. Moreover, instead of picking currently available animations, you are welcome to create your own one.

#### Reference

```
import { EntryExitTransition } from 'react-native-reanimated';

function App() {
  return <Animated.View layout={EntryExitTransition} />;
}
```

#### Modifiers

```
EntryExitTransition.duration(1000)
  .delay(500)
  .entering(FlipInEasyX)
  .exiting(FlipOutEasyY)
  .reduceMotion(ReduceMotion.Never)
  .withCallback((finished) => {
    console.log(`finished without interruptions: ${finished}`);
  });
```

- `.duration(duration: number)` sets length of the animation (in milliseconds). Default depends on entry/exit animation.
- `.delay(duration: number)` is the delay before the animation starts (in milliseconds). Defaults to `0`.
- `.exiting(animation)` determines animation shown when element is removed from position. Defaults to `FadeOut`.
- `.entering(animation)` determines animation shown when element is added to new position. Defaults to `FadeIn`.
- `.reduceMotion(reduceMotion: ReduceMotion)` determines how the animation responds to the device's reduced motion accessibility setting.
- `.withCallback(callback: (finished: boolean) => void)` is the callback that will fire after the animation ends. Sets `finished` to `true` when animation ends without interruptions, and `false` otherwise.

#### Remarks

- Duration equals sum of entering and exiting durations.

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Debugging worklets

info

This page was ported from an old version of the documentation.

As we're rewriting the documentation some of the pages might be a little outdated.

If you'd like to help with transition you can find guidelines in contributing guide.

Due to Reanimated's unique architecture and usage of a second JS runtime, debugging can be problematic, and some common solutions might not work as expected. This article summarizes all the available methods and highlights their caveats.

info

Reanimated v1 works with all the common React Native debugging tools. This article focuses on the use of these tools with Reanimated v2.

#### React Native debugging tools

These are the debugging tools we checked for compatibility with React Native apps using the Reanimated library:

- **Chrome debugger** (also known as the _React Native Debugger_) is a simple tool that creates a web worker inside your preferred browser which executes your app's JavaScript code. It works with all the runtimes available in React Native.

- **Chrome DevTools** (unavailable for JSC) is Chrome's built-in feature that allows for connecting to a remote JavaScript runtime. This means that the code you are debugging actually runs on the device itself and behaves the same way as it would with DevTools detached.

- **Flipper** (Hermes debugger) is an app created by Facebook that makes it easy to use the _Chrome DevTools_ while providing additional tools for UI inspection and debugging.

- **Safari DevTools** is Safari's built-in feature that is only available for iOS devices running JSC. It works very similarly to Chrome DevTools - it allows you to connect to a remote runtime and keep code execution on device.

- **React Developer Tools** are a standalone app that allows debugging UI through the inspector, as well as monitoring performance and profiling your app.

#### The JS context vs. the UI context

It is important to understand the differences between the JS and UI contexts. One thing to note is that adding Reanimated changes nothing when it comes to debugging the regular JS context that is available in all React Native apps. It is only debugging the UI context, which is specific to the Reanimated library that might be difficult to debug in some scenarios, which are all explained in this article.

#### Debugging web apps

For debugging web apps, you may use the tools you prefer or any that are provided by the browser of your choice. We did not discover any issues with debugging apps using Reanimated on web.

#### Summary

| Tool | Platform | JSC     | Hermes  | V8      |
| ---- | -------- | ------- | ------- | ------- |
|      | Android  | ⚛️ ✅ ¹ | ⚛️ ✅ ¹ | ⚛️ ✅ ¹ |
|      | iOS      | ⚛️ ✅ ¹ | ⚛️ ✅ ¹ | N/A     |
|      | Android  | N/A     | ⚛️ ✅ ² | ⚛️      |
|      | iOS      | N/A     | ⚛️ ✅ ² | N/A     |
|      | Android  | N/A     | ⚛️ ✅ ² | ⚛️      |
|      | iOS      | N/A     | ⚛️ ✅ ² | N/A     |
|      | Android  | N/A     | N/A     | N/A     |
|      | iOS      | ⚛️ ✅   | N/A     | N/A     |
|      | Android  | ⚛️      | ⚛️      | ⚛️      |
|      | iOS      | ⚛️      | ⚛️      | N/A     |

¹ - Works, but uses web implementations of functions and runs worklets on the JS thread. This means that measure and Layout Animations will not be available.\
² - Experimental feature (see description).

##### Legend:

- ⚛️ ✅ - special features for React Native apps using Reanimated
- ⚛️ - works the same as with all React Native apps, debugging worklets is not available
- N/A - unavailable in React Native apps

caution

Remember that console logs will always appear in the primary JS runtime as the `console.log` function on the UI runtime is just a wrapper around the one from the JS runtime.

#### Chrome Debugger

| Platform | JSC   | Hermes | V8    |
| -------- | ----- | ------ | ----- |
| Android  | ⚛️ ✅ | ⚛️ ✅  | ⚛️ ✅ |
| iOS      | ⚛️ ✅ | ⚛️ ✅  | N/A   |

**Summary:** Works, but uses web implementations of functions and runs everything on the JS thread.

Since the Chrome Debugger runs its own web worker, all the code is run on the JS thread, and it uses the JavaScript engine provided by your web browser (V8 in Chrome, JSC in Safari and SpiderMonkey in Firefox). This means that this piece of code:

```
function runWorklet() {
  'worklet';
  console.log('worklet:', _WORKLET);
}
runOnUI(runWorklet)();
```

would output:

```
LOG: worklet: false
```

Another side effect is that Reanimated uses web implementations of all functions. This means that the `scrollTo` function will work (using the native web implementation), but the `measure` function will not be available, and its usage will trigger this error:

```
[Reanimated] measure() cannot be used with Chrome Debugger.
```

You may still use the standard web version of `measure` as described here.

Those functions that are provided by Reanimated and do not have web implementations won't work at all. An example of this behavior is the `useAnimatedSensor` hook, which currently only works on mobile platforms. When debugging in Chrome and using this hook, the following message will appear in the logs:

```
[Reanimated] useAnimatedSensor is not available on web yet.
```

But despite all of this, it is still possible to set breakpoints both in normal JS code and in worklets (since they run on the main JS thread now).

#### Chrome DevTools

| Platform | JSC | Hermes | V8  |
| -------- | --- | ------ | --- |
| Android  | N/A | ⚛️ ✅  | ⚛️  |
| iOS      | N/A | ⚛️ ✅  | N/A |

**Summary:** Works and both contexts can be debugged.

warning

This is an early experimental feature.

Worklet debugging is now available in Reanimated apps as an early experimental feature. We do not recommend using Chrome DevTools to debug the UI context, but instead try using the Flipper tool. It has fewer bugs and provides a much better experience.

If you still want to use Chrome DevTools then follow these steps:

1. Add the `patch-package` to your project and set it up to run as a `post-install` task. More details can be found here.

2. Add the necessary patch for `metro-inspector-proxy` to the `patches/` folder:

- `0.76.7` → here
- `0.76.5` → here
- `0.76.4` → here
- `0.76.0` → here
- `0.73.7` → here
- `0.73.5` → here
- `0.72.3` → here
- `0.72.1` → here

_Warnings about mismatched patch versions can be safely ignored if the patch was successfully applied._

3. Open chrome://inspect in a Google Chrome browser.

4. Select the Reanimated runtime from the list. The list should look something like this:

You may choose either `Reanimated Runtime` or `Reanimated Runtime experimental (Improved Chrome Reloads)`, but we recommend the latter.

_Debugging relies on source maps that are generated by the Reanimated Babel plugin, so you might have to run `yarn start --reset-cache` for those changes to take effect. In case it still doesn't work after that please reinstall the app and reset metro cache once again._

caution

Known issues include:

- Reloads don't work - if a debugger is connected to the Reanimated runtime while the reload is performed, the app will crash (both on Android and iOS)

- On iOS, a breakpoint can't be set in a line where a breakpoint was previously set and then removed

- On iOS, breakpoint labels are not visible

- The profiler does not work (it is not possible to stop the recording) - this is an issue with Hermes and is not related to Reanimated and has been already fixed in this PR

- The console is unresponsive if there are no animations running (this will be fixed in the near future)

These issues **do not** affect release builds as well as debug builds where the debugger connection is closed while performing a reload or the debugger is not used at all.

_We are actively working on improving the debugging experience with Chrome DevTools on Hermes._

#### Flipper (Hermes debugger)

| Platform | JSC | Hermes | V8  |
| -------- | --- | ------ | --- |
| Android  | N/A | ⚛️ ✅  | ⚛️  |
| iOS      | N/A | ⚛️ ✅  | N/A |

**Summary:** Works and both contexts can be debugged.

warning

This is an early experimental feature.

Worklet debugging is now available in Reanimated apps as an early experimental feature. If you want to try it out follow these steps:

1. Add the `patch-package` to your project and set it up to run as a `post-install` task. More details can be found here;

2. Add the necessary patches to the `patches/` folder:

- this patch for `metro-inspector-proxy`,
- this one for `react-native-gesture-handler` (not necessary for `react-native-gesture-handler` 2.7.0 or newer).

_Warnings about mismatched patch versions can be safely ignored if the patch was successfully applied._

3. Install the `reanimated` plugin in Flipper.

4) Select the plugin from the side menu (it might be disabled) and you should be good to go!

_Debugging relies on source maps that are generated by the Reanimated Babel plugin, so you might have to run `yarn start --reset-cache` for those changes to take effect. In case it still doesn't work after that please reinstall the app and reset metro cache once again._

caution

Known issues include:

- Reloads don't work - if a debugger is connected to the Reanimated runtime while the reload is performed, the app will crash (both on Android and iOS)

- Breakpoints might not be active after a reload even though they look as if they were

- Android app crashes after the Flipper client is closed and will crash on startup after that. This is a known Flipper issue (link) and is not related to Reanimated.

- The profiler does not work (it is not possible to stop the recording) - this is an issue with Hermes and is not related to Reanimated and has been already fixed in this PR

- The console is unresponsive if there are no animations running (this will be fixed in the near future)

These issues **do not** affect release builds as well as debug builds where the debugger connection is closed while performing a reload or the debugger is not used at all.

_We are actively working on improving the debugging experience with Flipper on Hermes._

#### Safari DevTools

| Platform | JSC   | Hermes | V8  |
| -------- | ----- | ------ | --- |
| Android  | N/A   | N/A    | N/A |
| iOS      | ⚛️ ✅ | N/A    | N/A |

**Summary:** Safari DevTools is only available on iOS devices running the JSC engine. Worklet debugging is available.

After opening Safari and configuring it as specified in the React Native docs, under `Develop > Device` you'll see two JSC contexts like in the screenshot below:

The order of the contexts is random, but one of them will be the main JS context. All `console.log` outputs will appear in the console of this context. You can also set breakpoints here, but unfortunately the only source file visible is the transformed `indexjs.bundle` which does make things more difficult to find.

The other option will be the UI context. No console logs will appear in the console of this context, but all worklet functions should be visible as separate files. It is also possible to set breakpoints in these worklets.

#### React Developer Tools

| Platform | JSC | Hermes | V8  |
| -------- | --- | ------ | --- |
| Android  | ⚛️  | ⚛️     | ⚛️  |
| iOS      | ⚛️  | ⚛️     | N/A |

**Summary:** React Developer Tools work as expected, and the profiler and layout inspector can be used as usual.

On Android, remember to first run the command:

```
adb reverse tcp:8097 tcp:8097
```

We wanted to make it possible to migrate from Reanimated 1 to Reanimated 2 incrementally. When installing Reanimated 2, you will be able to use the old API as well as the new one. We made the latest stable Reanimated 1 available from the same package with a few exceptions, as we needed to address some naming collisions. Whenever there was a naming collision with Reanimated 1, we'd rename the Reanimated 1 version of such method in order to keep the naming in Reanimated 2 cleaner. This strategy made the most sense to us, as we are planning to slowly phase out the old API (we will keep making fixes to Reanimated 1 core but most likely stop new feature development). Unfortunately, it means that Reanimated 2 introduces some breaking changes to the API, where some methods pulled from Reanimated 1 changed their name. Thankfully the list of the renamed methods is relatively short, and the renamed methods weren't too frequently used anyways.

## Renamed methods:

##### 1. `interpolate` renamed to `interpolateNode`

When using `interpolate` imported directly from `react-native-reanimated` v1, in v2 you should use `interpolateNode` instead. If you were using a class member method `AnimatedValue.interpolate`, no change is necessary.

##### 2. `Easing` renamed to `EasingNode`

When using `Easing` imported from `react-native-reanimated` v1, in v2 you should use `EasingNode` instead.

## Getting started

The goal of the _Fundamentals_ section is to help you gain a strong foundation on the core concepts of Reanimated and give you the confidence to explore more advanced use cases on your own. This section is packed with interactive examples, code snippets and explanations. Are you ready? Let's dive in!

### What is React Native Reanimated?

React Native Reanimated is a powerful animation library built by Software Mansion.

With Reanimated, you can easily create smooth animations and interactions that run on the UI thread.

### Quick start

If you don't have an existing project, you can create a new Expo app using a template:

- NPM
- YARN

npx create-expo-app\@latest my-app -e with-reanimated

yarn create expo-app my-app -e with-reanimated

Alternatively, you can dive into our examples on GitHub.

### Installation

It takes three steps to add Reanimated to a project:

#### Step 1: Install the package

Install `react-native-reanimated` package from npm:

- EXPO
- NPM
- YARN

npx expo install react-native-reanimated

npm install react-native-reanimated

yarn add react-native-reanimated

#### Step 2: Add Reanimated's babel plugin

Add `react-native-reanimated/plugin` plugin to your `babel.config.js`.

```
  module.exports = {
    presets: [
      ... // don't add it here :)
    ],
    plugins: [
      ...
      'react-native-reanimated/plugin',
    ],
  };
```

caution

`react-native-reanimated/plugin` has to be listed last.

Why do I need this?

In short, the Reanimated babel plugin automatically converts special JavaScript functions (called worklets) to allow them to be passed and run on the UI thread.

To learn more about the plugin head onto to Reanimated babel plugin section.

#### Step 3: Wrap metro config with reanimated wrapper (recommended)

Wrap your existing Metro configuration in the `metro.config.js` file with the `wrapWithReanimatedMetroConfig` function.

```
// metro.config.js
const {
  wrapWithReanimatedMetroConfig,
} = require('react-native-reanimated/metro-config');

const config = {
  // Your existing Metro configuration options
};

module.exports = wrapWithReanimatedMetroConfig(config);
```

Why should I do this?

Wrapping your Metro configuration with the Reanimated Metro config wrapper will result in displaying improved reanimated errors and warnings with more accurate call stacks. Thanks to this, identifying misuses of the Reanimated API will be much easier than before.

To learn more about this feature, head onto to Accurate Call Stacks.

#### Step 4: Clear Metro bundler cache (recommended)

- EXPO
- NPM
- YARN

npx expo start -c

npm start -- --reset-cache

yarn start --reset-cache

#### Expo development build

When using an Expo development build, run prebuild to update the native code in the `ios` and `android` directories.

```
npx expo prebuild
```

#### Platform specific setup

##### Android

No additional steps are necessary.

##### iOS

While developing for iOS, make sure to install pods first before running the app:

```
cd ios && pod install && cd ..
```

##### Web

For building apps that target web using react-native-web we highly recommend to use Expo.

To use Reanimated on the web all you need to do is to install and add `@babel/plugin-proposal-export-namespace-from` Babel plugin to your `babel.config.js`.

- EXPO
- NPM
- YARN

npx expo install @babel/plugin-proposal-export-namespace-from

npm install @babel/plugin-proposal-export-namespace-from

yarn add @babel/plugin-proposal-export-namespace-from

```
  module.exports = {
      presets: [
        ... // don't add it here :)
      ],
      plugins: [
          ...
          '@babel/plugin-proposal-export-namespace-from',
          'react-native-reanimated/plugin',
      ],
  };
```

Make sure to list `react-native-reanimated/plugin` last.

More advanced use cases such as running Reanimated with `webpack` or with `Next.js` are explained in a separate Web Support guide.

Reanimated 3.x doesn't introduce any breaking changes between 2.x and 3.x in terms of the API. All the code you've written in Reanimated v2 API works in 3.x without any changes. However, Reanimated 3.x drops the Reanimated v1 API entirely. For the migration guide between 1.x and 2.x versions please consult Migration from 1.x to 2.x.

Version: 3.x

## Animations

###

###

###

###

###

###

###

## Testing with Jest

Reanimated provides testing API, based on Jest. It allows user to mock web-based animations.

### Reference

```
test('reference', () => {
  // some styles

  const { getByTestId } = render(<AnimatedComponent />);
  const view = getByTestId('view');
  const button = getByTestId('button');

  expect(view).toHaveAnimatedStyle(style);

  fireEvent.press(button);
  jest.advanceTimersByTime(250); // if whole animation duration is a 500ms

  style.width = 50; // value of component width after 250ms of animation
  expect(view).toHaveAnimatedStyle(style);
});
```

### Setup

Add the following line to your `jest-setup.js` file:

```
require('react-native-reanimated').setUpTests();
```

- `setUpTests()` can take optional config argument. Default config is `{ fps: 60 }`.

To be sure, check if your `jest.config.js` file contains:

```
...
preset: 'react-native',
setupFilesAfterEnv: ['./jest-setup.js'],
...
```

caution

If you use Jest in a version **older than 28**, you should set `setupFiles` property instead of `setupFilesAfterEnv`

### API

#### Style checker

##### `expect(component).toHaveAnimatedStyle(expectedStyle)`

Checking equality of selected styles with current component styles.

- `component` - tested component.
- `expectedStyle` - contains expected styles of testing component, for example `{ width: 100 }`.

##### `expect(component).toHaveAnimatedStyle(expectedStyle, {exact: true})`

Checking equality of all current component styles with expected styles.

##### `expect(component).toHaveAnimatedProps(expectedProps)`Available from 3.17.2

Checking equality of selected props with current component props.

- `component` - tested component.
- `expectedProps` - contains expected props of testing component, for example `{ text: 'name' }`.

##### `getDefaultStyle(component)`

Gets all styles of tested component.

#### Timers

You can use Jest's fake timers to control animation progress. Check the full guide about mocking timers on Jest documentation website.

```
jest.useFakeTimers();
// call animation
jest.runAllTimers();
```

If you want more control over animation, you can use `jest.advanceTimersByTime` to move to a certain point in the animation:

```
jest.useFakeTimers();
// call animation
jest.advanceTimersByTime(250);
// make assertions on what you expect the styles of a component should be after 250ms
```

### Example

Expand the full code

```
  test('withTiming animation', () => {
    const style = getDefaultStyle();

    const { getByTestId } = render(<AnimatedComponent />);
    const view = getByTestId('view');
    const button = getByTestId('button');

    expect(view.props.style.width).toBe(0);
    expect(view).toHaveAnimatedStyle(style);

    fireEvent.press(button);
    jest.advanceTimersByTime(600);

    style.width = 100;
    expect(view).toHaveAnimatedStyle(style);
  });
});
```

More examples from `react-native-reanimated` repository:

-
-

### Remarks

- Tests must run with Node 16 or newer.
- Testing `react-native-svg` props is not supported.
- If you have custom babel configuration for testing, make sure that Reanimated's babel plugin is enabled in that environment.

### Recommended testing library

-
- @testing-library/react-hooks - for dealing with hooks

## Custom animations

Custom animations give you a full control over the Entering/Exiting animations and Layout transitions. However, they tend to be hard to understand and maintain. We recommend starting with predefined Entering/Exiting, Keyframes and Layout presets first before using custom animations.

### Reference

```
function CustomAnimation(values) {
  'worklet';
  const animations = {
    // your animations
  };
  const initialValues = {
    // initial values for animations
  };
  const callback = (finished: boolean) => {
    // optional callback that will fire when layout animation ends
  };
  return {
    initialValues,
    animations,
    callback,
  };
}
```

### Custom Exiting Animation

Type definitions

```
function CustomExitTransition (values: ExitAnimationsValues) => LayoutAnimation

type LayoutAnimation = {
    initialValues: StyleProps;
    animations: StyleProps;
    callback?: (finished: boolean) => void;
};

type ExitAnimationsValues = CurrentLayoutAnimationsValues &
  WindowDimensions;

type CurrentLayoutAnimationsValues = {
  ['currentOriginX', 'currentOriginY', 'currentWidth', 'currentHeight', 'currentBorderRadius', 'currentGlobalOriginX','currentGlobalOriginY']: number;
};

interface WindowDimensions {
    windowWidth: number;
    windowHeight: number;
}
```

#### Arguments

- `values` - contains information about where view was displayed and what were its dimensions

  - `values.currentOriginX` - X coordinate of top left corner in parent's coordinate system
  - `values.currentOriginY` - Y coordinate of top left corner in parent's coordinate system
  - `values.currentWidth` - view's width
  - `values.currentHeight` - view's height
  - `values.currentBorderRadius` - view's border radius
  - `values.currentGlobalOriginX` - X coordinate of top left corner in global coordinate system
  - `values.currentGlobalOriginY` - Y coordinate of top left corner in global coordinate system

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

Expand the full code

```
const customExiting = (values) => {
  'worklet';
  const animations = {
    originX: withTiming(2 * WIDTH, { duration: 3000 }),
    opacity: withTiming(0, { duration: 2000 }),
    transform: [{ scale: withTiming(0.2, { duration: 3500 }) }],
  };
  const initialValues = {
    originX: values.currentOriginX,
    opacity: 1,
    transform: [{ scale: 1 }],
  };
  return {
    initialValues,
    animations,
  };
};
```

### Custom Entering Animation

Type definitions

```
function CustomEntryTransition (values: EntryAnimationsValues) => LayoutAnimation

type LayoutAnimation = {
    initialValues: StyleProps;
    animations: StyleProps;
    callback?: (finished: boolean) => void;
};

type EntryAnimationsValues = TargetLayoutAnimationsValues &
  WindowDimensions;

type TargetLayoutAnimationsValues = {
  ['targetOriginX', 'targetOriginY', 'targetWidth', 'targetHeight', 'targetBorderRadius', 'targetGlobalOriginX','targetGlobalOriginY']: number;
};

interface WindowDimensions {
    windowWidth: number;
    windowHeight: number;
}
```

#### Arguments

- `values` - contains information about where view wants to be displayed and what are its dimensions

  - `values.targetOriginX` - X coordinate of top left corner in parent's coordinate system
  - `values.targetOriginY` - Y coordinate of top left corner in parent's coordinate system
  - `values.targetWidth` - view's width
  - `values.targetHeight` - view's height
  - `values.targetBorderRadius` - view's border radius
  - `values.targetGlobalOriginX` - X coordinate of top left corder in global coordinate system
  - `values.targetGlobalOriginY` - Y coordinate of top left corder in global coordinate system

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

Expand the full code

```
const customEntering = (targetValues) => {
  'worklet';
  const animations = {
    originX: withTiming(targetValues.targetOriginX, { duration: 3000 }),
    opacity: withTiming(1, { duration: 2000 }),
    borderRadius: withDelay(1500, withTiming(40, { duration: 3000 })),
    transform: [
      { rotate: withTiming('0deg', { duration: 4000 }) },
      { scale: withTiming(1, { duration: 3500 }) },
    ],
  };
  const initialValues = {
    originX: -WIDTH,
    opacity: 0,
    borderRadius: 10,
    transform: [{ rotate: '90deg' }, { scale: 0.2 }],
  };
  return {
    initialValues,
    animations,
  };
};
```

### Custom Layout Transition

Type definitions

```
function CustomLayoutTransition (values: LayoutAnimationValues) => LayoutAnimation

type LayoutAnimation = {
    initialValues: StyleProps;
    animations: StyleProps;
    callback?: (finished: boolean) => void;
};

type LayoutAnimationsValues = CurrentLayoutAnimationsValues & TargetLayoutAnimationsValues & WindowDimensions;

type CurrentLayoutAnimationsValues = {
    ['currentOriginX', 'currentOriginY', 'currentWidth', 'currentHeight', 'currentBorderRadius', 'currentGlobalOriginX','currentGlobalOriginY']: number;
};

type TargetLayoutAnimationsValues = {
    ['targetOriginX', 'targetOriginY', 'targetWidth', 'targetHeight', 'targetBorderRadius', 'targetGlobalOriginX','targetGlobalOriginY']: number;
};

interface WindowDimensions {
    windowWidth: number;
    windowHeight: number;
}
```

#### Arguments

- `values` - contains before and after information about the view's origin and dimensions

  - `values.targetOriginX` - X coordinate of top left corner in parent's coordinate system
  - `values.targetOriginY` - Y coordinate of top left corner in parent's coordinate system
  - `values.targetWidth` - view's width
  - `values.targetHeight` - view's height
  - `values.targetBorderRadius` - view's border radius
  - `values.targetGlobalOriginX` - X coordinate of top left corder in global coordinate system
  - `values.targetGlobalOriginY` - Y coordinate of top left corder in global coordinate system
  - `values.currentOriginX` - X coordinate of top left corner in parent's coordinate system (before)
  - `values.currentOriginY` - Y coordinate of top left corner in parent's coordinate system (before)
  - `values.currentWidth` - view's width (before)
  - `values.currentHeight` - view's height (before)
  - `values.currentBorderRadius` - view's border radius (before)
  - `values.currentGlobalOriginX` - X coordinate of top left corner in global coordinate system (before)
  - `values.currentGlobalOriginY` - Y coordinate of top left corner in global coordinate system (before)

#### Example

Your browser does not support the video tag.

Your browser does not support the video tag.

Expand the full code

```
const customLayoutTransition = (values) => {
  'worklet';
  return {
    animations: {
      originX: withTiming(values.targetOriginX, { duration: 1000 }),
      originY: withDelay(
        1000,
        withTiming(values.targetOriginY, { duration: 1000 })
      ),
      width: withSpring(values.targetWidth),
      height: withSpring(values.targetHeight),
    },

    initialValues: {
      originX: values.currentOriginX,
      originY: values.currentOriginY,
      width: values.currentWidth,
      height: values.currentHeight,
    },
  };
};
```

### Remarks

- Each Reanimated component has a shared value that keeps the current animations assigned to that particular component. If you start a new animation for a specific property without providing an initial value for that property, the initial value will be taken from the last animation assigned to the component. The only exception is the `Entering` animation, as we have no way to get the previous animation values.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

## useAnimatedProps

`useAnimatedProps` lets you create an animated props object which can be animated using shared values. This object is used to animate properties of third-party components.

For animating style use `useAnimatedStyle` instead.

### Reference

```
import { useAnimatedProps } from 'react-native-reanimated';

function App() {
  const animatedProps = useAnimatedProps(() => {
    return {
      opacity: sv.value ? 1 : 0,
    };
  });

  return <Animated.View animatedProps={animatedProps} />;
}
```

Type definitions

```
function useAnimatedProps<T extends {}>(
  updater: () => Partial<T>,
  dependencies?: DependencyList | null,
  adapters?: PropsAdapterFunction | PropsAdapterFunction[] | null
): Partial<T>;
```

#### Arguments

##### `updater`

A function returning an object with properties you want to animate.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

##### `adapters`Optional

An optional function or an array of functions.

Sometimes when working with third-party libraries properties might be named differently on the API surface from what they really represent on the native side. Adapters make it possible to handle these cases by defining a way to convert these props.

Reanimated comes with two built-in adapters:

- `SVGAdapter` for handling `transform` property in `react-native-svg`
- `TextInputAdapter`.

You can create your own adapters using `createAnimatedPropAdapter` function.

Here's an example of adapting `fill` and `stroke` properties from `react-native-svg` to be able to animate them with Reanimated.

Expand the full code

```
const adapter = createAnimatedPropAdapter(
  (props) => {
    if (Object.keys(props).includes('fill')) {
      props.fill = { type: 0, payload: processColor(props.fill) };
    }
    if (Object.keys(props).includes('stroke')) {
      props.stroke = { type: 0, payload: processColor(props.stroke) };
    }
  },
  ['fill', 'stroke']
);
```

#### Color-related properties

Color-related properties that come from custom components won't work in most cases as these props are in a format incomprehensible for native side. For most commonly used color-related properties we integrated the color processing to our code, managed by our predefined list in Colors.ts file.

However, when your desired color property is not on the list and you want to use it with `useAnimatedProps` - manual processing is necessary. You need to explicitly wrap such color properties with `processColor` function to ensure they are correctly interpreted by the native side.

You can check full list of automatically processed props here - Colors.ts

```
import { processColor } from 'react-native-reanimated';

function App() {
  const animatedProps = useAnimatedProps(() => {
    const mainColor = interpolateColor(
      colorProgress.value,
      [0, 1],
      ['red', 'blue']
    );

    const bgColor = interpolateColor(
      colorProgress.value,
      [0, 1],
      ['green', 'yellow']
    );

    return {
      // `colors` prop is not on our list - we need to process it manually
      colors: processColor([mainColor, bgColor]),
    };
  });
}
```

### Returns

`useAnimatedProps` returns an animated props object which has to be passed to `animatedProps` property of an Animated component that you want to animate.

### Example

### Remarks

- You can share animated props between components to avoid code duplication.
- We recommend to create adapters outside of the component's body to avoid unnecessary recalculations.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## LayoutAnimationConfig

`LayoutAnimationConfig` is a component that lets you skip entering and exiting animations.

### Reference

```
import { LayoutAnimationConfig } from 'react-native-reanimated';

function App() {
  const [show, setShow] = React.useState(true);

  return (
    <LayoutAnimationConfig skipEntering>
      <View>
        {show && <Animated.View entering={PinwheelIn} exiting={PinwheelOut} />}
      </View>
    </LayoutAnimationConfig>
  );
}
```

Type definitions

```
interface LayoutAnimationConfigProps {
  skipEntering?: boolean;
  skipExiting?: boolean;
  children: ReactNode;
}
```

#### Arguments

##### `skipEntering`Optional

A boolean indicating whether children's entering animations should be skipped when `LayoutAnimationConfig` is mounted.

##### `skipExiting`Optional

A boolean indicating whether children's exiting animations should be skipped when `LayoutAnimationConfig` is unmounted.

### Example

Expand the full code

```
      <LayoutAnimationConfig skipEntering>
        {outer && (
          <Animated.View
            entering={PinwheelIn}
            exiting={PinwheelOut}
            style={styles.outerBox}>
            <LayoutAnimationConfig skipEntering skipExiting>
              {inner && (
                <Animated.View
                  style={styles.box}
                  entering={PinwheelIn}
                  exiting={PinwheelOut}
                />
              )}
            </LayoutAnimationConfig>
          </Animated.View>
        )}
      </LayoutAnimationConfig>
```

### Remarks

- You can nest the `LayoutAnimationConfig` component if you want to disable animations on a smaller subset of components.

- If you are working with a `FlatList` and want to skip animations in items when the list is mounted and unmounted you can use `skipEnteringExitingAnimations`. This prop automatically wraps your `FlatList` with `<LayoutAnimationConfig skipEntering skipExiting>`.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

- -
-
-
-

## Web Support

It's possible to launch Reanimated in a web browser. For that case all of the functionalities are implemented purely in JavaScript, hence the efficiency of the animations might be lower.

#### Step 1: Install the package

Install `@babel/plugin-proposal-export-namespace-from`:

- EXPO
- NPM
- YARN

npx expo install @babel/plugin-proposal-export-namespace-from

npm install @babel/plugin-proposal-export-namespace-from

yarn add @babel/plugin-proposal-export-namespace-from

#### Step 2: Add plugins to config file

Add `@babel/plugin-proposal-export-namespace-from` and Reanimated Babel plugin to your `babel.config.js`.

```
  module.exports = {
      presets: [
        ... // don't add it here :)
      ],
      plugins: [
          ...
          '@babel/plugin-proposal-export-namespace-from',
          'react-native-reanimated/plugin',
      ],
  };
```

caution

Make sure to list `react-native-reanimated/plugin` last.

#### Step 3: Launch your app

If you use playground app and want to start it in the browser just type:

```
yarn web
```

If you want to start the example applications from the reanimated repository you need to run the following commands inside respository root:

```
yarn && yarn build
```

Then run inside the `apps/web-example` directory:

```
yarn start
```

### Webpack support

If you want to use Reanimated in a `webpack` app you should adjust your `webpack` config.

Example webpack config file with Reanimated support:

```
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');

module.exports = {
  entry: ['babel-polyfill', './index.js'],
  plugins: [
    new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './index.html',
    }),
    new webpack.EnvironmentPlugin({ JEST_WORKER_ID: null }),
    new webpack.DefinePlugin({ process: { env: {} } }),
  ],
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              '@babel/preset-react',
              { plugins: ['@babel/plugin-proposal-class-properties'] },
            ],
          },
        },
      },
    ],
  },
  resolve: {
    alias: { 'react-native$': 'react-native-web' },
    extensions: ['.web.js', '.js'],
  },
};
```

### Web without the Babel plugin

It is possible to use Reanimated without the Babel plugin (`react-native-reanimated/plugin` on the Web, with some additional configuration.

Reanimated hooks all accept optional dependency arrays. Under the hood, the Reanimated Babel plugin inserts these for you.

In order to use Reanimated without a Babel/SWC plugin, you need to explicitly pass the dependency array whenever you use a Reanimated hook.

Passing a dependency array is valid on both Web and native. Adding them will not negatively impact iOS or Android.

Make sure the following hooks have a dependency array as the last argument:

- `useDerivedValue`
- `useAnimatedStyle`
- `useAnimatedProps`
- `useAnimatedReaction`

For example:

```
const sv = useSharedValue(0);
const dv = useDerivedValue(
  () => sv.value + 1,
  [sv] // dependency array here
);
```

Be sure to pass the dependency itself (`sv`) and not `sv.value` to the dependency array.

caution

Babel users will still need to install the `@babel/plugin-proposal-class-properties` plugin.

#### ESLint Support

When you use hooks from React, they give you nice suggestions from ESLint to include all dependencies. In order to add this support to Reanimated hooks, add the following to your ESLint config:

```
{
  "rules": {
    "react-hooks/exhaustive-deps": [
      "error",
      {
        "additionalHooks": "(useAnimatedStyle|useDerivedValue|useAnimatedProps)"
      }
    ]
  }
}
```

info

This assumes you've already installed the `react-hooks` eslint plugin.

If you're using ESLint autofix, the ESLint plugin may add `.value` to the dependency arrays, rather than the root dependency. In these cases, you should update the array yourself.

```
const sv = useSharedValue(0);

// 🚨 bad, sv.value is in the array
const dv = useDerivedValue(() => sv.value, [sv.value]);

// ✅ good, sv is in the array
const dv = useDerivedValue(() => sv.value, [sv]);
```

### Solito / Next.js Compatibility

There is an experimental SWC plugin in the works. However, given that this may not work properly, you can use the Web without a Babel plugin instructions above.

#### Next.js Polyfill

In order to use Reanimated with Next.js / Solito, you'll need to add the `raf` polyfill for `requestAnimationFrame` to not throw on the server:

```
yarn add raf
```

Add the following to the top of your `_app.tsx`:

```
import 'raf/polyfill';
```

##

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -

- -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -
  -

- -
  -
  -
  -

- -
  -
  -
  -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

- -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -

- -
  -

Version: 3.x

On this page

## List Layout Animations

`itemLayoutAnimation` lets you define a layout transition that's applied when list items layout changes. You can use one of the predefined transitions like `LinearTransition` or create your own transition.

### Example

```
import Animated, { LinearTransition } from 'react-native-reanimated';

function App() {
  return (
    <Animated.FlatList
      data={data}
      renderItem={renderItem}
      itemLayoutAnimation={LinearTransition}
    />
  );
}
```

### Remarks

- `itemLayoutAnimation` works only with a single-column `Animated.FlatList`, `numColumns` property cannot be greater than 1.
- You can change the `itemLayoutAnimation` on the fly or disable it by setting it to `undefined`.

```
function App() {
  const [transition, setTransition] = useState(LinearTransition);

  const changeTransition = () => {
    setTransition(
      transition === LinearTransition ? JumpingTransition : LinearTransition
    );
  };

  const toggleTransition = () => {
    setTransition(transition ? undefined : LinearTransition);
  };

  return (
    <Animated.FlatList
      data={data}
      renderItem={renderItem}
      itemLayoutAnimation={transition}
    />
  );
}
```

- If the list items contain neither a `key` nor `id` property (which are used by default by the FlatList keyExtractor to create list item keys), you must provide your own implementation of the `keyExtractor` function that returns a unique key for each list item.

```
function App() {
  return (
    <Animated.FlatList
      data={data}
      renderItem={renderItem}
      itemLayoutAnimation={LinearTransition}
      keyExtractor={customKeyExtractor}
    />
  );
}
```

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

-
-
-

## withTiming

`withTiming` lets you create an animation based on duration and easing.

### Reference

```
import { withTiming } from 'react-native-reanimated';

function App() {
  sv.value = withTiming(0);
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

interface WithTimingConfig {
  duration?: number;
  easing?: EasingFunction;
  reduceMotion?: ReduceMotion;
}

function withTiming<T extends AnimatableValue>(
  toValue: T,
  config?: WithTimingConfig,
  callback?: (finished?: boolean, current?: AnimatableValue) => void
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `toValue`

The value on which the animation will come at rest. Supported categories:

- **numbers** - number can be a either a number or a string

- **suffixed numbers** - strings being a number with a unit, like `"5.5%"`, `"90deg"` or even `"3bananas`". Just make sure there is no space between number and suffix, also suffix should consist of basic english letters only.

- **colors**

  - Hexadecimal integer - e.g. `0xff1234`,
  - RGB (Red, Green, Blue) - e.g. `"rgb(100, 50, 0)"`,
  - RGBA (Red, Green, Blue, Alpha) - e.g. `"rgba(255, 105, 180, 0)`",
  - RGB Hexadecimal - e.g. `"#53575E"`,
  - HSL (Hue, Saturation, Lightness) - e.g.`"hsl(0, 50%, 50%)"`,
  - Named colors - e.g. `"dodgerblue"`.

- **objects** - object with properties that will be animated separately,

- **array** - array of numbers, each value will be animated separately.

- **transformation matrix** - an array consisting of exactly 16 numerical values is by default animated as a transformation matrix. The numbers in the matrix aren't animated separately. Instead, the array gets decomposed into 3 basic transformations - rotation, scale, and translation – which are then animated separately.

Please mind, that `toValue` and the animated shared value have to share the same category (e.g. you can't animate `width` from `100px` to `50%`).

##### `config`Optional

The timing animation configuration.

Available properties:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| duration | `number` | 300 | Length of the animation (in milliseconds). |
| easing | `Easing` | `Easing.inOut(Easing.quad)` | An easing function which defines the animation curve. |
| reduceMotion | `ReduceMotion` | `ReduceMotion.System` | A parameter that determines how the animation responds to the device's reduced motion accessibility setting. |

###### `Easing`

The `easing` parameter lets you fine-tune the animation over the specified time duration. For example, you can make the animation begin with fast acceleration and then slow down towards the end, or start slowly, then pick up speed before slowing down again towards the end.

It will all start to make sense when you compare a `linear` easing side by side with the default `Easing.inOut(Easing.quad)` easing.

Reanimated provides a selection of ready-to-use easing functions in the `Easing` module. You can find a visualization of some common easing functions at <http://easings.net/>.

You can use our built-in easings by passing them as the `easing` property to the `withTiming` config:

```
import { Easing } from 'react-native-reanimated';

withTiming(sv.value, {
  easing: Easing.bounce,
});
```

Available functions:

- `back` provides a simple animation where the object goes slightly back before moving forward
- `bezier(x1: number, y1: number, x2: number, y2: number)` provides a cubic bezier curve
- `bounce` provides a bouncing animation
- `circle` provides a circular function
- `cubic` provides a cubic function
- `ease` provides a simple inertial animation
- `elastic(bounciness?: number)` provides a simple spring interaction
- `exp` provides an exponential function
- `linear` provides a linear function
- `poly(n: number)` can be used to implement quartic, quintic, and other higher power functions
- `quad` provides a quadratic function
- `sin` provides a sinusoidal function

The following helpers are used to modify other easing functions.

- `in(easing: EasingFunction)` runs an easing function forwards
- `inOut(easing: EasingFunction)` makes any easing function symmetrical
- `out(easing: EasingFunction)` runs an easing function backwards

##### `callback`Optional

A function called upon animation completion. If the animation is cancelled, the callback will receive `false` as the argument; otherwise, it will receive `true`.

#### Returns

`withTiming` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Remarks

- The callback passed to the 3rd argument is automatically workletized and ran on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Getting started

The goal of the _Fundamentals_ section is to help you gain a strong foundation on the core concepts of Reanimated and give you the confidence to explore more advanced use cases on your own. This section is packed with interactive examples, code snippets and explanations. Are you ready? Let's dive in!

### What is React Native Reanimated?

React Native Reanimated is a powerful animation library built by Software Mansion.

With Reanimated, you can easily create smooth animations and interactions that run on the UI thread.

### Quick start

If you don't have an existing project, you can create a new Expo app using a template:

- NPM
- YARN

npx create-expo-app\@latest my-app -e with-reanimated

yarn create expo-app my-app -e with-reanimated

Alternatively, you can dive into our examples on GitHub.

### Installation

It takes three steps to add Reanimated to a project:

#### Step 1: Install the package

Install `react-native-reanimated` package from npm:

- EXPO
- NPM
- YARN

npx expo install react-native-reanimated

npm install react-native-reanimated

yarn add react-native-reanimated

#### Step 2: Add Reanimated's babel plugin

Add `react-native-reanimated/plugin` plugin to your `babel.config.js`.

```
  module.exports = {
    presets: [
      ... // don't add it here :)
    ],
    plugins: [
      ...
      'react-native-reanimated/plugin',
    ],
  };
```

caution

`react-native-reanimated/plugin` has to be listed last.

Why do I need this?

In short, the Reanimated babel plugin automatically converts special JavaScript functions (called worklets) to allow them to be passed and run on the UI thread.

To learn more about the plugin head onto to Reanimated babel plugin section.

#### Step 3: Wrap metro config with reanimated wrapper (recommended)

Wrap your existing Metro configuration in the `metro.config.js` file with the `wrapWithReanimatedMetroConfig` function.

```
// metro.config.js
const {
  wrapWithReanimatedMetroConfig,
} = require('react-native-reanimated/metro-config');

const config = {
  // Your existing Metro configuration options
};

module.exports = wrapWithReanimatedMetroConfig(config);
```

Why should I do this?

Wrapping your Metro configuration with the Reanimated Metro config wrapper will result in displaying improved reanimated errors and warnings with more accurate call stacks. Thanks to this, identifying misuses of the Reanimated API will be much easier than before.

To learn more about this feature, head onto to Accurate Call Stacks.

#### Step 4: Clear Metro bundler cache (recommended)

- EXPO
- NPM
- YARN

npx expo start -c

npm start -- --reset-cache

yarn start --reset-cache

#### Expo development build

When using an Expo development build, run prebuild to update the native code in the `ios` and `android` directories.

```
npx expo prebuild
```

#### Platform specific setup

##### Android

No additional steps are necessary.

##### iOS

While developing for iOS, make sure to install pods first before running the app:

```
cd ios && pod install && cd ..
```

##### Web

For building apps that target web using react-native-web we highly recommend to use Expo.

To use Reanimated on the web all you need to do is to install and add `@babel/plugin-proposal-export-namespace-from` Babel plugin to your `babel.config.js`.

- EXPO
- NPM
- YARN

npx expo install @babel/plugin-proposal-export-namespace-from

npm install @babel/plugin-proposal-export-namespace-from

yarn add @babel/plugin-proposal-export-namespace-from

```
  module.exports = {
      presets: [
        ... // don't add it here :)
      ],
      plugins: [
          ...
          '@babel/plugin-proposal-export-namespace-from',
          'react-native-reanimated/plugin',
      ],
  };
```

Make sure to list `react-native-reanimated/plugin` last.

More advanced use cases such as running Reanimated with `webpack` or with `Next.js` are explained in a separate Web Support guide.

Version: 3.x

On this page

## useScrollViewOffset

`useScrollViewOffset` lets you to create animations based on the offset of a `ScrollView`. The hook automatically detects if the `ScrollView` is horizontal or vertical.

### Reference

```
import { useScrollViewOffset } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();
  const scrollOffset = useScrollViewOffset(animatedRef);
  return (
    <Animated.ScrollView ref={animatedRef}>{/* ... */}</Animated.ScrollView>
  );
}
```

Type definitions

```
function useScrollViewOffset(
  animatedRef: AnimatedRef<AnimatedScrollView>,
  initialRef?: SharedValue<number>
): SharedValue<number>;
```

#### Arguments

##### `animatedRef`

An animated ref connected to the ScrollView component you'd want to scroll on. The animated ref has to be passed either to an Animated component or a React Native built-in component.

##### `initialRef`Optional

An optional shared value to be updated with the scroll offset. If not provided a new shared value will be created internally.

#### Returns

`useScrollViewOffset` returns a shared value which holds the current offset of the `ScrollView`.

### Example

### Remarks

- The `animatedRef` argument can be changed at will and the hook will correctly return values based on the ScrollView component it is connected to, for example:

  `useScrollViewOffset(someState ? someScrollRefA : someScrollRefB)`

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

##

## Customizing animations

Previous section not only taught you how to use shared values in practice but also you used `withSpring` and `withTiming` functions to create animations. We think now you're more than ready to dive deeper into customizing animations!

Reanimated comes with three built-in animation functions: `withTiming`, `withSpring`, and `withDecay`. For now, let's focus on the first two, and we'll come back to `withDecay` in the Handling gestures section.

It's very easy to customize the behavior of animation functions in Reanimated. You can do this by passing a `config` object to the second parameter of either `withTiming` or `withSpring` function.

### Configuring `withTiming`

The `config` parameter of `withTiming` comes with two properties: `duration` and `easing`.

```
import { withTiming, Easing } from 'react-native-reanimated';

withTiming(sv.value, {
  duration: 300,
  easing: Easing.inOut(Easing.quad),
});
```

Simple enough, the `duration` parameter defines how long in milliseconds the animation should take to reach the assigned `toValue`. The duration by default is set to `300` milliseconds.

The `easing` parameter lets you fine-tune the animation over the specified time. For example, you can make the animation start slowly then pickup some speed and slow it down again towards the end. This value defaults to `Easing.inOut(Easing.quad)`.

It all will start to make sense when you compare side by side a `linear` easing with the default easing.

Reanimated comes with a handful of predefined easing functions. You can play around with them in the interactive playground below or check the full `withTiming` API reference.

`withTiming` interactive playground

### Configuring `withSpring`

`withSpring` is a physics-based animation function which works way differently from `withTiming`. It makes it look like the object you're animating is connected to a real spring. The physics-based approach makes the animations look _believable_.

Most of the time when tinkering with springs you'll be adjusting one of these three properties: `mass`, `stiffness` (also known as _tension_), and `damping` (also known as _friction_).

```
import { withSpring } from 'react-native-reanimated';

withSpring(sv.value, {
  mass: 1,
  stiffness: 100,
  damping: 10,
});
```

The mass of a spring influences how hard is it to make an object move and to bring it to a stop. Mass adds a feeling of _inertia_ to the object you're trying to move. You can see in the playground that the spring with greater mass moves more "sluggish" compared to the default configuration.

Stiffness affects how bouncy the spring is. As an example, think about the difference between a steel spring (with very high stiffness) and a spring made out of soft plastic (with low stiffness).

Damping describes how quickly the spring animation finishes. Higher damping means the spring will come to rest faster. In the real world, you could think about the same spring bouncing in the air and underwater. For example, a spring in a vacuum would have zero friction and thus zero damping.

Reanimated comes with a handful of other properties used to customize your spring animation. You can play around with them in our interactive playground or check the full `withSpring` API reference.

`withSpring` interactive playground

### Summary

In this section, we learned how to customize the `withTiming` and `withSpring` animation functions. To sum up:

- Both `withTiming` and `withSpring` functions take the `config` object as a second parameter.
- You can adjust `withTiming` behavior with `duration` and `easing` properties. For your convenience Reanimated comes with a built-in `Easing` module.
- Some of the properties which adjust the behavior of `withSpring` are `mass`, `stiffness` and `damping`.

### What's next?

In the upcoming section, you'll discover how to use animation modifiers such as `withSequence` and `withRepeat`. These modifiers we'll allow us to create more complex and engaging animations.

## withSpring

`withSpring` lets you create spring-based animations.

### Reference

```
import { withSpring } from 'react-native-reanimated';

function App() {
  sv.value = withSpring(0);
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

interface WithSpringConfig {
  damping?: number;
  mass?: number;
  stiffness?: number;
  overshootClamping?: boolean;
  restSpeedThreshold?: number;
  restDisplacementThreshold?: number;
  velocity?: number;
  reduceMotion?: ReduceMotion;
  clamp?: [number, number];
}

function withSpring<T extends AnimatableValue>(
  toValue: T,
  config?: WithSpringConfig,
  callback?: (finished?: boolean, current?: AnimatableValue) => void
): T;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `toValue`

The value on which the animation will come at rest. Supported categories:

- **numbers** - number can be a either a number or a string

- **suffixed numbers** - strings being a number with a unit, like `"5.5%"`, `"90deg"` or even `"3bananas`". Just make sure there is no space between number and suffix, also suffix should consist of basic english letters only.

- **colors**

  - Hexadecimal integer - e.g. `0xff1234`,
  - RGB (Red, Green, Blue) - e.g. `"rgb(100, 50, 0)"`,
  - RGBA (Red, Green, Blue, Alpha) - e.g. `"rgba(255, 105, 180, 0)`",
  - RGB Hexadecimal - e.g. `"#53575E"`,
  - HSL (Hue, Saturation, Lightness) - e.g.`"hsl(0, 50%, 50%)"`,
  - Named colors - e.g. `"dodgerblue"`.

- **objects** - object with properties that will be animated separately,

- **array** - array of numbers, each value will be animated separately.

- **transformation matrix** - an array consisting of exactly 16 numerical values is by default animated as a transformation matrix. The numbers in the matrix aren't animated separately. Instead, the array gets decomposed into 3 basic transformations - rotation, scale, and translation – which are then animated separately.

Please mind, that `toValue` and the animated shared value have to share the same category (e.g. you can't animate `width` from `100px` to `50%`).

##### `config`Optional

The spring animation configuration.

Available for physics-based spring:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| massOptional | `number` | 1 | The weight of the spring. Reducing this value makes the animation faster. |
| dampingOptional | `number` | 10 | How quickly a spring slows down. Higher damping means the spring will come to rest faster. |

Available for duration-based spring:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| durationOptional | `number` | 2000 | Length of the animation (in milliseconds). Available in Reanimated ≥ 3.2.x |
| dampingRatioOptional | `number` | 0.5 | How damped the spring is. Value `1` means the spring is critically damped, and value `>1` means the spring is overdamped. Available in Reanimated ≥ 3.2.x |

info

The `mass` and `damping` (physics-based) properties can't be used at the same time as `duration` and `dampingRatio` (duration-based).

When used together `duration` and `dampingRatio` overrides `mass` and `damping` props.

Available for every spring animation:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| stiffnessOptional | `number` | 100 | How bouncy the spring is. |
| velocityOptional | `number` | 0 | Initial velocity applied to the spring equation. |
| overshootClampingOptional | `boolean` | false | Whether a spring can bounce over the `toValue`. |
| restDisplacementThresholdOptional | `number` | 0.01 | The displacement below which the spring will snap to `toValue` without further oscillations. |
| restSpeedThresholdOptional | `number` | 2 | The speed in pixels per second from which the spring will snap to `toValue` without further oscillations. |
| reduceMotionOptional | `ReduceMotion` | `ReduceMotion.System` | A parameter that determines how the animation responds to the device's reduced motion accessibility setting. Available in Reanimated ≥ 3.5.x |
| clampOptional | `[number, number]` | `undefined` | Limit of the scope of movement. If your spring would exceed this limit, then `dampingRatio` will be reduced (to make the spring less bouncy) Available in Reanimated ≥ 3.6.x |

##### `callback`Optional

A function called upon animation completion. If the animation is cancelled, the callback will receive `false` as the argument; otherwise, it will receive `true`.

#### Returns

`withSpring` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Remarks

- The callback passed to the 3rd argument is automatically workletized and ran on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## useAnimatedRef

`useAnimatedRef` lets you get a reference of a view. Used alongside `measure`, `scrollTo`, and `useScrollViewOffset` functions.

You need to pass the object defined using `useAnimatedRef` to the `ref` property of a component.

### Reference

```
import { useAnimatedRef } from 'react-native-reanimated';

function App() {
  const animatedRef = useAnimatedRef();

  return <Animated.View ref={animatedRef} />;
}
```

Type definitions

```
function useAnimatedRef<T extends Component>(): AnimatedRef<T>;
```

#### Arguments

`useAnimatedRef` doesn't take any arguments.

#### Returns

`useAnimatedRef` returns an object with a `current` property which contains an instance of a component.

### Example

Expand the full code

```
export default function App() {
  const animatedRef = useAnimatedRef<Animated.View>();

  return (
    <View style={styles.container}>
      <Animated.View
        ref={animatedRef}
        style={styles.box}
        onLayout={() => {
          // Returns a reference to the component
          const component = animatedRef.current;
        }}
      />
    </View>
  );
}
```

### Remarks

- You can use `useAnimatedRef` to reference not only the Animated versions of components, but any React Native component.

- The value stored in the current property becomes available after the component is mounted.

```
function App() {
  const animatedRef = useAnimatedRef();

  console.log(animatedRef.current); // 🚩 Returns null

  useEffect(() => {
    console.log(animatedRef.current); // ✅ Returns the component
  }, []);

  return <View ref={animatedRef} />;
}
```

Alternatively, you can get the value stored in the `current` in event handlers or in a `onLayout` property.

- The value stored in the `current` property isn't available on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

##

## Animating styles and props

In the last section, we learned how to make simple animations, what shared values are and how to use them. Now, we'll learn a different way of passing animation styles to components. We'll also go over the difference between animating styles and props and how to handle them using `useAnimatedStyle` and `useAnimatedProps`.

### Animating styles

As we learned in the previous section we can animate styles by passing shared values inline to the elements' `style` property:

```
import Animated, { useSharedValue } from 'react-native-reanimated';

function App() {
  const width = useSharedValue(100);

  return <Animated.View style={{ width }} />;
}
```

In basic cases, this syntax works well but it has one big downside. It doesn't allow to access the value stored in a shared value. For example, it's not possible to build more complex animations by using inline styling to multiply this value (or do any other mathematical operation) before assigning it to the `style` prop.

```
<Animated.View style={{ width: width * 5 }} /> // this won't work
```

Let's suppose we have an example with a box which moves to the right on every button press:

```
import { View, Button } from 'react-native';
import Animated, { useSharedValue, withSpring } from 'react-native-reanimated';

function App() {
  const translateX = useSharedValue(0);

  const handlePress = () => {
    translateX.value = withSpring(translateX.value + 50);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, { transform: [{ translateX }] }]} />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

If we would like to customize how our shared value changes based on some user input, (e.g. multiplying it by 2 or following some other mathematical equation) we couldn't use inline styling.

Luckily, the `useAnimatedStyle` hook comes to the rescue. It adds additional control and flexibility over your animation. This can be really useful when creating a bit more complicated animations which include conditional statements or loops.

Let's see it in action:

Expand the full code

```
export default function App() {
  const translateX = useSharedValue<number>(0);

  const handlePress = () => {
    translateX.value += 50;
  };

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [{ translateX: withSpring(translateX.value * 2) }],
  }));

  return (
    <>
      <Animated.View style={[styles.box, animatedStyles]} />
      <View style={styles.container}>
        <Button onPress={handlePress} title="Click me" />
      </View>
    </>
  );
```

`useAnimatedStyle` lets you access the value stored in a shared value. Thanks to that we could multiply the value by `2` before assigning it to `style`. This hook has one more advantage over passing animations to inline styles. It allows you to keep all the animation-related logic in one place.

You can see it in action in the example below:

### Animating props

Most of the values that developers animate (`width`, `color`, `transform` etc.) are modified by passing them as an object to the `style` property of an element. But that's not always the case.

Sometimes we'd like to animate not just styles but also the props which are passed to the component.

For example, let's say we would like to animate SVG elements. Instead of passing values to the `style` property, values are defined as props:

```
<Circle cx="50" cy="50" r="10" fill="blue" />
```

Reanimated comes with just a handful of built-in components like `Animated.View` or `Animated.ScrollView`. For components which aren't a part of Reanimated, to make their props animatable, we need to wrap them with `createAnimatedComponent`:

```
import Animated from 'react-native-reanimated';
import { Circle } from 'react-native-svg';

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
```

To animate the radius of the SVG circle we can simply pass the shared value as a prop:

```
import { useSharedValue } from 'react-native-reanimated';
import { Svg } from 'react-native-svg';

function App() {
  const r = useSharedValue(10);

  return (
    <Svg>
      <AnimatedCircle cx="50" cy="50" r={r} fill="blue" />
    </Svg>
  );
}
```

This approach works just fine but same as `useAnimatedStyle` for animating styles we can encapsulate the animation logic and gain access to the `.value` property of a shared value by using `useAnimatedProps`.

So if we'd like to smoothly increase the radius of a circle by `10px` on each button press we could use `useAnimatedProps`:

Expand the full code

```
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

export default function App() {
  const r = useSharedValue<number>(20);

  const handlePress = () => {
    r.value += 10;
  };

  const animatedProps = useAnimatedProps(() => ({
    r: withTiming(r.value),
  }));

  return (
    <View style={styles.container}>
      <Svg style={styles.svg}>
        <AnimatedCircle
          cx="50%"
          cy="50%"
          fill="#b58df1"
          animatedProps={animatedProps}
        />
      </Svg>
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

In a function which `useAnimatedProps` takes as an argument, we return an object with all the props we'd like to animate. Then we can pass the value which `useAnimatedProps` returns to the `animatedProps` prop of an Animated component.

Check out the full example below:

### Summary

In this section, we went through the differences between animating styles and props and how to use `useAnimatedStyle` and `useAnimatedProps`. To sum up:

- Passing shared values to inline styles is a simple way of creating animations but it has some limitations.
- Difference between animating `props` and `styles` is that props are not passed to the `style` object, but rather as separate props of the component.
- By using `useAnimatedStyle` and `useAnimatedProps`, you can access the value stored in a shared value. This can add additional control over the animation.
- You can make your own animatable components by wrapping them with `Animated.createAnimatedComponent`.

### What's next?

In the next section, we'll learn more about animation functions and how to customize their behavior.

## useDerivedValue

`useDerivedValue` lets you create new shared values based on existing ones while keeping them reactive.

### Reference

```
import { useDerivedValue } from 'react-native-reanimated';

function App() {
  const derivedValue = useDerivedValue(() => {
    return sv.value * 50;
  });
}
```

Type definitions

```
interface SharedValue<Value = unknown> {
  value: Value;
  get(): Value;
  set(value: Value | ((value: Value) => Value)): void;
  addListener: (listenerID: number, listener: (value: Value) => void) => void;
  removeListener: (listenerID: number) => void;
  modify: (
    modifier?: <T extends Value>(value: T) => T,
    forceUpdate?: boolean
  ) => void;
}

interface DerivedValue<Value = unknown>
  extends Readonly<Omit<SharedValue<Value>, 'set'>> {
  /**
   * @deprecated Derived values are readonly, don't use this method. It's here
   *   only to prevent breaking changes in TypeScript types. It will be removed
   *   in the future.
   */
  set: SharedValue<Value>['set'];
}

function useDerivedValue<T>(
  updater: () => T,
  dependencies?: DependencyList
): DerivedValue<T>;
```

#### Arguments

##### `updater`

A function that should return a value constructed of shared values, React state or any other JavaScript value. This function is called whenever at least one of the shared values or state used in the function body changes.

##### `dependencies`Optional

An optional array of dependencies.

Only relevant when using Reanimated without the Babel plugin on the Web.

#### Returns

`useDerivedValue` returns a new readonly shared value based on a value returned from the `updater` function.

### Example

### Remarks

- The callback passed to the first argument is automatically workletized and ran on the UI thread.

- You can also use `useDerivedValue` without returning a value in the `updater` function to react to a change of a shared value. If you need to access the previous value stored in a shared value use `useAnimatedReaction` instead.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## runOnJS

`runOnJS` lets you asynchronously run non-workletized functions that couldn't otherwise run on the UI thread. This applies to most external libraries as they don't have their functions marked with `"worklet";` directive.

`runOnJS` is usually used to update React state either on animation finish or conditionally within a gesture.

### Reference

```
import { runOnJS } from 'react-native-reanimated';

function App() {
  // While on the UI thread
  runOnJS(navigation.goBack)();
}
```

Type definitions

```
function runOnJS<A extends any[], R>(
  fn: (...args: A) => R
): (...args: Parameters<typeof fn>) => void;
```

#### Arguments

##### fn

A reference to a function you want to execute on the JavaScript thread from the UI thread. Arguments to your function have to be passed to the function returned from `runOnJS` i.e. `runOnJS(setValue)(10);`.

#### Returns

`runOnJS` returns a function that accepts arguments for the function passed as the first argument. This function can be safely executed on the UI thread.

info

Don't forget to call the function returned from `runOnJS`.

### Example

### Remarks

- Functions passed to `runOnJS` must be defined in the JavaScript thread scope, i.e. in the component body or the global scope. This code won't work because `myFunction` is defined in the `withTiming` callback, which is only executed in the UI thread:

```
withTiming(0, {}, () => {
  // myFunction is defined on the UI thread 🚨
  const myFunction = () => {
    // ...
  };
  runOnJS(myFunction)(); // 💥
});
```

- It's a common mistake to execute function inside of runOnJS like this: ~~`runOnJS(setValue(10))()`~~. Here, the correct usage would be `runOnJS(setValue)(10)`.

- It's safe to run functions via `runOnJS` on the JavaScript thread, as this has no effect.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## runOnUI

`runOnUI` lets you asynchronously run workletized functions on the UI thread.

Most commonly used either with an `useEffect` to start an animation on component mount/unmount or with `measure` and `scrollTo` functions which have implementations only on the UI thread.

### Reference

```
import { runOnUI } from 'react-native-reanimated';

function App() {
  // E.g. in event handler or in an effect
  runOnUI((greeting) => {
    console.log(`${greeting} from the UI thread`);
  })('Howdy');

  // ...
}
```

Type definitions

```
function runOnUI<A extends any[], R>(
  fn: (...args: A) => R
): (...args: Parameters<typeof fn>) => void;
```

#### Arguments

##### fn

A reference to a function you want to execute on the UI thread from the JavaScript thread. Arguments to your function have to be passed to the function returned from `runOnUI` i.e. `runOnUI(myWorklet)(10);`.

#### Returns

`runOnUI` returns a function that accepts arguments for the function passed as the first argument.

info

Don't forget to call the function returned from `runOnUI`.

### Example

### Remarks

- When implementing your animations you should first reach for more general solutions such as `useDerivedValue`, `useAnimatedReaction` or running code in gesture callbacks and only use `runOnUI` after you've tried other methods.

- It's a common mistake to execute function inside of runOnUI like this: ~~`runOnUI(myWorklet(10))()`~~. Here, the correct usage would be `runOnUI(myWorklet)(10)`.

- The callback passed as the argument is automatically workletized and ready to be run on the UI thread.

- Make sure not to execute `runOnUI` on the UI thread as this will result in an error.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## Your First Animation

In this section, we'll guide you through the basic concepts of Reanimated. If you're new to Reanimated, you're in the right hands! We're going to start by building a simple animation which will help you develop a basic understanding of the library. Then, in the following sections, we're going to build on top of this knowledge and further expand your skills. Let's go!

### Using an Animated component

Let's start by having something that we could see on the screen. First, to create an animatable component you need to import an `Animated` object:

```
import Animated from 'react-native-reanimated';
```

This `Animated` object wraps React Native built-ins such as `View`, `ScrollView` or `FlatList`.

You use these components as any other JSX components:

```
import Animated from 'react-native-reanimated';

export default function App() {
  return (
    <Animated.View
      style={{
        width: 100,
        height: 100,
        backgroundColor: 'violet',
      }}
    />
  );
}
```

info

### Defining a shared value

A shared value is a driving factor of all your animations. You can think of it as a React state which is automagically kept in sync between the “JavaScript” and the “native” side of your app (hence the name). You create shared values using a `useSharedValue` hook:

```
import { useSharedValue } from 'react-native-reanimated';
```

As with any other React hook, you need to define it in your component's body. In a shared value, you can store any JS value like `number`, `string` or `boolean` but also data structures such as `array` and `object`.

For now, let's use `100` as the default value of the `useSharedValue` hook and pass the returned value as an inline style of the `Animated.View`:

```
import Animated, { useSharedValue } from 'react-native-reanimated';

export default function App() {
  const width = useSharedValue(100);

  return (
    <Animated.View
      style={{
        width,
        height: 100,
        backgroundColor: 'violet',
      }}
    />
  );
}
```

### Using a shared value

Let's create a very simple animation that will animate a `width` of an element. We'll make it expand by `50px` on each button press. We can do this by modifying a shared value connected to the `width` property of an `Animated.View` component. I know it might sound complicated, but it's actually quite simple.

Values stored in shared values are accessed and modified by their `.value` property.

There's no setter or anything - you simply mutate the `.value` property like there's no tomorrow.

Let's define a `handlePress` function inside of which we'll modify the shared value:

```
import { Button, View } from 'react-native';
import Animated, { useSharedValue } from 'react-native-reanimated';

export default function App() {
  const width = useSharedValue(100);

  const handlePress = () => {
    width.value = width.value + 50;
  };

  return (
    <View style={{ flex: 1, alignItems: 'center' }}>
      <Animated.View
        style={{
          width,
          height: 100,
          backgroundColor: 'violet',
        }}
      />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

Please hold on a second before you shorten `width.value = width.value + 50` to `width.value += 50`. We're preparing this code for the final step which will finally bring our animation to life!

caution

It's a common mistake to modify a shared value directly like this: ~~`sv = sv + 100;`~~. Always remember to access the shared value by using the `.value` property instead. Here, the correct usage would be `sv.value = sv.value + 100;`.

### Using an animation function

Finally, import `withSpring` function and wrap around `width.value + 50` in the `handlePress` function so that the value which `withSpring` returns modifies the shared value. This will create a bouncy spring animation that transitions the width of the element from its current value (here `width.value`) to the new one (here `width.value + 50`).

```
import { Button, View } from 'react-native';
import Animated, { useSharedValue, withSpring } from 'react-native-reanimated';

export default function App() {
  const width = useSharedValue(100);

  const handlePress = () => {
    width.value = withSpring(width.value + 50);
  };

  return (
    <View style={{ flex: 1, alignItems: 'center' }}>
      <Animated.View
        style={{
          width,
          height: 100,
          backgroundColor: 'violet',
        }}
      />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

And voilà, we've made our first animation using Reanimated! You can see how it works in its full glory in a preview below:

### Summary

In this section, we gained a firm grasp on the Reanimated fundamentals. We learned about `Animated` components, shared values and how to use them to create a simple animation. To sum up:

- `Animated` components are used to define animatable elements.
- Shared values are a driving factor of all animations and we define them using a `useSharedValue` hook.
- Shared values are always accessed and modified by their `.value` property (eg. `sv.value = 100;`).
- To create smooth animations modify shared values using animation functions like `withTiming`

### What's next?

In the next section, we will learn more about how to animate styles and props using `useAnimatedStyle` and `useAnimatedProps` hooks.

## withDecay

`withDecay` lets you create animations that mimic objects in motion with friction. The animation will start with the provided velocity and slow down over time according to the given deceleration rate until it stops.

### Reference

```
import { withDecay } from 'react-native-reanimated';

function App() {
  sv.value = withDecay({ velocity: 1 });
  // ...
}
```

Type definitions

```
type AnimatableValue = number | string | number[];

interface WithDecayConfig {
  deceleration?: number;
  velocity?: number;
  clamp?: [number, number];
  velocityFactor?: number;
  rubberBandEffect?: boolean;
  rubberBandFactor?: number;
  reduceMotion?: ReduceMotion;
}

function withDecay(
  userConfig: WithDecayConfig,
  callback?: (finished?: boolean, current?: AnimatableValue) => void
): number;

enum ReduceMotion {
  System = 'system',
  Always = 'always',
  Never = 'never',
}
```

#### Arguments

##### `config`

The decay animation configuration.

Available properties:

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| velocityOptional | `number` | 0 | Initial velocity of the animation. |
| decelerationOptional | `number` | 0.998 | The rate at which the velocity decreases over time. |
| clampOptional\* | `[number, number]` | \[] | Array of two numbers which restricts animation's range. Animation stops when either bound is reached unless the `rubberBandEffect` option is set to `true`. \*Required when `rubberBandEffect` is set to `true`. |
| velocityFactorOptional | `number` | 1 | Velocity multiplier. |
| rubberBandEffectOptional | `boolean` | false | Makes the animation bounce over the limit specified in `clamp`. |
| rubberBandFactorOptional | `number` | 0.6 | Strength of the rubber band effect. |
| reduceMotionOptional | `ReduceMotion` | `ReduceMotion.System` | A parameter that determines how the animation responds to the device's reduced motion accessibility setting. |

##### `callback`Optional

A function called on animation complete. In case the animation is cancelled, the callback will receive `false` as the argument, otherwise it will receive `true`.

#### Returns

`withDecay` returns an animation object which holds the current state of the animation. It can be either assigned directly to a shared value or can be used as a value for a style object returned from useAnimatedStyle.

### Example

### Remarks

- The callback passed to the 2nd argument is automatically workletized and ran on the UI thread.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## createAnimatedComponent

`createAnimatedComponent` lets you create an Animated version of any React Native component. Wrapping a component with `createAnimatedComponent` allows Reanimated to animate any prop or style associated with that component.

Reanimated comes with five built-in Animated components:

- `Animated.FlatList`
- `Animated.Image`
- `Animated.View`
- `Animated.ScrollView`
- `Animated.Text`

Rest of the components you might want to animate in React Native have to be wrapped with a `createAnimatedComponent` function.

### Reference

```
import Animated from 'react-native-reanimated';
import { TextInput } from 'react-native';

const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);
```

Type definitions

```
function createAnimatedComponent<P extends object>(
  component: ComponentClass<P>
): ComponentClass<AnimateProps<P>>;

function createAnimatedComponent<P extends object>(
  component: FunctionComponent<P>
): FunctionComponent<AnimateProps<P>>;
```

#### Arguments

##### `component`

The component you want to make animatable. Function components have to be wrapped with `React.forwardRef()`.

#### Returns

`createAnimatedComponent` returns a component that Reanimated is capable of animating.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## runOnRuntime

`runOnRuntime` lets you asynchronously run workletized functions on a separate worklet runtime on a separate thread.

### Reference

```
import { createWorkletRuntime, runOnRuntime } from 'react-native-reanimated';

const workletRuntime = createWorkletRuntime('background');

function App() {
  // E.g. in event handler or in an effect
  runOnRuntime(workletRuntime, (greeting) => {
    console.log(`${greeting} from a separate thread`);
  })('Howdy');

  // ...
}
```

Type definitions

```
function runOnRuntime<A extends any[], R>(
  workletRuntime: WorkletRuntime,
  fn: (...args: A) => R
): (...args: Parameters<typeof fn>) => void;
```

#### Arguments

##### workletRuntime

A reference to worklet runtime created with `createWorkletRuntime`.

##### fn

A reference to a function you want to execute on the UI thread from the JavaScript thread. Arguments to your function have to be passed to the function returned from `runOnUI` i.e. `runOnUI(myWorklet)(10);`.

#### Returns

`runOnRuntime` returns a function that accepts arguments for the function passed as the first argument.

info

Don't forget to call the function returned from `runOnRuntime`.

### Remarks

- It's a common mistake to execute function inside of `runOnRuntime` like this: ~~`runOnRuntime(myWorklet(10))()`~~. Here, the correct usage would be `runOnRuntime(myWorklet)(10)`.

- The callback passed as the argument will not be workletized automatically. You need to add `'worklet';` directive manually to allow the function to be run on the UI thread.

- You may call `runOnRuntime` on any runtime, including the RN runtime, UI runtime and other worklet runtimes.

- The function passed to `runOnRuntime` will be added to an execution queue on a separate thread and executed asynchronously on the specified worklet runtime. The functions will be executed in the order they were added to the queue.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

## cancelAnimation

`cancelAnimation` lets you cancel a running animation paired to a shared value.

### Reference

```
import { cancelAnimation } from 'react-native-reanimated';

function App() {
  const offset = useSharedValue(100);

  const handleCancel = () => {
    cancelAnimation(offset);
  };
}
```

Type definitions

```
type SharedValue<T> = { value: T };

function cancelAnimation<T>(sharedValue: SharedValue<T>): void;
```

#### Arguments

##### `sharedValue`

The shared value of a running animation that you want to cancel. If no animation is running, the `cancelAnimation` function does nothing.

#### Returns

`cancelAnimation` returns `undefined`.

### Example

### Remarks

- You can resume the animation by assigning the same animation (i.e. `withSpring`, `withTiming`) to the shared value again.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## createWorkletRuntime

`createWorkletRuntime` lets you create a new JS runtime which can be used to run worklets possibly on different threads than JS or UI thread. This function is supposed to be used by third-party libraries that need to integrate with worklets. The return value represents the runtime and it's supposed to be passed to C++ side using JSI (JavaScript Interface) for further operations.

### Reference

#### Usage in JavaScript

```
import { createWorkletRuntime } from 'react-native-reanimated';

function App() {
  const runtime = createWorkletRuntime('background');
}
```

#### Usage in C++

```
auto runtime = reanimated::extractWorkletRuntime(rt, runtimeValue);

jsi::Runtime &rt = runtime->getJSIRuntime();

auto worklet = reanimated::extractShareableOrThrow<reanimated::ShareableWorklet>(rt, workletValue);

runtime->runGuarded(worklet, ...args);
```

Type definitions

```
type WorkletRuntime = {
  __hostObjectWorkletRuntime: never;
  readonly name: string;
};

function createWorkletRuntime(
  name: string,
  initializer?: __ComplexWorkletFunction<[], void>
): WorkletRuntime;
```

#### Arguments

##### `name`

A name used to identify the runtime which will appear in devices list in Chrome DevTools.

##### `initializer`

An optional worklet that will be run synchronously on the same thread immediately after the runtime is created. It can be used to inject some global variables or functions into the runtime.

#### Returns

`createWorkletRuntime` returns `WorkletRuntime` which is a `jsi::HostObject<reanimated::WorkletRuntime>`.

### Remarks

- Worklet runtimes come with `performance.now` and `console.*` methods installed out-of-the-box. Other APIs are not available and need to be injected into the runtime or captured via worklet closure.

- In development mode, all unhandled errors thrown in the runtime (except for those thrown in `initializer`) will be caught and thus logged to the console and displayed in a LogBox.

- You can use Chrome DevTools to debug the runtime (Hermes only). The runtime will appear in the devices list as `name` passed to `createWorkletRuntime`.

- Shared values are only partially supported in worklet runtimes. If you want to write to a shared value from the RN runtime and read it on the worklet runtime, you need to perform the assignment using `runOnRuntime`. Otherwise, the value will be updated only in the RN and UI runtimes.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ❌  |

##

## Applying modifiers

Another way of customizing animations in Reanimated is by using animation modifiers. Reanimated comes with three built-in modifiers: `withRepeat`, `withSequence`, and `withDelay`.

Let's build a simple shake animation which uses all the modifiers and learn them along the way. Let's go!

### Starting point

In this example, we're going to make an animated box which will shake on a button press after a slight delay.

Let's start by having an `Animated.View` and a `Button` which moves the view to the right on press. To achieve this we can use `useAnimatedStyle` and `withTiming` function to smoothly animate our box `40px` to the right.

If this sounds new to you, no worries! Start by going through the basics in Your First Animation and come back here when you're ready.

Expand the full code

```
export default function App() {
  const offset = useSharedValue<number>(0);

  const style = useAnimatedStyle(() => ({
    transform: [{ translateX: offset.value }],
  }));

  const OFFSET = 40;

  const handlePress = () => {
    offset.value = withTiming(OFFSET);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, style]} />
      <Button title="shake" onPress={handlePress} />
    </View>
  );
}
```

### Repeating an animation

To implement our desired shake animation we can use `withRepeat` modifier. This modifier lets you repeat a provided animation.

```
import { withRepeat } from 'react-native-reanimated';

function App() {
  sv.value = withRepeat(withTiming(50), 5);
  // ...
}
```

Pass a number to the second parameter of the function to make it repeat a given number of times. You can make it repeat forever by passing a non-positive value (eg. `0` or `-1`). You can make the animation go back and forth by passing `true` to the third (i.e. `reverse`) argument.

To learn more about it you can check out the full `withRepeat` API reference.

Let's use this function in our example:

Expand the full code

```
export default function App() {
  const offset = useSharedValue<number>(0);

  const style = useAnimatedStyle(() => ({
    transform: [{ translateX: offset.value }],
  }));

  const OFFSET = 40;

  const handlePress = () => {
    offset.value = withRepeat(withTiming(OFFSET), 5, true);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, style]} />
      <Button title="shake" onPress={handlePress} />
    </View>
  );
}
```

When we run this code we can see that the box jiggles left to right between the set offset and a starting position. After the animation finishes the box doesn't come back to its initial place. It's not really how we imagined a shake animation but we'll get there in a second!

### Running animations in a sequence

One way to improve our animation is to start it with a left offset and reset it back to starting position after the animation ends. That's a perfect use case for the `withSequence` modifier.

```
import { withSequence } from 'react-native-reanimated';

function App() {
  sv.value = withSequence(withTiming(50), withTiming(0));
  // ...
}
```

This modifier lets you chain animations together. The next animation starts when the previous one ends. You use it by passing animations as arguments in the order you want them to run.

To learn more about it you can check out the full `withSequence` API reference.

Coming back to our example - we can utilize `withSequence` to improve our animation. First, we'll sway the box to the left which we'll make it to take half of the duration of one swing. Then, we'll shake the box 5 times and finish up the animation by bringing it to starting position also with half of the animation duration.

Expand the full code

```
  const TIME = 250;

  const handlePress = () => {
    offset.value = withSequence(
      // start from -OFFSET
      withTiming(-OFFSET, { duration: TIME / 2 }),
      // shake between -OFFSET and OFFSET 5 times
      withRepeat(withTiming(OFFSET, { duration: TIME }), 5, true),
      // go back to 0 at the end
      withTiming(0, { duration: TIME / 2 })
    );
  };
```

### Starting the animation with delay

As a cherry on top, we'll add a little bit of suspense by adding a slight delay before the animation begins. For this exact purpose, Reanimated comes with a `withDelay` modifier.

```
import { withDelay } from 'react-native-reanimated';

function App() {
  sv.value = withDelay(500, withTiming(0));
  // ...
}
```

This function as a first parameter takes the duration in milliseconds before the animation starts. The second parameter defines the animation to delay.

To learn more about it you can check out the full `withDelay` API reference.

Expand the full code

```
  const OFFSET = 40;
  const TIME = 250;
  const DELAY = 400;

  const handlePress = () => {
    offset.value = withDelay(
      DELAY,
      withSequence(
        // start from -OFFSET
        withTiming(-OFFSET, { duration: TIME / 2 }),
        // shake between -OFFSET and OFFSET 5 times
        withRepeat(withTiming(OFFSET, { duration: TIME }), 5, true),
        // go back to 0 at the end
        withTiming(0, { duration: TIME / 2 })
      )
    );
  };
```

### Summary

In this section, we learned how to create complex animations by using animation modifiers. To sum up:

- Reanimated comes with three built-in animation modifiers - `withRepeat`, `withSequence`, and `withDelay`.
- `withRepeat` lets you repeat an animation a given number of times or run it indefinitely.
- `withSequence` lets you run animations in a sequence.
- `withDelay` lets you start an animation with a delay.

### What's next?

In the next section, we're going to learn about handling `Tap` and `Pan` gestures. Also, we'll get to know the `withDecay` animation function.

##

## interpolate

`interpolate` lets you map a value from one range to another using linear interpolation.

### Reference

```
import { interpolate } from 'react-native-reanimated';

function App() {
  const animatedStyle = useAnimatedStyle(() => ({
    opacity: interpolate(sv.value, [0, 100], [0, 1], Extrapolation.CLAMP),
  }));
}
```

Type definitions

```
enum Extrapolation {
  IDENTITY = 'identity',
  CLAMP = 'clamp',
  EXTEND = 'extend',
}

type ExtrapolationAsString = 'identity' | 'clamp' | 'extend';

export type ExtrapolationType =
  | ExtrapolationConfig
  | Extrapolation
  | ExtrapolationAsString
  | undefined;

function interpolate(
  value: number,
  input: readonly number[],
  output: readonly number[],
  extrapolate?: ExtrapolationType
): number;
```

#### Arguments

##### `value`

A number that is going to be mapped to the `output` range.

##### `input`

An array of numbers specifying the input range of the interpolation.

##### `output`

An array of numbers specifying the output range of the interpolation. It should have at least the same number of points as the input range.

##### `extrapolate`Optional

The `extrapolate` parameter determines what happens when the `value` goes beyond the `input` range. Defaults to `Extrapolation.EXTEND`.

Available types:

- `Extrapolation.EXTEND` - predicts the values beyond the output range.
- `Extrapolation.CLAMP` - clamps the value to the edge of the output range.
- `Extrapolation.IDENTITY` - returns the provided value as is.

EXTEND

CLAMP

IDENTITY

This parameter also accepts string values:

- `"extend"`
- `"clamp"`
- `"identity"`

By default, the `extrapolate` parameter applies the value passed to both edges of the range. To specify extrapolation to a particular edge, you can pass an object:

```
const opacity = interpolate(
  sv.value,
  [0, 100],
  [0, 1],
  { extrapolateLeft: Extrapolation.CLAMP }
);
```

#### Returns

`interpolate` returns a mapped value within the output range.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

Version: 3.x

On this page

## clamp

`clamp` lets you limit a value within a specified range.

### Reference

```
import { clamp } from 'react-native-reanimated';

function App() {
  const result = clamp(sv.value, 0, 100);
}
```

Type definitions

```
function clamp(value: number, min: number, max: number): number;
```

#### Arguments

##### `value`

A number that will be returned as long as the provided value is in range between `min` and `max`.

##### `min`

A number which will be returned when provided `value` is lower than `min`.

##### `max`

A number which will be returned when provided `value` is higher than `max`.

#### Returns

`clamp` returns a number between `min` and `max` bounds.

### Example

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |

## interpolateColor

`interpolateColor` maps input range to output colors using linear interpolation.

### Reference

```
import { interpolateColor } from 'react-native-reanimated';

function App() {
  const progress = useSharedValue(0);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      backgroundColor: interpolateColor(
        progress.value,
        [0, 1],
        ['red', 'green']
      ),
    };
  });

  // ...

  return <Animated.View style={[{ width: 100, height: 100 }, animatedStyle]} />;
}
```

Type definitions

```
type InterpolationOptions = {
  gamma?: number;
  useCorrectedHSVInterpolation?: boolean;
};

function interpolateColor(
  value: number,
  input: number[],
  output: string[],
  colorSpace?: 'RGB' | 'HSV',
  options?: InterpolationOptions
): string;
```

#### Arguments

##### `value`

A number from the input range that is going to be mapped to the output range.

##### `input`

An array of numbers specifying the input range of the interpolation. Values in the input range should be increasing.

##### `output`

An array of output colors values in form of strings (like `'red'`, `'#ff0000'`, `'rgba(255, 0, 0, 0.5)'` etc.). It should have at least the same number of points as the input range.

##### `colorSpace`Optional

The color space to use for interpolation. Can be either `'HSV'` or `'RGB'`. Defaults to `'RGB'`.

##### `options`Optional

Color interpolation options. Allowed parameters:

| Options | Type | Default | Description |
| --- | --- | --- | --- |
| gammaOptional | `number` | 2.2 | Gamma parameter used in gamma correction. |
| useCorrectedHSVInterpolationOptional | `boolean` | true | Whether to reduce the number of colors the interpolation has to go through. |

##### Options explanation

- _gamma_ - Colors on web / mobile are expressed in sRGB colorspace which is gamma-corrected, that is non-linear. Operations on colors in non-linear space like addition will give wrong results. For example the interpolated color may appear darker than it should. That's why when interpolating we convert sRGB to linear space first and then convert the result back into non-linear sRGB space. Gamma correction is device-dependent but for most devices to convert from non-linear to linear space raising components to the power of gamma=2.2 is a good approximation. If you'd like to disable that you can always set gamma=1. A nice article on that if you'd like to know more: <https://observablehq.com/@sebastien/srgb-rgb-gamma>
- _useCorrectedHSVInterpolation_ - Sometimes (for example when interpolating from yellow to purple) HSV interpolation goes through many other hues. This option allows to reduce the number of hues in such cases by treating HSV hues like a circular spectrum and choosing the shortest arc (so instead of going from yellow to purple through green and blue, it goes only through red).

#### Returns

`interpolateColor` returns the color after interpolation from within the output range in `rgba(r, g, b, a)` format.

### Example

### Remarks

- It works just like `interpolate` function but the output is color string in `rgba(r, g, b, a)` notation.

### Platform compatibility

| Android | iOS | Web |
| ------- | --- | --- |
| ✅      | ✅  | ✅  |
