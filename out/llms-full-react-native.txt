# react-native

Welcome to your initial steps into React Native! If you're seeking instructions on getting started, they have been relocated to a dedicated section. Continue reading for an introduction covering documentation, Native Components, React, and more.

React Native is utilized by a diverse group of individuals, ranging from seasoned iOS developers to those new to React, as well as newcomers to programming in their careers. These documents are crafted to cater to learners at all levels of experience and backgrounds.

### How to Use These Docs

You have the flexibility to read through these documents sequentially like a book or focus on specific sections that interest you. If you're already familiar with React, feel free to skip that section—or revisit it for a quick refresher.

### Prerequisites

To work effectively with React Native, an understanding of JavaScript fundamentals is essential. For those new to JavaScript or in need of a refresher, the Mozilla Developer Network offers comprehensive resources.

> While we strive to assume no prior knowledge of React, Android, or iOS development, these areas are beneficial for aspiring React Native developers. Where appropriate, we have included links to additional resources and articles that delve deeper into these topics.

### Interactive Examples

This introduction allows you to begin immediately in your browser with interactive examples like the following:

The above example is a Snack Player—a tool developed by Expo designed to embed and run React Native projects, showcasing their rendering on platforms such as Android and iOS. The code is live and editable, enabling direct interaction within your browser. Feel free to modify the "Try editing me!" text above to "Hello, world!"

> Optionally, if you prefer setting up a local development environment, follow our guide for configuring it on your machine and integrate the code examples into your project. (Web developers might already have a local setup suitable for mobile browser testing!)

### Developer Notes

React Native attracts learners from various development backgrounds, including web, Android, and iOS technologies. We aim to address developers across these diverse fields. Occasionally, we provide platform-specific explanations as follows:

- **Android**
- **iOS**
- **Web**

> Android developers might recognize this concept.

> iOS developers might recognize this concept.

> Web developers might recognize this concept.

### Formatting

Menu paths are presented in bold and utilize carets for navigating submenus. Example: **Android Studio > Preferences**

***

With an understanding of how to navigate these guides, it's time to explore the foundation of React Native: Native Components.

## Animated

The `Animated` library is designed for creating fluid, powerful animations that are easy to build and maintain. It emphasizes declarative relationships between inputs and outputs, configurable transforms, and control over animation execution through `start`/`stop` methods.

### Core Workflow

To create an animation:

1. Create an `Animated.Value`.
1. Connect it to style attributes of an animated component.
1. Drive updates using animations like `Animated.timing()`.

> **Note:** Avoid modifying the animated value directly. Use the `useRef` Hook for a mutable ref object that persists throughout the component lifecycle.

### Example

Consider a `View` that fades in and out based on the animated value `fadeAnim`.

For more examples, refer to the Animations guide.

### Overview of Value Types

- **`Animated.Value()`**: For single values.
- **`Animated.ValueXY()`**: For vectors.

A single `Animated.Value` can drive multiple properties and bind to style or other props. It can also be interpolated.

#### Configuring Animations

Three types of animations are provided:

- **`Animated.decay()`**: Starts with an initial velocity, gradually slowing to a stop.
- **`Animated.spring()`**: Implements a basic spring physics model.
- **`Animated.timing()`**: Animates values over time using easing functions. Defaults to a symmetric easeInOut curve.

#### Working with Animations

Animations are controlled by calling `start()`, which accepts a completion callback:

```typescript
Animated.timing({}).start(({ finished }) => {
  /* completion callback */
})
```

#### Using the Native Driver

Enable native driver for smoother animations by specifying `useNativeDriver: true` in your animation configuration.

#### Animatable Components

Only animatable components can be animated. These components handle binding of animated values and perform targeted native updates:

- `Animated.Image`
- `Animated.ScrollView`
- `Animated.Text`
- `Animated.View`
- `Animated.FlatList`
- `Animated.SectionList`

Use `createAnimatedComponent()` to make a component animatable.

#### Composing Animations

Animations can be combined using composition functions:

- **`Animated.delay()`**: Starts an animation after a delay.
- **`Animated.parallel()`**: Runs animations simultaneously.
- **`Animated.sequence()`**: Executes animations in order.
- **`Animated.stagger()`**: Starts animations with successive delays.

By default, stopping one animation stops all others in the group.

#### Combining Animated Values

Combine animated values using operations like addition, subtraction, multiplication, division, or modulo:

- `Animated.add()`
- `Animated.subtract()`
- `Animated.divide()`
- `Animated.modulo()`
- `Animated.multiply()`

#### Interpolation

The `interpolate()` function maps input ranges to output ranges. More details are available on the separate page.

#### Advanced APIs

- **`forkEvent()`**: Adds a listener to an existing animated event.
- **`unforkEvent()`**: Removes a listener from an animated event.

#### Starting and Stopping Animations

- **`start(callback?: (result: {finished: boolean}) => void)`**: Begins the animation, optionally with a completion callback.

  ```typescript
  Animated.timing({}).start(({ finished }) => {
    /* completion callback */
  })
  ```

- **`stop()`**: Halts any running animation.

#### Resetting Animations

- **`reset()`**: Stops and resets the value to its original state.

### Properties

- **`Value`**: Standard class for driving animations.
- **`ValueXY`**: For 2D animations, like pan gestures.
- **`Interpolation`**: Type used in flow for interpolation.
- **`Node`**: Base class for animated values.
- **`createAnimatedComponent`**: Makes any React component animatable.
- **`attachNativeEvent`**: Attaches an animated value to a view event. Prefer `Animated.event` with `useNativeDriver: true`.

## Linking

Linking provides a unified interface for managing both incoming and outgoing app links. Each link (URL) is associated with a URL scheme, such as `https://` or `http://`, which serves as the scheme identifier.

### Built-in URL Schemes

Certain URL schemes are universally recognized across platforms:

|Scheme|Description|iOS|Android|
|-|-|-|-|
|`mailto`|Opens mail app, e.g., `mailto:support@expo.io`|✅|✅|
|`tel`|Opens phone app, e.g., `tel:+123456789`|✅|✅|
|`sms`|Opens SMS app, e.g., `sms:+123456789`|✅|✅|
|`https` / `http`|Opens web browser app, e.g., `https://expo.io`|✅|✅|

### Enabling Deep Links

#### Projects with Native Code Only

This section applies to projects with native code. For managed Expo workflow users, refer to the Expo documentation for Linking.

##### Android

To enable deep links:

- Add intent filters in `AndroidManifest.xml`.
- Set `launchMode` of `MainActivity` to `singleTask`.

```xml
<activity
  android:name=".MainActivity"
  android:launchMode="singleTask">
```

> **Note:** For iOS, include the `LinkingIOS` folder in your header search paths. To handle incoming app links during execution, add the following to `*AppDelegate.m`:

###### Objective-C

```objc
// iOS 9.x or newer
#import <React/RCTLinkingManager.h>

- (BOOL)application:(UIApplication *)application
   openURL:(NSURL *)url
   options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {
  return [RCTLinkingManager application:application openURL:url options:options];
}
```

###### Swift

```swift
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
  return RCTLinkingManager.application(app, open: url, options: options)
}
```

For Universal Links:

###### Objective-C

```objc
- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {
  return [RCTLinkingManager application:application continueUserActivity:userActivity restorationHandler:restorationHandler];
}
```

###### Swift

```swift
func application(
  _ application: UIApplication,
  continue userActivity: NSUserActivity,
  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
    return RCTLinkingManager.application(
      application,
      continue: userActivity,
      restorationHandler: restorationHandler
    )
}
```

### Handling Deep Links

There are two methods to handle URLs that open your app:

1. **Foreground App with Event**: If the app is already open, it foregrounds and fires a Linking 'url' event. Use `Linking.addEventListener('url', callback)` to handle these events.

1. **App Launch with URL**: If the app isn't open, it launches with the URL passed as `initialURL`. Handle this using `Linking.getInitialURL()`, which returns a Promise resolving to the URL if present.

### Reference

#### Methods

##### `addEventListener()`

```typescript
static addEventListener(
  type: 'url',
  handler: (event: { url: string }) => void,
): EmitterSubscription;
```

Adds an event listener for Linking changes by listening to the `url` event type and providing a handler.

##### `canOpenURL()`

```typescript
static canOpenURL(url: string): Promise<boolean>;
```

Determines if an installed app can handle a given URL. Returns a Promise resolving to a boolean indicating whether the URL can be opened.

**Parameters:**

- **urlRequired**: The URL to check.

> For web URLs, ensure the protocol (`"http://"`, `"https://"`).

##### `getInitialURL()`

```typescript
static getInitialURL(): Promise<string | null>;
```

Returns the app launch URL if triggered by an app link; otherwise, returns `null`.

##### `openSettings()`

```typescript
static openSettings(): Promise<void>;
```

Opens the Settings app to display the app’s custom settings.

##### `openURL()`

```typescript
static openURL(url: string): Promise<any>;
```

Attempts to open a given URL with any installed apps. Returns a Promise resolving if successful or rejecting otherwise.

**Parameters:**

- **urlRequired**: The URL to open.

> Ensure the protocol is set for web URLs (`"http://"`, `"https://"`).

##### `sendIntent()` (Android)

```typescript
static sendIntent(
  action: string,
  extras?: Array<{ key: string; value: string | number | boolean }>,
): Promise<void>;
```

Launches an Android intent with optional extras.

**Parameters:**

- **actionRequired**: The action to perform.
- **extras**: Optional array of key-value pairs for additional data.

## ActionSheetIOS

Displays native to iOS Action Sheet component.

### Example

### Reference

### Methods

#### `showActionSheetWithOptions()`

```typescript
static showActionSheetWithOptions: (
  options: ActionSheetIOSOptions,
  callback: (buttonIndex: number) => void,
);
```

Display an iOS action sheet. The `options` object must contain one or more of:

- `options`: Array of strings - a list of button titles (required)
- `cancelButtonIndex`: Integer - index of cancel button in `options`
- `cancelButtonTintColor`: String - the color used for changing the text color of the cancel button
- `destructiveButtonIndex`: Integer or array of integers - indices of destructive buttons in `options`
- `title`: String - a title to show above the action sheet
- `message`: String - a message to show below the title
- `anchor`: Number - the node to which the action sheet should be anchored (used for iPad)
- `tintColor`: String - the color used for non-destructive button titles
- `disabledButtonIndices`: Array of numbers - a list of button indices which should be disabled
- `userInterfaceStyle`: String - the interface style used for the action sheet, can be set to `light` or `dark`, otherwise the default system style will be used

The 'callback' function takes one parameter, the zero-based index of the selected item.

Minimal example:

```typescript
ActionSheetIOS.showActionSheetWithOptions(
  {
    options: ["Cancel", "Remove"],
    destructiveButtonIndex: 1,
    cancelButtonIndex: 0,
  },
  (buttonIndex) => {
    if (buttonIndex === 1) {
      /* destructive action */
    }
  }
)
```

#### `dismissActionSheet()`

```typescript
static dismissActionSheet();
```

Dismisses the most upper iOS action sheet presented. If no action sheet is present, a warning is displayed.

#### `showShareActionSheetWithOptions()`

```typescript
static showShareActionSheetWithOptions: (
  options: ShareActionSheetIOSOptions,
  failureCallback: (error: Error) => void,
  successCallback: (success: boolean, method: string) => void,
);
```

Display the iOS share sheet. The `options` object should contain one or both of `message` and `url`, and can additionally have a `subject` or `excludedActivityTypes`:

- `url`: String - a URL to share
- `message`: String - a message to share
- `subject`: String - a subject for the message
- `excludedActivityTypes`: Array - the activities to exclude from the ActionSheet

> **Note:** If `url` points to a local file, or is a base64-encoded URI, the file it points to will be loaded and shared directly. In this way, you can share images, videos, PDF files, etc. If `url` points to a remote file or address, it must conform to URL format as described in RFC 2396. For example, a web URL without a proper protocol (HTTP/HTTPS) will not be shared.

The 'failureCallback' function takes one parameter, an error object. The only property defined on this object is an optional `stack` property of type `string`.

The 'successCallback' function takes two parameters:

- A boolean value signifying success or failure
- A string that, in the case of success, indicates the method of sharing

## Cross-Language Communication in React Native

React Native allows integration with existing apps by embedding it within native components and vice versa. This guide summarizes techniques to facilitate communication between native and React Native components.

### Introduction

Inspired by React, React Native follows a one-directional information flow where data is passed from parent to child components using properties. When integrating React Native with native components, specific cross-language mechanisms are required for effective communication.

#### Properties

Properties serve as the primary method of cross-component communication, allowing data transfer between native and React Native components in both directions.

##### Passing Properties from Native to React Native

To pass properties from a native component to React Native, implement `ReactActivityDelegate` in your main activity. Override `getLaunchOptions` to return a `Bundle` with the desired properties.

**Java Example:**

```java
public class MainActivity extends ReactActivity {
  @Override
  protected ReactActivityDelegate createReactActivityDelegate() {
    return new ReactActivityDelegate(this, getMainComponentName()) {
      @Override
      protected Bundle getLaunchOptions() {
        Bundle initialProperties = new Bundle();
        ArrayList<String> imageList = new ArrayList<>(Arrays.asList(
                "https://dummyimage.com/600x400/ffffff/000000.png",
                "https://dummyimage.com/600x400/000000/ffffff.png"
        ));
        initialProperties.putStringArrayList("images", imageList);
        return initialProperties;
      }
    };
  }
}
```

**Kotlin Example:**

```kotlin
class MainActivity : ReactActivity() {
    override fun createReactActivityDelegate(): ReactActivityDelegate {
        return object : ReactActivityDelegate(this, mainComponentName) {
            override fun getLaunchOptions(): Bundle {
                val imageList = arrayListOf(
                    "https://dummyimage.com/600x400/ffffff/000000.png",
                    "https://dummyimage.com/600x400/000000/ffffff.png"
                )
                return Bundle().apply { putStringArrayList("images", imageList) }
            }
        }
    }
}
```

**React Native Example:**

```javascript
import React from "react"
import { View, Image } from "react-native"

export default class ImageBrowserApp extends React.Component {
  renderImage(imgURI) {
    return <Image source={{ uri: imgURI }} />
  }

  render() {
    return <View>{this.props.images.map(this.renderImage)}</View>
  }
}
```

`ReactRootView` provides a `appProperties` property that can be updated to re-render the React Native app with new properties. Ensure updates occur on the main thread.

**Java Update Example:**

```java
Bundle updatedProps = mReactRootView.getAppProperties();
ArrayList<String> imageList = new ArrayList<>(Arrays.asList(
        "https://dummyimage.com/600x400/ff0000/000000.png",
        "https://dummyimage.com/600x400/ffffff/ff0000.png"
));
updatedProps.putStringArrayList("images", imageList);
mReactRootView.setAppProperties(updatedProps);
```

**Kotlin Update Example:**

```kotlin
var updatedProps: Bundle = reactRootView.getAppProperties()
val imageList = arrayListOf(
    "https://dummyimage.com/600x400/ff0000/000000.png",
    "https://dummyimage.com/600x400/ffffff/ff0000.png"
)
```

> **Note:** The `componentWillUpdateProps` function is not called after a prop update. Access new props in the `componentDidMount` function.

##### Passing Properties from React Native to Native

Expose native component properties using setter methods annotated with `@ReactProp`. These can be used as if they were regular React Native components.

#### Limits of Properties

Properties do not support callbacks for bottom-up data bindings, limiting their use in scenarios where a JS action should trigger changes in the native parent view. Cross-language callbacks exist but are not intended to be passed as properties; instead, they allow triggering native actions from JS and handling results within JS.

### Other Ways of Cross-Language Interaction (Events and Native Modules)

For more flexible communication beyond properties, React Native offers events and native modules for both internal and external interactions.

#### Calling React Native Functions from Native (Events)

Events enable executing handlers in JS without needing component references. However, they can introduce dependencies, potential name collisions, and require identifiers to distinguish between multiple instances of the same component.

#### Calling Native Functions from React Native (Native Modules)

Native modules are Java/Kotlin classes accessible in JS, allowing arbitrary functions and constants to be exported. Each module instance is created per JS bridge, but all share the same namespace, necessitating caution against name collisions.

> **Warning:** Be mindful of shared namespaces when creating new native modules.

## Cross-Language Communication in React Native

React Native allows for seamless integration with native components. This guide explores techniques to facilitate communication between React Native and native code.

### Introduction

Inspired by React, React Native follows a unidirectional data flow where components depend on their parent's properties or internal state. When integrating native components, specific mechanisms are required to enable cross-language communication.

#### Properties

Properties serve as the primary method for passing information between native and React Native components.

##### Passing Properties from Native to React Native

To embed a React Native view within a native component, use `RCTRootView`, which acts as an interface. You can pass properties using its initializer:

```objective-c
NSArray *imageList = @[@"https://dummyimage.com/600x400/ffffff/000000.png",
                       @"https://dummyimage.com/600x400/000000/ffffff.png"];

NSDictionary *props = @{@"images" : imageList};

RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge
                                                 moduleName:@"ImageBrowserApp"
                                          initialProperties:props];
```

In React Native, these properties can be accessed as follows:

```typescript
import React from 'react';
import { View, Image } from 'react-native';

export default class ImageBrowserApp extends React.Component {
  renderImage(imgURI) {
    return <Image source={{ uri: imgURI }} />;
  }

  render() {
    return (
      <View>
        {this.props.images.map(this.renderImage)}
      </View>
    );
  }
}
```

`RCTRootView` also supports updating properties via `appProperties`, which triggers a re-render when changes occur. Ensure updates are performed on the main thread.

##### Passing Properties from React Native to Native

Expose native component properties using the `RCT_CUSTOM_VIEW_PROPERTY` macro, allowing them to be used in React Native as standard components.

#### Limits of Properties

Properties lack support for callbacks, limiting bottom-up data binding. For instance, removing a React Native view based on JS actions requires alternative mechanisms.

### Other Ways of Cross-Language Interaction (Events and Native Modules)

For more complex interactions, consider using events or native modules:

#### Calling React Native Functions from Native (Events)

Events allow triggering JavaScript functions without direct references to components. However, they can introduce dependencies and potential name collisions. Use the `reactTag` as an identifier for distinguishing between multiple instances.

#### Calling Native Functions from React Native (Native Modules)

Native modules expose Objective-C classes in JavaScript, allowing function calls across languages. They are singletons per JS bridge, requiring identifiers to manage multiple native views.

### Layout Computation Flow

Integrating different layout systems requires careful management:

#### Layout of a Native Component Embedded in React Native

Most style and size attributes work as expected since native react views subclass `UIView`.

#### Layout of a React Native Component Embedded in Native

##### Fixed Size Content

For fixed-size content, set the frame explicitly. Use Flexbox to ensure content fits within bounds.

```objective-c
- (void)viewDidLoad {
  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge
                                                   moduleName:appName
                                            initialProperties:props];
  rootView.frame = CGRectMake(0, 0, self.view.width, 200);
  [self.view addSubview:rootView];
}
```

##### Flexible Size Content

For dynamic sizes, use `ScrollView` or `RCTRootView`'s flexibility modes to adjust layout based on content size.

```objective-c
- (instancetype)initWithFrame:(CGRect)frame {
  _rootView = [[RCTRootView alloc] initWithBridge:bridge
                                      moduleName:@"FlexibilityExampleApp"
                               initialProperties:@{}];
  _rootView.delegate = self;
  _rootView.sizeFlexibility = RCTRootViewSizeFlexibilityHeight;
  _rootView.frame = CGRectMake(0, 0, self.frame.size.width, 0);
}

#pragma mark - RCTRootViewDelegate
- (void)rootViewDidChangeIntrinsicSize:(RCTRootView *)rootView {
  CGRect newFrame = rootView.frame;
  newFrame.size = rootView.intrinsicContentSize;
  rootView.frame = newFrame;
}
```

#### Notes

React Native's layout calculations occur on a separate thread, potentially causing temporary UI inconsistencies. Synchronize updates to maintain consistency.

By understanding these techniques, you can effectively manage communication and layout between React Native and native components.

## Color Reference

In React Native, components are styled using JavaScript. The color properties generally align with how CSS functions on the web. Below are general guidelines for color usage across different platforms:

- Android
- iOS

### Color APIs

React Native offers several color APIs to leverage platform-specific design and user preferences:

- `PlatformColor` allows referencing the platform's color system.
- `DynamicColorIOS`, specific to iOS, enables specifying colors for Light or Dark Mode.

### Color Representations

#### Red Green Blue (RGB)

React Native supports both hexadecimal and functional notation for `rgb()` and `rgba()`:

- Hexadecimal: `#f0f` (#rgb), `#ff00ff` (#rrggbb), `#f0ff` (#rgba), `#ff00ff00` (#rrggbbaa)
- Functional: `'rgb(255, 0, 255)'`, `'rgb(255 0 255)'`, `'rgba(255, 0, 255, 1.0)'`, `'rgba(255 0 255 / 1.0)'`

#### Hue Saturation Lightness (HSL)

React Native supports `hsl()` and `hsla()` in functional notation:

- Functional: `'hsl(360, 100%, 100%)'`, `'hsl(360 100% 100%)'`, `'hsla(360, 100%, 100%, 1.0)'`, `'hsla(360 100% 100% / 1.0)'`

#### Hue Whiteness Blackness (HWB)

React Native supports `hwb()` in functional notation:

- Functional: `'hwb(0, 0%, 100%)'`, `'hwb(360, 100%, 100%)'`, `'hwb(0 0% 0%)'`, `'hwb(70 50% 0%)'`

#### Color Integers

React Native also supports colors as integer values in RGB color mode:

- Integer: `0xff00ff00` (0xrrggbbaa)

> **Caution:** This is similar to Android's Color integers but differs as Android uses SRGB color mode (0xaarrggbb).

#### Named Colors

React Native allows using lowercase string names for colors. Uppercase names are not supported.

##### `transparent`

This acts as a shortcut for `rgba(0,0,0,0)`, similar to CSS3.

##### Color Keywords

Named colors in React Native follow the CSS3/SVG specification:

- aliceblue (`#f0f8ff`)
- antiquewhite (`#faebd7`)
- aqua (`#00ffff`)
- aquamarine (`#7fffd4`)
- azure (`#f0ffff`)
- beige (`#f5f5dc`)
- bisque (`#ffe4c4`)
- black (`#000000`)
- blanchedalmond (`#ffebcd`)
- blue (`#0000ff`)
- blueviolet (`#8a2be2`)
- brown (`#a52a2a`)
- burlywood (`#deb887`)
- cadetblue (`#5f9ea0`)
- chartreuse (`#7fff00`)
- chocolate (`#d2691e`)
- coral (`#ff7f50`)
- cornflowerblue (`#6495ed`)
- cornsilk (`#fff8dc`)
- crimson (`#dc143c`)
- cyan (`#00ffff`)
- darkblue (`#00008b`)
- darkcyan (`#008b8b`)
- darkgoldenrod (`#b8860b`)
- darkgray (`#a9a9a9`)
- darkgreen (`#006400`)
- darkgrey (`#a9a9a9`)
- darkkhaki (`#bdb76b`)
- darkmagenta (`#8b008b`)
- darkolivegreen (`#556b2f`)
- darkorange (`#ff8c00`)
- darkorchid (`#9932cc`)
- darkred (`#8b0000`)
- darksalmon (`#e9967a`)
- darkseagreen (`#8fbc8f`)
- darkslateblue (`#483d8b`)
- darkslategrey (`#2f4f4f`)
- darkturquoise (`#00ced1`)
- darkviolet (`#9400d3`)
- deeppink (`#ff1493`)
- deepskyblue (`#00bfff`)
- dimgray (`#696969`)
- dimgrey (`#696969`)
- dodgerblue (`#1e90ff`)
- firebrick (`#b22222`)
- floralwhite (`#fffaf0`)
- forestgreen (`#228b22`)
- fuchsia (`#ff00ff`)
- gainsboro (`#dcdcdc`)
- ghostwhite (`#f8f8ff`)
- gold (`#ffd700`)
- goldenrod (`#daa520`)
- gray (`#808080`)
- green (`#008000`)
- greenyellow (`#adff2f`)
- grey (`#808080`)
- honeydew (`#f0fff0`)
- hotpink (`#ff69b4`)
- indianred (`#cd5c5c`)
- indigo (`#4b0082`)
- ivory (`#fffff0`)
- khaki (`#f0e68c`)
- lavender (`#e6e6fa`)
- lavenderblush (`#fff0f5`)
- lawngreen (`#7cfc00`)
- lemonchiffon (`#fffacd`)
- lightblue (`#add8e6`)
- lightcoral (`#f08080`)
- lightcyan (`#e0ffff`)
- lightgoldenrodyellow (`#fafad2`)
- lightgray (`#d3d3d3`)
- lightgreen (`#90ee90`)
- lightgrey (`#d3d3d3`)
- lightpink (`#ffb6c1`)
- lightsalmon (`#ffa07a`)
- lightseagreen (`#20b2aa`)
- lightskyblue (`#87cefa`)
- lightslategrey (`#778899`)
- lightsteelblue (`#b0c4de`)
- lightyellow (`#ffffe0`)
- lime (`#00ff00`)
- limegreen (`#32cd32`)
- linen (`#faf0e6`)
- magenta (`#ff00ff`)
- maroon (`#800000`)
- mediumaquamarine (`#66cdaa`)
- mediumblue (`#0000cd`)
- mediumorchid (`#ba55d3`)
- mediumpurple (`#9370db`)
- mediumseagreen (`#3cb371`)
- mediumslateblue (`#7b68ee`)
- mediumspringgreen (`#00fa9a`)
- mediumturquoise (`#48d1cc`)
- mediumvioletred (`#c71585`)
- midnightblue (`#191970`)
- mintcream (`#f5fffa`)
- mistyrose (`#ffe4e1`)
- moccasin (`#ffe4b5`)
- navajowhite (`#ffdead`)
- navy (`#000080`)
- oldlace (`#fdf5e6`)
- olive (`#808000`)
- olivedrab (`#6b8e23`)
- orange (`#ffa500`)
- orangered (`#ff4500`)
- orchid (`#da70d6`)
- palegoldenrod (`#eee8aa`)
- palegreen (`#98fb98`)
- paleturquoise (`#afeeee`)
- palevioletred (`#db7093`)
- papayawhip (`#ffefd5`)
- peachpuff (`#ffdab9`)
- peru (`#cd853f`)
- pink (`#ffc0cb`)
- plum (`#dda0dd`)
- powderblue (`#b0e0e6`)
- purple (`#800080`)
- rebeccapurple (`#663399`)
- red (`#ff0000`)
- rosybrown (`#bc8f8f`)
- royalblue (`#4169e1`)
- saddlebrown (`#8b4513`)
- salmon (`#fa8072`)
- sandybrown (`#f4a460`)
- seagreen (`#2e8b57`)
- seashell (`#fff5ee`)
- sienna (`#a0522d`)
- silver (`#c0c0c0`)
- skyblue (`#87ceeb`)
- slateblue (`#6a5acd`)
- slategray (`#708090`)
- snow (`#fffafa`)
- springgreen (`#00ff7f`)
- steelblue (`#4682b4`)
- tan (`#d2b48c`)
- teal (`#008080`)
- thistle (`#d8bfd8`)
- tomato (`#ff6347`)
- turquoise (`#40e0d0`)
- violet (`#ee82ee`)
- wheat (`#f5deb3`)
- white (`#ffffff`)
- whitesmoke (`#f5f5f5`)
- yellow (`#ffff00`)
- yellowgreen (`#9acd32`)

## ActivityIndicator

Displays a circular loading indicator.

### Example

### Reference

### Properties

#### Inherited from View

The `ActivityIndicator` inherits properties from the `View`.

#### `animating`

Determines if the indicator is visible (`true`) or hidden (`false`).

- **Type**: `bool`
- **Default**: `true`

#### `color`

Sets the color of the spinner.

- **Type**: `color`
- **Default**:
  - General: `null` (system accent default)
  - Android: `'#999999'`
  - iOS: Inherits system accent default

#### `hidesWhenStopped` (iOS Only)

Controls whether the indicator is hidden when not animating.

- **Type**: `bool`
- **Default**: `true`

#### `size`

Specifies the size of the indicator.

- **Type**:
  - Enum: `'small'`, `'large'` for iOS
  - Number for Android
- **Default**: `'small'`

### Example

```typescript
// Example usage of ActivityIndicator with props
<ActivityIndicator
  animating={true}
  color={'#FF0000'}
  hidesWhenStopped={false}
  size={'large'}
/>
```

### Props Summary

- Inherited from View
- `animating`
- `color`
- `hidesWhenStopped` (iOS)
- `size`

## Button

The Button component is designed to render consistently across different platforms, offering a basic level of customization. If the default appearance does not meet your needs, consider creating a custom button using Pressable. For guidance, refer to the source code of the Button component.

```typescript
<Button
  onPress={onPressLearnMore}
  title="Learn More"
  color="#841584"
  accessibilityLabel="Learn more about this purple button"
/>
```

### Example

### Reference

### Props

|Prop Name|Description|Type|Required|
|-|-|-|-|
|**`onPress`**|Handler called when the user taps the button.|`({nativeEvent: PressEvent})`|Yes|
|**`title`**|Text displayed inside the button. On Android, this title is converted to uppercase.|string|Yes|
|`accessibilityLabel`|Text for blindness accessibility features.|string|No|
|`accessibilityLanguage`|Language used by screen readers on iOS, following BCP 47 specification.|string|No|
|`accessibilityActions`|List of actions for assistive technologies to invoke programmatically.|array|No|
|`onAccessibilityAction`|Invoked when an accessibility action is performed by the user.|function|No|
|`color`|Text color on iOS, background color on Android.|color|No|
||Default:|||
||- Android: `'#2196F3'`|||
||- iOS: `'#007AFF'`|||
|`disabled`|Disables all interactions if set to true.|bool|No|
||Default:|||
||- false|||
|`hasTVPreferredFocus`|Indicates TV preferred focus.|bool|No|
||Default:|||
||- false|||
|`nextFocusDown`|Next view to receive focus when navigating down on Android TV.|number|No|
|`nextFocusForward`|Next view to receive focus when navigating forward on Android TV.|number|No|
|`nextFocusLeft`|Next view to receive focus when navigating left on Android TV.|number|No|
|`nextFocusRight`|Next view to receive focus when navigating right on Android TV.|number|No|
|`nextFocusUp`|Next view to receive focus when navigating up on Android TV.|number|No|
|`testID`|Identifier for locating this view in end-to-end tests.|string|No|
|`touchSoundDisabled`|Disables system sound on touch if set to true (Android only).|boolean|No|
||Default:|||
||- false|||

This table summarizes the properties available for the Button component, detailing their purpose and default values where applicable.

## Image

To integrate image handling capabilities in your React Native application, you can utilize the `<Image />` component along with various methods and properties provided for efficient image management. Below is an overview of how to use these features effectively:

#### Adding Image Support

1. **Install Required Libraries:**

   - For GIF support on Android, ensure you have `react-native-gesture-handler`.
   - For WebP support on iOS, bundle the JavaScript code with your app.

1. **Configure Build Files:**

   - Add dependencies in `android/build.gradle` and `android/app/build.gradle`.

1. **Modify Native Code:**
   - Update `MainApplication.java` to include necessary packages.
   - Modify `settings.gradle` to include new modules like `react-native-gesture-handler`.

#### Using the `<Image />` Component

The `<Image />` component in React Native allows you to display images from various sources. Here’s how you can use it:

```jsx
import React from "react"
import { Image, StyleSheet } from "react-native"

const MyComponent = () => (
  <Image
    source={{ uri: "https://example.com/image.png" }}
    style={styles.image}
    resizeMode="contain"
  />
)

const styles = StyleSheet.create({
  image: {
    width: 200,
    height: 100,
  },
})

export default MyComponent
```

#### Key Properties

- **`source`**: Can be a URI, local file path, or static resource. Supports multiple formats like PNG, JPEG, GIF, and WebP.
- **`style`**: Apply styles such as width, height, and transformations.
- **`resizeMode`**: Controls how the image should resize to fit its container (e.g., `contain`, `cover`).
- **`tintColor`**: Changes the color of non-transparent pixels.

#### Methods for Image Management

1. **Prefetching Images:**

   ```javascript
   import { Image } from "react-native"

   const prefetchImage = async () => {
     try {
       await Image.prefetch("https://example.com/image.png")
       console.log("Image prefetched successfully!")
     } catch (error) {
       console.error("Error prefetching image:", error)
     }
   }
   ```

1. **Querying Cache:**

   ```javascript
   const checkCache = async () => {
     try {
       const cacheStatus = await Image.queryCache([
         "https://example.com/image.png",
       ])
       console.log(cacheStatus)
     } catch (error) {
       console.error("Error querying cache:", error)
     }
   }
   ```

1. **Getting Image Size:**
   ```javascript
   const getImageSize = async () => {
     try {
       const { width, height } = await Image.getSize(
         "https://example.com/image.png",
         (width, height) => console.log(`Image size is ${width}x${height}`)
       )
     } catch (error) {
       console.error("Error getting image size:", error)
     }
   }
   ```

#### Advanced Features

- **`srcSet`**: Allows specifying multiple image sources for different resolutions.
- **Cache Control**: Use `cache` property in `source` to manage caching behavior.

By leveraging these features, you can efficiently handle images in your React Native application, ensuring optimal performance and user experience.

## PanResponder

The `PanResponder` component in React Native helps manage touch gestures by consolidating multiple touches into a single gesture. It ensures that single-touch gestures remain unaffected by additional touches and can recognize basic multi-touch gestures.

By default, `PanResponder` uses an `InteractionManager` to prevent long-running JavaScript events from interrupting active gestures. It provides a consistent interface for responder handlers within the gesture responder system. Each handler receives a new `gestureState` object along with the native event:

```typescript
onPanResponderMove: (event, gestureState) => {}
```

A native event is a synthetic touch event of type `PressEvent`.

The `gestureState` object includes:

- `stateID`: ID of the gesture state, which persists as long as there's at least one touch on screen.
- `moveX`: Latest X coordinate of the recently moved touch.
- `moveY`: Latest Y coordinate of the recently moved touch.
- `x0`: Initial X coordinate when the responder was granted.
- `y0`: Initial Y coordinate when the responder was granted.
- `dx`: Accumulated distance in the X direction since the gesture started.
- `dy`: Accumulated distance in the Y direction since the gesture started.
- `vx`: Current velocity of the gesture in the X direction.
- `vy`: Current velocity of the gesture in the Y direction.
- `numberActiveTouches`: Number of touches currently on screen.

### Usage Pattern

```typescript
const ExampleComponent = () => {
  const panResponder = React.useRef(
    PanResponder.create({
      // Ask to be the responder:
      onStartShouldSetPanResponder: (evt, gestureState) => true,
      onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
      onMoveShouldSetPanResponder: (evt, gestureState) => true,
      onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,

      onPanResponderGrant: (evt, gestureState) => {
        // The gesture has started. Show visual feedback to the user.
        // gestureState.dx and gestureState.dy will be set to zero now
      },
      onPanResponderMove: (evt, gestureState) => {
        // Use gestureState.moveX and gestureState.moveY for recent move distance
        // Use gestureState.dx and gestureState.dy for accumulated gesture distance
      },
      onPanResponderTerminationRequest: (evt, gestureState) => true,
      onPanResponderRelease: (evt, gestureState) => {
        // The user has released all touches while this view is the responder.
        // This typically means a gesture has succeeded
      },
      onPanResponderTerminate: (evt, gestureState) => {
        // Another component has become the responder; cancel this gesture
      },
      onShouldBlockNativeResponder: (evt, gestureState) => true,
    })
  ).current;

  return <View {...panResponder.panHandlers} />;
};
```

### Example

`PanResponder` can be used with the `Animated` API to create complex gestures in the UI. For instance, an animated `View` component can be dragged freely across the screen.

Try the PanResponder example in RNTester.

### Reference

#### Methods

##### `create()`

```typescript
static create(config: PanResponderCallbacks): PanResponderInstance;
```

**Parameters:**

|Name|Type|Description|
|-|-|-|
|configRequired|object|Refer below|

The `config` object provides enhanced versions of all responder callbacks, including the `PanResponder` gesture state. Replace `onResponder*` with `onPanResponder*`. For example:

- `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
- `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
- `onStartShouldSetPanResponder: (e, gestureState) => {...}`
- `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
- `onPanResponderReject: (e, gestureState) => {...}`
- `onPanResponderGrant: (e, gestureState) => {...}`
- `onPanResponderStart: (e, gestureState) => {...}`
- `onPanResponderEnd: (e, gestureState) => {...}`
- `onPanResponderRelease: (e, gestureState) => {...}`
- `onPanResponderMove: (e, gestureState) => {...}`
- `onPanResponderTerminate: (e, gestureState) => {...}`
- `onPanResponderTerminationRequest: (e, gestureState) => {...}`
- `onShouldBlockNativeResponder: (e, gestureState) => {...}`

For events with capture equivalents, the gesture state is updated once in the capture phase and can be used in the bubble phase. Be cautious with `onStartShould*` callbacks; they only reflect updated `gestureState` for start/end events that bubble/capture to the Node. Once a node becomes the responder, every start/end event updates the `gestureState`. Note that `numberActiveTouches` may not always be accurate unless you are the responder.

## Installing dependencies

To develop a React Native app, ensure you have Node, Watchman, the React Native CLI, a JDK, and Android Studio installed. While any editor can be used for development, Android Studio is necessary for setting up the Android build environment.

### Node & Watchman

Install Node and Watchman using Homebrew with these commands:

```shell
brew install node
brew install watchman
```

Ensure your Node version is 18.18 or newer if already installed. Watchman, a filesystem monitoring tool by Facebook, enhances performance and is recommended for installation.

### Java Development Kit (JDK)

Install the OpenJDK distribution Azul Zulu using Homebrew:

```shell
brew install --cask zulu@17

# Find the JDK installer path
brew info --cask zulu@17
```

After locating the package, double-click `Double-Click to Install Azul Zulu JDK 17.pkg` in Finder. Set or update your `JAVA_HOME` environment variable:

```shell
export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
```

Zulu OpenJDK supports both Intel and M1 Macs, optimizing build speeds on M1 devices. If a JDK is already installed, use version 17 to avoid compatibility issues.

### Android Development Environment

Setting up the Android development environment can be complex for newcomers but straightforward if familiar with Android development. Follow these steps:

#### 1. Install Android Studio

Download and install Android Studio, ensuring you select `Android SDK`, `Android SDK Platform`, and `Android Virtual Device` during installation. If checkboxes are unavailable, they will appear later.

After setup, proceed to the next step upon reaching the Welcome screen.

#### 2. Install the Android SDK

By default, Android Studio installs the latest Android SDK. For React Native apps with native code, install the `Android 15 (VanillaIceCream)` SDK via the SDK Manager in Android Studio:

- Open Android Studio and select "More Actions" > "SDK Manager".

- In the "SDK Platforms" tab, enable "Show Package Details", then expand `Android 15 (VanillaIceCream)`. Ensure these are checked:

  - `Android SDK Platform 35`
  - `Intel x86 Atom_64 System Image` or `Google APIs Intel x86 Atom System Image` or for M1 Silicon: `Google APIs ARM 64 v8a System Image`

- In the "SDK Tools" tab, enable "Show Package Details", expand "Android SDK Build-Tools", and select version `35.0.0`.

- Click "Apply" to install.

#### 3. Configure the ANDROID\_HOME Environment Variable

Set up necessary environment variables for React Native tools:

```shell
export ANDROID_HOME=$HOME/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/emulator
export PATH=$PATH:$ANDROID_HOME/platform-tools
```

Load these settings with `source ~/.zprofile` (or `source ~/.bash_profile` for bash). Verify by running `echo $ANDROID_HOME` and `echo $PATH`.

Ensure the correct Android SDK path is used, which can be found in Android Studio under **Languages & Frameworks** → **Android SDK**.

### Preparing the Android Device

To run your React Native app on Android, use either a physical device or an Android Virtual Device (AVD).

#### Using a Physical Device

Connect your Android device via USB and follow setup instructions for development.

#### Using a Virtual Device

Open `./AwesomeProject/android` in Android Studio to access AVDs. If needed, create a new AVD by selecting "Create Virtual Device...", choosing any Phone model, then the **VanillaIceCream** API Level 35 image. Launch your AVD with the green triangle button.

### Congratulations!

You've successfully set up your development environment for React Native on Android.

#### Next Steps

- For integrating React Native into an existing app, refer to the Integration guide.
- To learn more about React Native, explore the Introduction to React Native.

## Installing Dependencies (iOS)

For iOS development with React Native, ensure you have Node, Watchman, Xcode, and CocoaPods installed. While any editor can be used for coding, Xcode is essential for building your app.

### Node & Watchman

Install Node and Watchman using Homebrew:

```shell
brew install node
brew install watchman
```

Ensure Node version 18.18 or newer if already installed. Watchman improves performance by monitoring filesystem changes.

### Xcode

Use the latest version of Xcode, available via the Mac App Store. This installs the iOS Simulator and necessary tools for building your app.

#### Command Line Tools

Install Xcode Command Line Tools from **Xcode > Settings...** under the Locations panel.

#### Installing an iOS Simulator in Xcode

Access simulators through **Xcode > Settings... > Platforms (or Components)** tab, selecting a simulator with the desired iOS version. For Xcode 14.0 or newer, use the "+" icon and select "iOS…".

### CocoaPods

CocoaPods is a dependency management system for iOS, installable via Ruby gem using macOS's default Ruby.

For more details, visit the CocoaPods Getting Started guide.

#### Optional: Configuring Your Environment

From React Native 0.69 onwards, configure Xcode with the `.xcode.env` file provided by the template. Set the `NODE_BINARY` variable to your Node executable path for decoupling from system Node versions. Add other environment variables as needed and source `.xcode.env` in build script phases.

If using NVM (Node Version Manager) with zsh, move NVM initialization code from `~/.zshrc` to `~/.zshenv`:

```shell
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
```

Ensure all "shell script build phase" in Xcode uses `/bin/zsh`.

### Congratulations!

You've successfully set up your iOS development environment for React Native.

#### Next Steps

- For integrating React Native into an existing app, refer to the Integration guide.
- To learn more about React Native, explore the Introduction to React Native.

## ImageBackground

The `<ImageBackground>` component is designed for developers who are accustomed to using `background-image` in web development. It functions similarly to the `<Image>` component, allowing you to layer additional content on top of an image.

### Considerations

While `<ImageBackground>` provides basic functionality, it may not be suitable for all use cases. Developers are encouraged to review its source code and consider creating a custom component if necessary.

**Note:** It is essential to define width and height style attributes when using this component.

### Example Usage

*Example section would typically include a demonstration of how to implement the `<ImageBackground>` component.*

### Reference

*Reference section would provide additional resources or links for further information about the `<ImageBackground>` component.*

### Props

#### Image Props

The `<ImageBackground>` inherits all props from the `<Image>` component.

#### `imageStyle`

- **Type:** Image Style
- Description: Customizes the style of the image within the background.

#### `imageRef`

- **Type:** Ref
- Description: Allows setting a reference to the inner `Image` component for direct manipulation or access.

#### `style`

- **Type:** View Style
- Description: Applies styling to the view that contains the `<ImageBackground>`.

## KeyboardAvoidingView

The `KeyboardAvoidingView` component automatically adjusts its height, position, or bottom padding based on the keyboard's height to ensure it remains visible when the virtual keyboard is displayed.

### Example

***

### Reference

### Props

#### View Props

Inherits properties from the View component.

***

#### `behavior`

Defines how the view should respond to the presence of the keyboard. Note that Android and iOS handle this prop differently, but setting `behavior` is recommended for both platforms.

|Type|
|-|
|enum(`'height'`, `'position'`, `'padding'`)|

***

#### `contentContainerStyle`

Specifies the style applied to the content container (View) when the behavior is set to `'position'`.

|Type|
|-|
|View Style|

***

#### `enabled`

Determines whether the `KeyboardAvoidingView` is active or inactive.

|Type|Default|
|-|-|
|boolean|`true`|

***

#### `keyboardVerticalOffset`

Represents the distance between the top of the user's screen and the React Native view. This value may be non-zero in certain scenarios.

|Type|Default|
|-|-|
|number|`0`|

## Modal

The Modal component provides a straightforward method to display content above an enclosing view.

### Example

***

### Reference

### Props

#### View Props

Inherits properties from the View component.

***

#### `animationType`

Controls the animation style of the modal.

Possible values:

- `slide`: Slides in from the bottom.
- `fade`: Fades into view.
- `none`: Appears without any animation.

|Type|Default|
|-|-|
|enum(`'none'`, `'slide'`, `'fade'`)|`none`|

***

#### `backdropColor`

Sets the background color of the modal's container. Defaults to `white` unless `transparent` is set to `true`.

|Type|Default|
|-|-|
|color|white|

***

#### `hardwareAccelerated` (Android)

Determines if hardware acceleration should be forced for the underlying window.

|Type|Default|
|-|-|
|bool|`false`|

***

#### `navigationBarTranslucent` (Android)

Decides whether the modal appears under the system navigation bar. Requires `statusBarTranslucent` to also be `true`.

|Type|Default|
|-|-|
|bool|`false`|

***

#### `onDismiss` (iOS)

Allows a function to be called when the modal is dismissed.

|Type|
|-|
|function|

***

#### `onOrientationChange` (iOS)

Triggered when the orientation changes while the modal is displayed. The callback provides 'portrait' or 'landscape'. It also fires on initial render, regardless of current orientation.

|Type|
|-|
|function|

***

#### `onRequestClose`

Invoked when the user presses the hardware back button on Android or the menu button on Apple TV. Note that `BackHandler` events are suppressed while the modal is open. On iOS, it's called during a drag gesture dismissal with `presentationStyle` set to `pageSheet` or `formSheet`.

|Type|
|-|
|functionRequiredAndroidTV\*\*\*functioniOS|

***

#### `onShow`

Allows a function to be executed once the modal is displayed.

|Type|
|-|
|function|

***

#### `presentationStyle` (iOS)

Determines how the modal appears on larger devices like iPads or plus-sized iPhones. Refer to [UIModalPresentationStyle](https://developer.apple.com/reference/uikit/uimodalpresentationstyle) for more details.

Possible values:

- `fullScreen`: Covers the entire screen.
- `pageSheet`: Centers a portrait-width view (on larger devices).
- `formSheet`: Centers a narrow-width view (on larger devices).
- `overFullScreen`: Covers the screen completely but allows transparency.

|Type|Default|
|-|-|
|enum(`'fullScreen'`, `'pageSheet'`, `'formSheet'`, `'overFullScreen'`)|`fullScreen` if `transparent={false}`\*\*\*`overFullScreen` if `transparent={true}`|

***

#### `statusBarTranslucent` (Android)

Determines whether the modal appears under the system status bar.

|Type|Default|
|-|-|
|bool|`false`|

***

#### `supportedOrientations` (iOS)

Allows rotation of the modal to specified orientations. On iOS, it's limited by the app's Info.plist settings for UISupportedInterfaceOrientations.

> Ignored when using `presentationStyle` of `pageSheet` or `formSheet`.

|Type|Default|
|-|-|
|array of enums(`'portrait'`, `'portrait-upside-down'`, `'landscape'`, `'landscape-left'`, `'landscape-right'`)|`['portrait']`|

***

#### `transparent`

Determines if the modal will cover the entire view with a transparent background.

|Type|Default|
|-|-|
|bool|`false`|

***

#### `visible`

Controls whether the modal is visible or not.

|Type|Default|
|-|-|
|bool|`true`|

## Key Concepts

To integrate React Native into an existing iOS application, follow these steps carefully. This guide assumes you have a basic understanding of both iOS development using Xcode and JavaScript/React Native.

#### Prerequisites

1. **Node.js**: Ensure Node.js is installed on your machine. You can download it from [nodejs.org](https://nodejs.org/).
1. **Xcode**: Make sure you have the latest version of Xcode installed.
1. **CocoaPods**: Install CocoaPods if not already installed, using `sudo gem install cocoapods`.

#### Step-by-Step Integration

##### 1. Set Up React Native Environment

First, initialize a new React Native project in your existing iOS app directory:

```bash
npx react-native init MyReactNativeApp --template react-native-template-typescript
```

This command creates a new React Native project using TypeScript.

##### 2. Configure CocoaPods

Navigate to the `ios` directory of your React Native project and open the `Podfile`. Add the following lines:

```ruby
platform :ios, '11.0'

require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules'
```

Then run:

```bash
pod install
```

This installs necessary dependencies for React Native.

##### 3. Modify Xcode Project

Open your `.xcworkspace` file in Xcode. Ensure that the `User Script Sandboxing` is set to `NO` under Build Settings > Scripting.

Add a new Run Script Phase in Xcode:

1. Select your application target.
1. Go to `Build Phases`.
1. Click on the `+` button and select `New Run Script Phase`.
1. Rename it to `Bundle React Native code and images`.
1. Add the following script:

```bash
set -e

WITH_ENVIRONMENT="$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh"
REACT_NATIVE_XCODE="$REACT_NATIVE_PATH/scripts/react-native-xcode.sh"

/bin/sh -c "$WITH_ENVIRONMENT $REACT_NATIVE_XCODE"
```

Drag this script above `[CP] Embed Pods Frameworks`.

##### 4. Create Metro Configuration

In the root of your project, create a `metro.config.js` file:

```javascript
const { getDefaultConfig } = require("@react-native/metro-config")
module.exports = getDefaultConfig(__dirname)
```

Create a `.watchmanconfig` file with an empty JSON object:

```bash
echo {} > .watchmanconfig
```

##### 5. Start Metro Bundler

Run the following command in your project root to start the Metro bundler:

```bash
npx react-native start
```

##### 6. Build and Run Your iOS App

In Xcode, build and run your app as usual. Ensure that you have a button or some mechanism to present the React Native view.

##### 7. Passing Initial Props

To pass initial properties from native code to JavaScript:

**Objective-C:**

Modify `ReactViewController.mm`:

```objective-c
self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld" initialProperties:@{
    @"userID": @"12345678",
    @"token": @"secretToken"
}];
```

**Swift:**

Modify `ReactViewController.swift`:

```swift
view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld", initialProperties: [
    "userID": "12345678",
    "token": "secretToken"
])
```

Update your `App.tsx` to read these properties:

```tsx
function App(props): React.JSX.Element {
  const isDarkMode = useColorScheme() === "dark"

  return (
    <SafeAreaView
      style={{ backgroundColor: isDarkMode ? Colors.darker : Colors.lighter }}
    >
      <StatusBar barStyle={isDarkMode ? "light-content" : "dark-content"} />
      <ScrollView contentInsetAdjustmentBehavior="automatic">
        <Header />
        <View>
          <Text style={styles.title}>UserID: {props.userID}</Text>
          <Text style={styles.title}>Token: {props.token}</Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  )
}
```

#### Testing and Debugging

- Ensure your app is running in development mode to see changes reflected immediately.
- Use React Native Debugger or Chrome DevTools for debugging JavaScript code.

#### Deployment

For release builds, ensure the script phase for bundling JS and images is correctly configured. Test thoroughly on both simulators and real devices.

By following these steps, you should be able to integrate React Native into your existing iOS application successfully. Continue developing using React Native's extensive documentation for further guidance.

## Pressable

Pressable is a Core Component wrapper designed to detect various stages of press interactions on any defined children elements.

```typescript
<Pressable onPress={onPressFunction}>
  <Text>I'm pressable!</Text>
</Pressable>
```

### How it Works

When an element is wrapped by `Pressable`:

- `onPressIn` is triggered when a press interaction begins.
- `onPressOut` occurs when the press gesture ends.

Following `onPressIn`, one of two scenarios may unfold:

1. The user lifts their finger, triggering `onPressOut` followed by `onPress`.
1. If the finger remains for more than 500 milliseconds before lifting, `onLongPress` is activated. `onPressOut` will still occur upon finger removal.

To accommodate imprecise touch interactions and accidental activations, `Pressable` offers an optional `HitRect`. This defines how far a touch can register from the wrapped element, allowing presses to start anywhere within this area.

Additionally, `PressRect` is set using `pressRetentionOffset`, enabling touches to move beyond the element and its `HitRect` while still maintaining activation. This feature allows for actions like sliding a finger away from a button that's being pressed.

> Note: The touch area does not extend past parent view bounds, and sibling views with higher Z-index take precedence if a touch hits overlapping views.

For more details on the state machine flow of Pressability, refer to React Native's `Pressability` API documentation.

### Example

### Props

#### `android_disableSound`

- **Type**: boolean
- **Default**: `false`
- If true, prevents Android system sound from playing on press.

#### `android_ripple`

- **Type**: RippleConfig
- Enables the Android ripple effect and configures its properties.

#### `children`

- **Type**: React Node
- Accepts children or a function that receives a boolean indicating if the component is currently pressed.

#### `unstable_pressDelay`

- **Type**: number
- Duration (in milliseconds) to wait after press down before calling `onPressIn`.

#### `delayLongPress`

- **Type**: number
- **Default**: `500`
- Duration (in milliseconds) from `onPressIn` before `onLongPress` is triggered.

#### `disabled`

- **Type**: boolean
- **Default**: `false`
- Determines if the press behavior is disabled.

#### `hitSlop`

- **Type**: Rect or number
- Sets additional distance outside of the element where a press can be detected.

#### `onHoverIn`

- **Type**: `({ nativeEvent: MouseEvent }) => void`
- Called when hover is activated to provide visual feedback.

#### `onHoverOut`

- **Type**: `({ nativeEvent: MouseEvent }) => void`
- Called when hover is deactivated to remove visual feedback.

#### `onLongPress`

- **Type**: `({nativeEvent: PressEvent}) => void`
- Triggered if the time after `onPressIn` exceeds 500 milliseconds. This duration can be customized with `delayLongPress`.

#### `onPress`

- **Type**: `({nativeEvent: PressEvent}) => void`
- Called after `onPressOut`.

#### `onPressIn`

- **Type**: `({nativeEvent: PressEvent}) => void`
- Triggered immediately when a touch is engaged, before `onPressOut` and `onPress`.

#### `onPressOut`

- **Type**: `({nativeEvent: PressEvent}) => void`
- Called when a touch is released.

#### `pressRetentionOffset`

- **Type**: Rect or number
- **Default**: `{bottom: 30, left: 20, right: 20, top: 20}`
- Sets additional distance outside of this view where a touch is considered a press before triggering `onPressOut`.

#### `style`

- **Type**: View Style or `({ pressed: boolean }) => View Style`
- Accepts view styles or a function that receives a boolean indicating if the component is currently pressed and returns view styles.

#### `testOnly_pressed`

- **Type**: boolean
- **Default**: `false`
- Used only for documentation or testing purposes (e.g., snapshot testing).

### Type Definitions

#### RippleConfig

Configuration object for the `android_ripple` property.

|Name|Type|Required|Description|
|-|-|-|-|
|color|color|No|Defines the color of the ripple effect.|
|borderless|boolean|No|Determines if the ripple effect should exclude borders.|
|radius|number|No|Sets the radius of the ripple effect.|
|foreground|boolean|No|If true, adds the ripple effect to the view's foreground instead of the background. Useful when child views have their own backgrounds or images are displayed, preventing the ripple from being obscured.|

## RefreshControl

The `RefreshControl` component is designed to be used within a ScrollView or ListView, providing pull-to-refresh functionality. When the scroll position (`scrollY`) reaches zero and the user swipes down, an `onRefresh` event is triggered.

### Example Usage

> **Note:** The `refreshing` prop is controlled, meaning it must be set to `true` during the `onRefresh` function execution; otherwise, the refresh indicator will cease immediately.

### Reference Guide

#### Props Overview

##### Inherited View Props

- Inherits all properties from the View component.

##### Required Prop: `refreshing`

- **Type:** boolean\
  Indicates whether the view is currently showing an active refresh state.

##### Android-Specific Props

- **`colors`:**

  - **Type:** array of colors\
    Specifies the colors used to draw the refresh indicator. At least one color must be provided.

- **`enabled`:**

  - **Type:** boolean
  - **Default:** `true`\
    Determines if pull-to-refresh functionality is enabled.

- **`onRefresh`:**

  - **Type:** function\
    Triggered when the view begins refreshing.

- **`progressBackgroundColor`:**

  - **Type:** color\
    Sets the background color of the refresh indicator.

- **`progressViewOffset`:**

  - **Type:** number
  - **Default:** `0`\
    Defines the top offset for the progress view.

- **`size`:**
  - **Type:** enum(`'default'`, `'large'`)
  - **Default:** `'default'`\
    Specifies the size of the refresh indicator.

##### iOS-Specific Props

- **`tintColor`:**

  - **Type:** color\
    Sets the color of the refresh indicator.

- **`title`:**

  - **Type:** string\
    The title displayed beneath the refresh indicator.

- **`titleColor`:**
  - **Type:** color\
    Defines the color of the refresh indicator's title.

## Integration with Existing Apps

This guide details how to integrate a full-screen React Native app into an existing Android app as an **Activity**. To use React Native components within **Fragments** in an existing app, additional setup is required.

### 1. Add React Native to Your App

Follow the guide for Integration with Existing Apps until the end to ensure your React Native app can run safely in a full-screen Activity.

### 2. Add a FrameLayout for the React Native Fragment

To integrate a React Native Fragment into an Activity, use a `FrameLayout`. This method is adaptable for other layouts like Bottom Sheets or Tab Layouts.

Add a `<FrameLayout>` with an id, width, and height to your Activity's layout (e.g., `main_activity.xml` in the `res/layouts` folder). This layout will render your React Native Fragment.

```xml
<FrameLayout
    android:id="@+id/react_native_fragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

### 3. Implement `DefaultHardwareBackBtnHandler`

Since the host activity is not a `ReactActivity`, implement the `DefaultHardwareBackBtnHandler` interface to handle back button press events, as required by React Native.

Ensure your host activity implements this interface:

#### Java

```java
package <your-package-here>;

import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;

public class MainActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main_activity);

        findViewById(R.id.sample_button).setOnClickListener(button -> {
            // Handle button click
        });
    }

    @Override
    public void invokeDefaultOnBackPressed() {
        super.onBackPressed();
    }
}
```

#### Kotlin

```kotlin
package <your-package-here>

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler

class MainActivity : AppCompatActivity(), DefaultHardwareBackBtnHandler {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main_activity)

        findViewById<Button>(R.id.sample_button).setOnClickListener {
            // Handle button click
        }
    }

    override fun invokeDefaultOnBackPressed() {
        super.onBackPressed()
    }
}
```

### 4. Add a React Native Fragment to the FrameLayout

Update your Activity to add a React Native Fragment to the `FrameLayout`. Assume your Activity has a button with id `sample_button` that, when clicked, renders a React Native Fragment into the `FrameLayout`.

#### Java

```java
package <your-package-here>;

import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.facebook.react.ReactFragment;
import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;

public class MainActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main_activity);

        findViewById(R.id.sample_button).setOnClickListener(button -> {
            Bundle launchOptions = new Bundle();
            launchOptions.putString("message", "my value");

            ReactFragment fragment = new ReactFragment.Builder()
                    .setComponentName("HelloWorld")
                    .setLaunchOptions(launchOptions)
                    .build();
            getSupportFragmentManager()
                    .beginTransaction()
                    .add(R.id.react_native_fragment, fragment)
                    .commit();
        });
    }

    @Override
    public void invokeDefaultOnBackPressed() {
        super.onBackPressed();
    }
}
```

#### Kotlin

```kotlin
package <your-package-here>

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.facebook.react.ReactFragment
import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler

class MainActivity : AppCompatActivity(), DefaultHardwareBackBtnHandler {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main_activity)

        findViewById<Button>(R.id.sample_button).setOnClickListener {
            val reactNativeFragment = ReactFragment.Builder()
                .setComponentName("HelloWorld")
                .setLaunchOptions(Bundle().apply { putString("message", "my value") })
                .build()
            supportFragmentManager
                .beginTransaction()
                .add(R.id.react_native_fragment, reactNativeFragment)
                .commit()
        }
    }

    override fun invokeDefaultOnBackPressed() {
        super.onBackPressed()
    }
}
```

#### Explanation

- Use `ReactFragment.Builder()` to create a new `ReactFragment`.
- Add the Fragment to the `FrameLayout` using `supportFragmentManager`.
- Customize the fragment creation with:
  - `setComponentName`: Name of the component to render, specified in your `index.js` inside the `registerComponent` method.
  - `setLaunchOptions`: Optional method to pass initial props to your component.

### 5. Test Your Integration

Run `yarn start` to launch the bundler and then run your Android app in Android Studio. The app should load JavaScript/TypeScript code from the development server and display it in your React Native Fragment within the Activity.

## Building For TV Devices

Support for TV devices, specifically Apple TV and Android TV, was integrated into React Native applications with the goal of enabling these apps to function on such platforms with minimal modifications required in their JavaScript code.

> **Deprecated Notice:** The support for TV devices has been transitioned to a separate repository named "React Native for TV." For detailed guidance on projects targeting Apple TV or Android TV, please refer to the *README* file within that repository.

## ScrollView

The provided documentation outlines various properties and methods associated with a ScrollView component, likely from a mobile development framework such as React Native. Below is a summary of the key features:

#### Properties

1. **Automatic Scrolling**:

   - Automatically scrolls to the top when the status bar is tapped (`scrollsToTop`).
   - Programmatically scroll beyond content size (`scrollToOverflowEnabled`).

1. **Scroll Indicators**:

   - Control visibility of horizontal and vertical indicators.
   - Customize insets for scroll view indicators.

1. **Performance Enhancements**:

   - Remove offscreen child views to improve performance (`removeClippedSubviews`).
   - Log scroll performance with a custom tag (`scrollPerfTag`).

1. **Scroll Behavior**:

   - Enable or disable scrolling via touch interaction (`scrollEnabled`).
   - Throttle frequency of scroll events (`scrollEventThrottle`).
   - Control over-scroll behavior (`overScrollMode`).

1. **Refresh Control**:

   - Implement pull-to-refresh functionality with `refreshControl`.

1. **Snap and Paging**:

   - Snap to specific intervals or offsets for pagination (`snapToInterval`, `snapToOffsets`).
   - Align snapping positions (`snapToAlignment`).
   - Enable paging behavior (`pagingEnabled`).

1. **Nested Scrolling**:

   - Support nested scrolling on Android API level 21+ (`nestedScrollEnabled`).

1. **Zooming**:

   - Control zoom scale and enable pinch gestures for zooming.

1. **Sticky Headers**:

   - Fix certain headers to the top during scroll (`stickyHeaderIndices`, `stickyHeaderHiddenOnScroll`).

1. **Event Handling**:
   - Callbacks for various scroll events (e.g., `onScroll`, `onMomentumScrollBegin`).

#### Methods

1. **Flash Scroll Indicators**:

   - Temporarily display scroll indicators (`flashScrollIndicators`).

1. **Programmatic Scrolling**:
   - Scroll to specific coordinates with optional animation (`scrollTo`).
   - Automatically scroll to the end of content (`scrollToEnd`).

These properties and methods provide extensive control over scrolling behavior, performance optimization, and user interaction within a ScrollView component.

## Out-of-Tree Platforms

React Native extends beyond Android and iOS devices. Various partners and community projects have developed React Native for additional platforms:

**From Partners**

- **React Native macOS**: Supports macOS and Cocoa applications.
- **React Native Windows**: Targets Microsoft's Universal Windows Platform (UWP).
- **React Native visionOS**: Designed for Apple's visionOS.

**From Community**

- **React Native tvOS**: Compatible with Apple TV and Android TV devices.
- **React Native Web**: Enables React Native on the web using React DOM.
- **React Native Skia**: Utilizes Skia as a renderer, supporting Linux and macOS.

### Creating Your Own React Native Platform

Currently, creating a new React Native platform from scratch lacks comprehensive documentation. The upcoming re-architecture (Fabric) aims to simplify this process.

#### Bundling

Starting with React Native 0.57, you can register your custom platform with the JavaScript bundler, Metro. This allows using `--platform example` with `npx react-native bundle`, which will search for JavaScript files ending in `.example.js`.

To integrate your module with RNPM, its name should follow these patterns:

- **`react-native-example`**: Searches all top-level modules starting with `react-native-`.
- **`@org/react-native-example`**: Looks for modules under any scope that start with `react-native-`.
- **`@react-native-example/module`**: Searches within scopes beginning with `@react-native-`.

Your `package.json` must include an entry like this:

```json
{
  "rnpm": {
    "haste": {
      "providesModuleNodeModules": ["react-native-example"],
      "platforms": ["example"]
    }
  }
}
```

Here, `"providesModuleNodeModules"` is a list of modules added to the Haste module search path, and `"platforms"` specifies valid platform suffixes.

## StatusBar

The `StatusBar` component manages the app's status bar, which is typically located at the top of the screen. It displays information such as time, network status, battery level, and other status icons.

### Usage with Navigator

Multiple `StatusBar` components can be mounted simultaneously. The properties of these components are merged in the order they were mounted.

- **TypeScript**
- **JavaScript**

#### Imperative API

For scenarios where using a component is not ideal, an imperative API is available through static functions on the component. However, it's not recommended to use both the static API and the component for the same property simultaneously, as values set by the static API will be overridden by those set by the component in subsequent renders.

### Reference

#### Constants

- **`currentHeight` (Android):** Represents the height of the status bar, including any notch height if present.

### Props

|Prop Name|Type|Required|Default|Description|
|-|-|-|-|-|
|`animated`|boolean|No|`false`|Determines if transitions between status bar property changes should be animated. Supported for `backgroundColor`, `barStyle`, and `hidden`.|
|`backgroundColor` (Android)|color|No|Default system StatusBar background color or `'black'` if not defined|The background color of the status bar. **Warning:** Deprecated in API level 35 due to edge-to-edge enforcement introduced in Android 15.|
|`barStyle`|StatusBarStyle|No|`'default'`|Sets the color of the status bar text. On Android, this affects only API versions 23 and above.|
|`hidden`|boolean|No|`false`|Determines if the status bar is hidden.|
|`networkActivityIndicatorVisible` (iOS)|boolean|No|`false`|Controls visibility of the network activity indicator.|
|`showHideTransition` (iOS)|StatusBarAnimation|No|`'fade'`|The transition effect when showing or hiding the status bar using the `hidden` prop.|
|`translucent` (Android)|boolean|No|`false`|Determines if the status bar is translucent, allowing the app to draw under it. Useful with a semi-transparent status bar color.|

### Methods

#### `popStackEntry()`

```typescript
static popStackEntry(entry: StatusBarProps): void;
```

Get and remove the last `StatusBar` entry from the stack.

**Parameters:**

- **entry (Required)**: Entry returned from `pushStackEntry`.

#### `pushStackEntry()`

```typescript
static pushStackEntry(props: StatusBarProps): StatusBarProps;
```

Push a `StatusBar` entry onto the stack. The return value should be passed to `popStackEntry` when complete.

**Parameters:**

- **props (Required)**: Object containing the `StatusBar` props for the stack entry.

#### `replaceStackEntry()`

```typescript
static replaceStackEntry(
  entry: StatusBarProps,
  props: StatusBarProps
): StatusBarProps;
```

Replace an existing `StatusBar` stack entry with new properties.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**entry (Required)**|any|Entry returned from `pushStackEntry` to replace.|
|**props (Required)**|any|Object containing the `StatusBar` props for the replacement stack entry.|

#### `setBackgroundColor()` (Android)

```typescript
static setBackgroundColor(color: ColorValue, animated?: boolean): void;
```

Set the background color of the status bar.

**Warning:** Deprecated in API level 35 due to edge-to-edge enforcement introduced in Android 15.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**color (Required)**|string|Background color.|
|animated|boolean|Animate the style change.|

#### `setBarStyle()`

```typescript
static setBarStyle(style: StatusBarStyle, animated?: boolean): void;
```

Set the status bar style.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**style (Required)**|StatusBarStyle|Status bar style to set.|
|animated|boolean|Animate the style change.|

#### `setHidden()`

```typescript
static setHidden(hidden: boolean, animation?: StatusBarAnimation): void;
```

Show or hide the status bar.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**hidden (Required)**|boolean|Hide the status bar.|
|animation (iOS)|StatusBarAnimation|Animation when changing the hidden property of the status bar.|

#### `setNetworkActivityIndicatorVisible()` (iOS)

```typescript
static setNetworkActivityIndicatorVisible(visible: boolean): void;
```

Control the visibility of the network activity indicator.

**Parameters:**

- **visible (Required)**: Show the indicator.

#### `setTranslucent()` (Android)

```typescript
static setTranslucent(translucent: boolean): void;
```

Control the translucency of the status bar.

**Parameters:**

- **translucent (Required)**: Set as translucent.

### Type Definitions

#### StatusBarAnimation

Enum representing the status bar animation type for transitions on iOS.

|Value|Type|Description|
|-|-|-|
|`'fade'`|string|Fade animation.|
|`'slide'`|string|Slide animation.|
|`'none'`|string|No animation.|

#### StatusBarStyle

Enum representing the status bar style type.

|Value|Type|Description|
|-|-|-|
|`'default'`|string|Default status bar style (dark for iOS, light for Android).|
|`'light-content'`|string|White texts and icons.|
|`'dark-content'`|string|Dark texts and icons (requires API>=23 on Android).|

## 1. Enable Debugging over USB

Most Android devices restrict app installations to those downloaded from Google Play by default. To install apps during development, enable USB Debugging on your device.

### Steps to Enable USB Debugging:

1. **Access Developer Options:**

   - Navigate to **Settings** → **About phone** → **Software information**.
   - Tap the `Build number` row seven times to unlock "Developer options".

1. **Enable USB Debugging:**
   - Go back to **Settings** → **Developer options**.
   - Turn on "USB debugging".

## Setting Up an Android Device for React Native Development

### 1. Connect Your Device via USB

- Plug your device into your development machine using a USB cable.

#### Verify Connection with ADB:

Run the following command to ensure your device is connected:

```shell
$ adb devices
```

Output example:

```
List of devices attached
emulator-5554 offline   # Google emulator
14ed2fcc device         # Physical device
```

A `device` status indicates a successful connection. Ensure only one device is connected at a time.

#### Troubleshooting:

If you see `unauthorized`, execute the following command and allow USB debugging on your device:

```shell
adb reverse tcp:8081 tcp:8081
```

### 2. Running Your App

From your project's root directory, use either npm or Yarn to install and launch your app:

#### Using npm:

```shell
npm run android
```

#### Using Yarn:

```shell
yarn android
```

> **Note:** For a release build, use: `yarn android --mode release`.

## Connecting to the Development Server

Iterate quickly on a device by connecting it to your development server. Choose between USB or Wi-Fi methods.

### Method 1: Using adb reverse (Recommended)

This method is suitable for devices running Android 5.0 (Lollipop) or newer with USB debugging enabled and connected via USB.

Execute the following command:

```shell
$ adb -s <device name> reverse tcp:8081 tcp:8081
```

To find your device name, run:

```shell
$ adb devices
```

Enable Fast Refresh from the Dev Menu to reload your app upon JavaScript code changes.

### Method 2: Connect via Wi-Fi

Connect over Wi-Fi after initially installing the app with a USB cable. Ensure both your laptop and phone are on the same network.

#### Steps:

1. Open your React Native app; expect an initial error screen.
1. Access the in-app Dev Menu.
1. Navigate to **Dev Settings** → **Debug server host & port for device**.
1. Enter your machine's IP address and local dev server port (e.g., `10.0.1.1:8081`).
1. Select **Reload JS** from the Dev Menu.

Enable Fast Refresh to automatically reload your app when JavaScript code changes.

## Building Your App for Production

To release your React Native app on the Play Store, follow standard native Android app production processes with additional considerations. Refer to the guide for generating a signed APK for detailed instructions.

### Additional Setup for Linux Users:

#### Identify USB Device ID:

1. Use `lsusb` to list connected USB devices:

   ```bash
   $ lsusb
   ```

1. Identify your phone's line and extract the first four digits of its device ID (e.g., `22b8`).

1. Update udev rules with the following command, replacing `22b8` with your device ID:

   ```shell
   echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"' | sudo tee /etc/udev/rules.d/51-android-usb.rules
   ```

#### Verify ADB Connection Again:

Run `adb devices` to confirm your device is connected.

## Summary

This guide covers enabling USB debugging, setting up an Android device for React Native development, connecting to the development server via USB or Wi-Fi, and preparing your app for production release. Follow these steps to streamline your development workflow.

## Switch

The `Switch` component renders a boolean input and functions as a controlled component. It necessitates an `onValueChange` callback to update its `value` prop, ensuring that user interactions are accurately reflected in the UI. Without updating the `value` prop, the component will persistently display the initially supplied value.

### Example

*Example usage of the Switch component is not provided here.*

### Reference

*Reference details for the Switch component are not included here.*

### Props

#### View Props

The `Switch` inherits all View Props.

#### `disabled`

- **Description**: Disables user interaction with the switch.
- **Type**: `bool`
- **Default**: `false`

#### `ios_backgroundColor`

- **Description**: On iOS, this sets a custom background color for the switch. This color is visible when the switch value is `false` or if the switch is disabled and translucent.
- **Type**: `color`

#### `onChange`

- **Description**: Triggered when there's an attempt to change the switch's value. It receives the change event as its argument. For receiving only the new value, use `onValueChange`.
- **Type**: `function`

#### `onValueChange`

- **Description**: Called upon attempts to alter the switch's value. This prop receives the new value directly. To receive an event instead, utilize `onChange`.
- **Type**: `function`

#### `thumbColor`

- **Description**: Sets the color of the switch's foreground grip. On iOS, setting this will remove the drop shadow from the switch grip.
- **Type**: `color`

#### `trackColor`

- **Description**: Defines custom colors for the switch track.
  - *iOS*: When the switch is off (`false`), the track contracts into its border. To modify the color of the background revealed by this contracted track, use `ios_backgroundColor`.
- **Type**: `object: { false: color, true: color }`

#### `value`

- **Description**: Determines the state of the switch. If set to `true`, the switch is on; otherwise, it's off. The default value is `false`.
- **Type**: `bool`

## Fast Refresh

Fast Refresh is a feature in React Native that provides near-instant feedback when changes are made to your React components. By default, this feature is enabled and can be toggled through the "Enable Fast Refresh" option in the React Native Dev Menu. With it activated, most edits should become visible within seconds.

### How It Works

- **React Component Exports**: If you modify a module that exclusively exports React components, Fast Refresh will update only that specific module and re-render your component. This includes changes to styles, rendering logic, event handlers, or effects.

- **Non-Component Exports**: When editing a module with non-component exports, Fast Refresh triggers a re-run of both the edited module and any other modules importing it. For instance, if `Button.js` and `Modal.js` both import `Theme.js`, changes to `Theme.js` will update both components.

- **Non-React Imports**: If you edit a file imported by non-React tree modules, Fast Refresh defaults to a full reload. This often occurs when a component exports values used by non-React utilities. To maintain Fast Refresh functionality, consider moving such constants to separate files and importing them where needed.

### Error Resilience

Fast Refresh is designed to handle errors gracefully:

- **Syntax Errors**: Fixing syntax errors during a session will remove the redbox error message without requiring an app reload.

- **Runtime Initialization Errors**: Errors occurring during module initialization (e.g., `Style.create` instead of `StyleSheet.create`) allow the session to continue once corrected, with the redbox disappearing and the module updating.

- **Component Runtime Errors**: Even if a runtime error occurs within your component, Fast Refresh continues after fixing it. React will remount the application using the updated code.

Error boundaries in your app can help manage errors gracefully by retrying rendering on subsequent edits, preventing constant fallback to the root screen. However, they should not be overly granular and must be used intentionally.

### Limitations

While Fast Refresh aims to preserve local React state during edits, there are scenarios where it may reset:

- **Class Components**: State is not preserved for class components; only function components and Hooks maintain state.

- **Multiple Exports**: Modules with additional exports besides a React component might see their state reset.

- **Higher-Order Component Results**: If a module exports the result of a higher-order component like `createNavigationContainer(MyScreen)` and returns a class, its state will be reset.

As more code transitions to function components and Hooks, state preservation is expected to improve.

### Tips

- Fast Refresh inherently preserves local React state in function components (and Hooks).

- To force a component remount on every edit—useful for animations that occur on mount—you can add `// @refresh reset` within the file being edited. This directive instructs Fast Refresh to remount components defined in that file with each edit.

### Fast Refresh and Hooks

Fast Refresh attempts to maintain your component's state between edits, particularly for `useState` and `useRef`, as long as their arguments or Hook call order remain unchanged.

Hooks with dependencies (e.g., `useEffect`, `useMemo`, `useCallback`) will always update during Fast Refresh, ignoring dependency lists. For instance, changing `useMemo(() => x * 2, [x])` to `useMemo(() => x * 10, [x])` triggers a re-run even if the dependency `x` hasn't changed. This ensures your edits are reflected on screen.

This behavior can lead to unexpected results, such as an empty-array `useEffect` running once during Fast Refresh. Writing resilient code for occasional `useEffect` re-runs is beneficial and aligns with best practices, facilitating future dependency additions.

## Metro

React Native utilizes Metro to compile JavaScript code and manage assets. Below are guidelines for configuring Metro within your project.

### Configuring Metro

To customize Metro's configuration, modify the `metro.config.js` file in your project directory. This file can export:

- **An Object**: Recommended approach that merges with Metro's internal default configurations.
- **A Function**: Called with Metro's defaults and should return a final configuration object.

For comprehensive documentation on all available configuration options, refer to the "Configuring Metro" section on the Metro website.

In React Native projects, it is advisable to extend either `@react-native/metro-config` or `@expo/metro-config`. These packages provide essential default settings required for building and running React Native applications.

#### Default Configuration Example

Here's a typical `metro.config.js` file found in a React Native template project:

```typescript
const { getDefaultConfig, mergeConfig } = require("@react-native/metro-config")

/**
 * Metro configuration
 * https://metrobundler.dev/docs/configuration
 *
 * @type {import('metro-config').MetroConfig}
 */
const config = {}

module.exports = mergeConfig(getDefaultConfig(__dirname), config)
```

Customize Metro options by modifying the `config` object.

#### Advanced Configuration: Using a Config Function

Exporting a configuration function allows you to manage the final configuration manually. **Note**: Metro will not apply any internal defaults in this case. This approach is useful for accessing the base default config from Metro or setting options dynamically.

**Important Update**: From version `@react-native/metro-config` 0.72.1, it's no longer necessary to use a config function to access the complete default configuration. Refer to the "Tip" section below for simpler methods.

```typescript
const { getDefaultConfig, mergeConfig } = require("@react-native/metro-config")

module.exports = function (baseConfig) {
  const defaultConfig = mergeConfig(baseConfig, getDefaultConfig(__dirname))
  const {
    resolver: { assetExts, sourceExts },
  } = defaultConfig

  return mergeConfig(defaultConfig, {
    resolver: {
      assetExts: assetExts.filter((ext) => ext !== "svg"),
      sourceExts: [...sourceExts, "svg"],
    },
  })
}
```

#### Simpler Alternative

For simpler customizations like modifying `sourceExts`, you can directly read these defaults from `@react-native/metro-config`.

```typescript
const defaultConfig = getDefaultConfig(__dirname)

const config = {
  resolver: {
    sourceExts: [...defaultConfig.resolver.sourceExts, "svg"],
  },
}

module.exports = mergeConfig(defaultConfig, config)
```

**Recommendation**: It's best to copy and edit configuration values directly in your `metro.config.js` file. This ensures that the source of truth for these settings resides within your project.

✅ **Recommended Approach**

```typescript
const config = {
  resolver: {
    sourceExts: ["js", "ts", "tsx", "svg"],
  },
}
```

### Further Learning

- Visit the [Metro website](https://metrobundler.dev/docs/configuration) for more information.
- Watch the "Metro & React Native DevX" talk at App.js 2023 for insights into Metro's role in React Native development.

## Using Libraries

React Native offers built-in Core Components and APIs, but you can also leverage a vast community of developers to find additional libraries that extend your app's functionality.

### Selecting a Package Manager

Libraries for React Native are typically installed from the npm registry using package managers like npm CLI or Yarn Classic. If Node.js is already installed on your machine, npm CLI comes pre-installed. Some developers prefer Yarn Classic due to its faster install times and advanced features such as Workspaces. Both tools integrate well with React Native. For simplicity, this guide will use npm.

> 💡 In the JavaScript community, "library" and "package" are often used interchangeably.

### Installing a Library

To add a library to your project, navigate to your project directory in the terminal and execute the installation command. Here's how you can install `react-native-webview`:

- **Using npm:**

  ```shell
  npm install react-native-webview
  ```

- **Using Yarn:**

  ```shell
  yarn add react-native-webview
  ```

Libraries with native code require linking to your app before use.

### Linking Native Code on iOS

React Native uses CocoaPods for managing iOS project dependencies. Most libraries follow this convention, but if not, refer to their README for instructions. Typically:

1. Run `pod install` in the `ios` directory or use a shortcut with `npx pod-install`.

   ```bash
   npx pod-install
   ```

1. Rebuild your app binary to start using the new library:

   - **Using npm:**

     ```shell
     npm run ios
     ```

   - **Using Yarn:**

     ```shell
     yarn ios
     ```

### Linking Native Code on Android

React Native uses Gradle for managing Android project dependencies. After installing a library with native code, rebuild the app binary:

- **Using npm:**

  ```shell
  npm run android
  ```

- **Using Yarn:**

  ```shell
  yarn android
  ```

### Finding Libraries

The React Native Directory is a searchable database of libraries specifically for React Native. It's an excellent starting point for finding libraries.

Many libraries originate from the React Native Community or Expo:

- **React Native Community**: Driven by volunteers and companies reliant on React Native, these libraries often support iOS, tvOS, Android, Windows, though this varies.

- **Expo Libraries**: Written in TypeScript, they aim to support iOS, Android, and `react-native-web` where possible.

If a library isn't listed in the directory, check the npm registry. While it's a comprehensive source for JavaScript libraries, not all are compatible with React Native.

### Determining Library Compatibility

#### Does it work with React Native?

Libraries built for other platforms may not be compatible with React Native. For instance:

- `react-select` targets `react-dom` and is web-specific.
- `rimraf` interacts with the file system, making it Node.js-specific.

Conversely, libraries like `lodash`, which use only JavaScript features, are generally cross-platform. Testing is often necessary to determine compatibility. If a library doesn't work, remove it using `npm uninstall`.

#### Does it work for my app's platforms?

React Native Directory allows filtering by platform compatibility (iOS, Android, Web, Windows). If your desired library isn't listed, consult its README.

#### Does it work with my React Native version?

The latest library versions usually support the latest React Native releases. For older React Native versions, check the library's README for compatible versions. Install a specific version using:

```shell
npm install <library-name>@<version-number>
```

For example:

```shell
npm install @react-native-community/netinfo@^2.0.0
```

## Text

Here's a structured overview and explanation of the `Text` component in React Native, focusing on its properties and usage:

#### Overview

The `Text` component is used to display text within a React Native application. It supports various styling options and accessibility features, making it versatile for different use cases.

#### Key Properties

1. **Accessibility Features**

   - `accessibilityRole`: Defines the role of the component (e.g., button, link).
   - `accessibilityState`: Provides additional state information.
   - `accessibilityActions`: Specifies actions available to accessibility services.
   - `accessible`: Determines if the component is accessible.

1. **Styling**

   - `style`: Applies text and view styles using a combination of Text Style and View Style Props.
   - `numberOfLines` & `ellipsizeMode`: Controls text truncation with ellipses.
   - `selectable`: Enables text selection for copy-paste functionality.

1. **Layout and Measurement**

   - `onTextLayout`: Callback invoked on layout changes, providing detailed measurement data.
   - `lineBreakStrategyIOS` & `textBreakStrategy`: Configures line break strategies for iOS and Android respectively.

1. **Touch Handling**

   - `onPress`, `onLongPress`, `onPressIn`, `onPressOut`: Handle various touch events.
   - `onResponder*` series: Manage responder system interactions, crucial for handling touches across multiple views.

1. **Identification and Testing**

   - `id`, `nativeID`, `testID`: Used for locating the component in native code or tests.

1. **Dynamic Text Scaling**

   - `adjustsFontSizeToFit`, `minimumFontScale`, `maxFontSizeMultiplier`: Control font scaling based on user settings or constraints.

1. **Highlighting and Selection**
   - `suppressHighlighting`: Controls visual feedback on text press.
   - `selectionColor` (Android): Sets the highlight color for selected text.

#### Type Definitions

- **TextLayout**: Contains measurement data for each line of text, including dimensions and positions.

- **TextLayoutEvent**: Provides layout change information, including an array of `TextLayout` objects for rendered lines.

#### Example Usage

```jsx
import React from "react"
import { Text } from "react-native"

const MyComponent = () => (
  <Text
    style={{ fontSize: 16, color: "blue" }}
    numberOfLines={2}
    ellipsizeMode="tail"
    onPress={() => console.log("Text pressed")}
  >
    This is a sample text that will be truncated with an ellipsis if it exceeds
    two lines.
  </Text>
)

export default MyComponent
```

#### Conclusion

The `Text` component in React Native is highly customizable, supporting various styling and accessibility options. Understanding its properties allows developers to create rich, interactive text elements tailored to specific application needs.

## TextInput

Here is a structured overview of the properties, methods, and known issues related to the `TextInput` component in React Native:

#### Properties

##### General Properties

- **editable**: If `false`, prevents user input. Default: `true`.
- **maxLength**: Limits text length. Default: No limit.
- **multiline**: Enables multiple lines. Default: `false`.
- **numberOfLines**: Sets line count for multiline inputs. Default: 1.
- **onChangeText**: Callback on text change.
- **onSubmitEditing**: Callback when submit button is pressed.
- **placeholder**: Placeholder text when empty.
- **value**: Controlled component value.

##### Platform-Specific Properties

###### Android

- **disableFullscreenUI**: Hides fullscreen keyboard UI. Default: `false`.
- **enablesReturnKeyAutomatically**: Enables return key based on content. Default: `true`.
- **keyboardAppearance**: Sets keyboard appearance (`light` or `dark`). Default: `default`.
- **maxLength**: Limits text length.
- **numberOfLines**: Sets line count for multiline inputs.
- **returnKeyType**: Defines return key label. Options include `done`, `go`, `next`, etc.
- **scrollEnabled**: Enables scrolling in multiline mode. Default: `true`.
- **selectTextOnFocus**: Selects all text on focus. Default: `false`.
- **showSoftInputOnFocus**: Shows keyboard on focus. Default: `true`.

###### iOS

- **autoCapitalize**: Capitalization style (`none`, `sentences`, etc.). Default: `sentences`.
- **autoCorrect**: Enables autocorrection. Default: `true`.
- **keyboardType**: Sets keyboard type (`default`, `email-address`, etc.).
- **returnKeyType**: Defines return key label.
- **spellCheck**: Enables spell check. Default: Inherits from `autoCorrect`.

##### Common Properties

- **allowFontScaling**: Scales font size with user settings. Default: `true`.
- **blurOnSubmit**: Blurs on submit. Default: `false`.
- **caretHidden**: Hides caret in multiline mode. Default: `false`.
- **caretColor**: Sets caret color.
- **clearButtonMode**: Controls clear button visibility (`never`, `while-editing`, etc.). Default: `never`.
- **contextMenuHidden**: Hides context menu. Default: `false`.
- **disableFullscreenUI**: Hides fullscreen keyboard UI. Default: `false`.
- **enablesReturnKeyAutomatically**: Enables return key based on content. Default: `true`.
- **focusable**: Controls focusability. Default: `true`.
- **maxLength**: Limits text length.
- **multiline**: Enables multiple lines. Default: `false`.
- **numberOfLines**: Sets line count for multiline inputs. Default: 1.
- **onContentSizeChange**: Callback on content size change.
- **onChangeText**: Callback on text change.
- **onSubmitEditing**: Callback when submit button is pressed.
- **placeholder**: Placeholder text when empty.
- **returnKeyType**: Defines return key label.
- **secureTextEntry**: Obscures text for sensitive input. Default: `false`.
- **selection**: Sets text selection range.
- **selectionColor**: Sets highlight, handle, and cursor color.
- **style**: Applies styles to the text input.

#### Methods

- **focus()**: Requests focus on the native input.
- **blur()**: Removes focus from the native input.
- **clear()**: Clears all text from the `TextInput`.
- **isFocused()**: Returns `true` if the input is focused; otherwise, `false`.

#### Known Issues

- **react-native#19096**: Doesn't support Android's `onKeyPreIme`.
- **react-native#19366**: `.focus()` doesn't bring up the keyboard after closing it via back button on Android.
- **react-native#26799**: `secureTextEntry` doesn't work with `keyboardType="email-address"` or `keyboardType="phone-pad"` on Android.

This overview provides a comprehensive guide to using and understanding the `TextInput` component in React Native, including its properties, methods, and known issues.

## TouchableHighlight

> For a more robust and future-proof approach to handling touch-based input, consider using the Pressable API.

TouchableHighlight is designed to make views respond appropriately to touch interactions. When pressed, it reduces the opacity of the wrapped view, allowing an underlay color to become visible, which can darken or tint the view.

The underlay effect is achieved by wrapping the child component in a new View. This can impact layout and may introduce visual artifacts if not used correctly, such as when the `backgroundColor` of the wrapped view isn't set to an opaque color explicitly.

TouchableHighlight requires exactly one child element. If multiple child components are needed, they should be enclosed within a single View.

#### Example Usage

```typescript
function MyComponent(props: MyComponentProps) {
  return (
    <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>
      <Text>My Component</Text>
    </View>
  );
}

<TouchableHighlight
  activeOpacity={0.6}
  underlayColor="#DDDDDD"
  onPress={() => alert('Pressed!')}>
  <MyComponent />
</TouchableHighlight>;
```

### Reference

#### Props

##### Inherited from TouchableWithoutFeedback

- Inherits all props from `TouchableWithoutFeedback`.

##### Specific to TouchableHighlight

|Prop Name|Description|Type|
|-|-|-|
|`activeOpacity`|Sets the opacity of the wrapped view during touch interaction. Must be between 0 and 1. Defaults to 0.85. Requires `underlayColor`.|number|
|`onHideUnderlay`|Called immediately after the underlay is hidden.|function|
|`onShowUnderlay`|Called immediately after the underlay is shown.|function|
|`style`|Style properties for the view.|View\.style|
|`underlayColor`|The color of the underlay that appears when touch is active.|color|

##### iOS Specific Props

- **hasTVPreferredFocus**: *(Apple TV only)* Indicates TV preferred focus (refer to the View component documentation).
  - Type: bool

##### Android Specific Props

- **nextFocusDown**: TV next focus down (see View component documentation).
  - Type: number
- **nextFocusForward**: TV next focus forward (see View component documentation).
  - Type: number
- **nextFocusLeft**: TV next focus left (see View component documentation).
  - Type: number
- **nextFocusRight**: TV next focus right (see View component documentation).
  - Type: number
- **nextFocusUp**: TV next focus up (see View component documentation).
  - Type: number

##### Testing Prop

- **testOnly\_pressed**: Useful for snapshot tests.
  - Type: bool

## TouchableOpacity

> For a more comprehensive and future-proof approach to handling touch-based input, consider using the Pressable API.

The `TouchableOpacity` is a wrapper that ensures views respond appropriately to touch interactions. When pressed, it reduces the opacity of the wrapped view, creating a dimming effect.

This behavior is achieved by enclosing the children in an `Animated.View`, which is then added to the view hierarchy. Note that this can influence layout.

### Example

### Reference

### Properties

#### Inherited from TouchableWithoutFeedback Props

`TouchableOpacity` inherits properties from `TouchableWithoutFeedback`.

#### `style`

- **Type**: View\.style
- Description: Defines the style of the component.

#### `activeOpacity`

- **Type**: number
- **Default**: 0.2
- Description: Specifies the opacity level of the wrapped view during an active touch event.

#### `hasTVPreferredFocus` (iOS)

- **Type**: bool
- **Platform**: Apple TV only
- Description: Determines if the component should have preferred focus on Apple TV, as detailed in the View component documentation.

#### `nextFocusDown` (Android)

- **Type**: number
- **Platform**: Android
- Description: Specifies the next focusable view when navigating down using a TV remote, as described in the View component documentation.

#### `nextFocusForward` (Android)

- **Type**: number
- **Platform**: Android
- Description: Identifies the next focusable view when navigating forward with a TV remote, according to the View component documentation.

#### `nextFocusLeft` (Android)

- **Type**: number
- **Platform**: Android
- Description: Determines the next focusable view when navigating left using a TV remote, as per the View component documentation.

#### `nextFocusRight` (Android)

- **Type**: number
- **Platform**: Android
- Description: Specifies the next focusable view when navigating right with a TV remote, based on the View component documentation.

#### `nextFocusUp` (Android)

- **Type**: number
- **Platform**: Android
- Description: Identifies the next focusable view when navigating up using a TV remote, as detailed in the View component documentation.

## Upgrading to new versions

Upgrading to newer versions of React Native provides access to additional APIs, views, developer tools, and other enhancements. Although the process requires some effort, we aim to make it as straightforward as possible.

### Expo Projects

To upgrade an Expo project to a new version of React Native, update the `react-native`, `react`, and `expo` package versions in your `package.json`. It is recommended by Expo to incrementally upgrade SDK versions one at a time. This approach helps identify any issues or breakages during the upgrade process. For detailed guidance, refer to the Upgrading Expo SDK Walkthrough.

### React Native Projects

React Native projects typically consist of an Android project, an iOS project, and a JavaScript project, making upgrades complex. The Upgrade Helper is a web tool designed to assist in upgrading apps by displaying all changes between two versions and providing comments on specific files for better understanding.

#### Steps to Upgrade

##### 1. Select Versions

Begin by selecting the current version and the target version you wish to upgrade to. By default, the latest major versions are selected. After making your selection, click "Show me how to upgrade." Major updates may include a "useful content" section with helpful links.

##### 2. Upgrade Dependencies

The first file displayed is `package.json`. Update any dependencies listed there. For instance, if changes for `react-native` and `react` are shown, install them using the following commands:

- **Using npm:**

  ```shell
  # Replace {{VERSION}} and {{REACT_VERSION}} with the versions from the diff
  npm install react-native@{{VERSION}}
  npm install react@{{REACT_VERSION}}
  ```

- **Using Yarn:**

  ```shell
  # Replace {{VERSION}} and {{REACT_VERSION}} with the versions from the diff
  yarn add react-native@{{VERSION}}
  yarn add react@{{REACT_VERSION}}
  ```

##### 3. Upgrade Project Files

New releases may include updates to files generated by `npx react-native init`. These files are listed after `package.json` on the Upgrade Helper page. If no additional changes are needed, simply rebuild your project. Otherwise, manually apply any necessary changes.

#### Troubleshooting

If you have made all required changes but your app still uses an old version, this issue is often related to caching. It's recommended to use react-native-clean-project to clear the cache and then rerun the process.

## TouchableWithoutFeedback

> For more comprehensive and future-proof handling of touch-based input, consider using the Pressable API. Use `TouchableWithoutFeedback` only if there is a compelling reason to do so. All elements that respond to press should provide visual feedback when touched.

`TouchableWithoutFeedback` supports only one child element. If multiple children are needed, wrap them in a `View`. It's important to note that `TouchableWithoutFeedback` works by cloning its child and applying responder props to it. Therefore, any intermediary components must pass these props through to the underlying React Native component.

### Usage Pattern

```typescript
function MyComponent(props: MyComponentProps) {
  return (
    <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>
      <Text>My Component</Text>
    </View>
  );
}

<TouchableWithoutFeedback onPress={() => alert('Pressed!')}>
  <MyComponent />
</TouchableWithoutFeedback>;
```

### Example

### Reference

### Props

|Prop Name|Description|Type|
|-|-|-|
|`accessibilityIgnoresInvertColors` (iOS)|Indicates whether the view should be inverted when color inversion is enabled. A value of `true` prevents inversion even if color inversion is turned on. See the Accessibility guide for more information.|Boolean|
|`accessible`|When set to `true`, marks the view as an accessibility element. By default, all touchable elements are accessible.|bool|
|`accessibilityLabel`|Overrides the text read by screen readers when interacting with the element. By default, it is constructed from all child `Text` nodes separated by spaces.|string|
|`accessibilityLanguage` (iOS)|Specifies the language used by the screen reader for this element, following the BCP 47 specification. See the iOS `accessibilityLanguage` documentation for more information.|string|
|`accessibilityHint`|Provides a hint to help users understand what will happen when they perform an action on the accessibility element if it's not clear from the label.|string|
|`accessibilityRole`|Communicates the purpose of a component to assistive technology users. Possible values include `'none'`, `'button'`, `'link'`, `'search'`, `'image'`, `'keyboardkey'`, `'text'`, `'adjustable'`, and more.|string|
|`accessibilityState`|Describes the current state of a component to assistive technology users. See the Accessibility guide for more information.|object: `{disabled, selected, checked, busy, expanded}`|
|`accessibilityActions`|Allows assistive technologies to programmatically invoke actions on a component. Each action should include a name and label. See the Accessibility guide for more details.|array|
|`aria-busy`|Indicates that an element is being modified and assistive technologies may want to wait until changes are complete before notifying the user.|boolean|
|`aria-checked`|Represents the state of a checkable element, which can be either a boolean or `'mixed'`.|boolean, 'mixed'|
|`aria-disabled`|Indicates that an element is perceivable but disabled and not editable or operable.|boolean|
|`aria-expanded`|Shows whether an expandable element is currently expanded or collapsed.|boolean|
|`aria-hidden`|Specifies if the accessibility elements within this element are hidden, affecting how assistive technologies like VoiceOver interact with sibling views.|boolean|
|`aria-label`|Provides a string value that labels an interactive element.|string|
|`aria-live` (Android)|Indicates updates to an element and describes the types of updates expected by user agents, assistive technologies, and users. Options include `'assertive'`, `'off'`, and `'polite'`.|enum: `'assertive'`, `'off'`, `'polite'`|
|`aria-modal` (iOS)|Boolean indicating whether VoiceOver should ignore sibling elements within views. Takes precedence over the `accessibilityViewIsModal` prop.|boolean|
|`aria-selected`|Indicates if a selectable element is currently selected.|boolean|
|`onAccessibilityAction`|Invoked when an accessibility action is performed by the user. The function receives an event containing the name of the action to perform. See the Accessibility guide for more information.|function|
|`accessibilityValue`|Represents a component's current value, either as a textual description or range information (min, max, now) for components like sliders and progress bars.|object: `{min, max, now, text}`|
|`aria-valuemax`|Specifies the maximum value for range-based components, taking precedence over the `max` value in the `accessibilityValue` prop.|number|
|`aria-valuemin`|Specifies the minimum value for range-based components, taking precedence over the `min` value in the `accessibilityValue` prop.|number|
|`aria-valuenow`|Represents the current value for range-based components, taking precedence over the `now` value in the `accessibilityValue` prop.|number|
|`aria-valuetext`|Provides a textual description of the component's value, taking precedence over the `text` value in the `accessibilityValue` prop.|string|
|`delayLongPress`|Duration (in milliseconds) from `onPressIn` before `onLongPress` is called.|number|
|`delayPressIn`|Duration (in milliseconds) from the start of a touch until `onPressIn` is invoked.|number|
|`delayPressOut`|Duration (in milliseconds) after releasing a touch before `onPressOut` is called.|number|
|`disabled`|If set to true, disables all interactions for this component.|bool|
|`hitSlop`|Defines how far from the button a touch can start. This value is added to `pressRetentionOffset` when moving off of the button. The touch area does not extend past parent view bounds and sibling views with higher Z-index take precedence if overlapping.|Rect or number|
|`id`|Used to locate this view from native code, taking precedence over the `nativeID` prop.|string|
|`onBlur`|Invoked when the item loses focus.|function|
|`onFocus`|Invoked when the item receives focus.|function|
|`onLayout`|Called on mount and during layout changes.|`({nativeEvent: LayoutEvent}) => void`|
|`onLongPress`|Triggered if the time after `onPressIn` exceeds 370 milliseconds, customizable with `delayLongPress`.|function|
|`onPress`|Called when a touch is released unless cancelled (e.g., by a scroll that steals the responder lock). The first argument is an event in form of PressEvent.|function|
|`onPressIn`|Invoked as soon as the touchable element is pressed, even before `onPress`. Useful for tasks like network requests. The first argument is an event in form of PressEvent.|function|
|`onPressOut`|Called immediately after a touch is released, prior to `onPress`. The first argument is an event in form of PressEvent.|function|
|`pressRetentionOffset`|Defines how far a touch may move off the button before deactivating it when the scroll view is disabled. Re-activation occurs upon moving back over the button. Pass a constant to reduce memory allocations.|Rect or number|
|`nativeID`||string|
|`testID`|Used to locate this view in end-to-end tests.|string|
|`touchSoundDisabled` (Android)|If set to true, prevents the system sound from playing on touch.|Boolean|

## View

#### Accessibility Properties

- **`accessibilityActions`**: Defines actions that can be performed on the view for accessibility purposes.

- **`accessibilityComponentType`**: Specifies the type of component for accessibility.

- **`accessibilityElementsHidden`**: Determines if accessibility elements are hidden.

- **`accessibilityHint`**: Provides a hint about what performing an action will do.

- **`accessibilityIgnoresInvertColors`**: Indicates whether to ignore invert colors settings.

- **`accessibilityLabel`**: A label for the view that is read by screen readers.

- **`accessibilityLiveRegion`**: Defines how updates are announced by screen readers.

- **`accessibilityRole`**: Communicates the role of the component to assistive technologies.

- **`accessibilityState`**: Represents the state of accessibility elements.

- **`accessibilityStates`**: An array of states for accessibility elements.

- **`accessibilityTraits`**: Describes traits of the view for accessibility purposes.

- **`accessible`**: Indicates if the view is accessible.

- **`onAccessibilityAction`**: Callback invoked when an accessibility action is performed.

- **`onAccessibilityEscape`** (iOS): Invoked on escape gesture.

- **`onAccessibilityTap`** (iOS): Invoked on accessibility tap gesture.

- **`onMagicTap`** (iOS): Invoked on magic tap gesture.

#### Layout and Rendering Properties

- **`needsOffscreenAlphaCompositing`**: Determines if offscreen alpha compositing is needed for correct rendering.

- **`nextFocusDown/Forward/Left/Right/Up`** (Android): Designates the next view to receive focus in various directions.

- **`onLayout`**: Invoked when layout changes occur.

- **`removeClippedSubviews`**: Improves performance by removing offscreen subviews.

- **`renderToHardwareTextureAndroid`** (Android): Renders the view into a hardware texture for better performance during animations.

- **`shouldRasterizeIOS`** (iOS): Rasterizes the view to improve animation performance.

#### Interaction and Focus Properties

- **`onMoveShouldSetResponder`**: Determines if the view should become the responder on touch move.

- **`onMoveShouldSetResponderCapture`**: Allows a parent view to prevent a child from becoming the responder.

- **`onResponderGrant`**: Invoked when the view becomes the responder for touch events.

- **`onResponderMove`**: Triggered during finger movement.

- **`onResponderRelease`**: Fired at the end of a touch event.

- **`onResponderReject`**: Called if another responder takes over.

- **`onResponderTerminate`**: Invoked when the view loses its responder status.

- **`onResponderTerminationRequest`**: Requests to release the responder role.

- **`onStartShouldSetResponder`**: Determines if the view should become the responder on touch start.

- **`onStartShouldSetResponderCapture`**: Allows a parent view to prevent a child from becoming the responder on touch start.

#### Pointer Events

- **`pointerEvents`**: Controls whether the view can be the target of touch events. Options include `auto`, `none`, `box-none`, and `box-only`.

#### Identification Properties

- **`id`**: Unique identifier for the view.

- **`importantForAccessibility`** (Android): Determines if the view is important for accessibility.

- **`nativeID`**: Used to locate the view from native classes.

- **`testID`**: Identifier used in end-to-end tests.

#### Style and Role

- **`style`**: Defines the style of the view.

- **`role`**: Communicates the purpose of a component, with precedence over `accessibilityRole`.

This documentation provides comprehensive details on how to configure various aspects of a `View`, focusing on accessibility, layout, interaction, and identification.

## Style

In React Native, styling your application is done using JavaScript. Core components accept a `style` prop, which typically mirrors CSS conventions but uses camel casing for property names (e.g., `backgroundColor` instead of `background-color`).

### Using the `style` Prop

The `style` prop can be defined as a plain JavaScript object, which is common in example code. Alternatively, you can pass an array of styles; the last style in the array takes precedence, allowing for inheritance.

As components become more complex, it's often cleaner to use `StyleSheet.create` to define multiple styles in one place. Here’s how you might do this:

```typescript
import { StyleSheet } from "react-native"

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  text: {
    fontSize: 20,
    color: "blue",
  },
})
```

A common pattern is to allow a component to accept a `style` prop, which can then be used to style subcomponents. This approach enables styles to "cascade" similarly to CSS.

For more detailed customization of text styles, refer to the Text component reference for a comprehensive list.

### Enhancing Text Appearance

With these styling techniques, you can enhance your text's appearance significantly. The next step in mastering styling is learning how to control component size effectively.

### Known Issues

- **react-native#29308**: React Native sometimes deviates from web CSS behavior. For instance, the touch area does not extend beyond parent view bounds, and negative margins are unsupported on Android.

## Height and Width

A component's height and width determine its size on the screen.

### Fixed Dimensions

To set the dimensions of a component, you can add fixed `width` and `height` properties in the style. In React Native, all dimensions are unitless and represent density-independent pixels (dp).

Using fixed dimensions is typical for components that should maintain a constant size regardless of screen size.

> **Caution:** There isn't a universal conversion from points to physical units of measurement. Consequently, a component with fixed dimensions may not appear the same size across different devices and screens. However, this discrepancy is usually negligible in most scenarios.

### Flex Dimensions

To allow a component's size to adjust dynamically based on available space, use `flex` in its style. Typically, you'll set `flex: 1`, which instructs the component to occupy all available space, distributed evenly among siblings with the same parent. The larger the `flex` value assigned, the more space the component will take relative to its siblings.

> **Info:** A component can only expand to fill available space if its parent has dimensions greater than `0`. If a parent lacks either fixed `width` and `height` or `flex`, it defaults to dimensions of `0`, rendering flex children invisible.

Once you've mastered controlling a component's size, the next step is learning how to position it on the screen.

### Percentage Dimensions

To occupy a specific portion of the screen without using the `flex` layout, you can use **percentage values** in the component's style. Like flex dimensions, percentage dimensions require that the parent has defined dimensions.

## DrawerLayoutAndroid

The `DrawerLayoutAndroid` is a React component specifically designed for Android platforms. It encapsulates the platform's native `DrawerLayout`. This layout typically serves as a navigation drawer, which can be rendered using the `renderNavigationView` prop. The main content of your application resides within its direct children.

By default, the navigation view remains hidden and can be revealed by pulling it from the side of the screen specified by the `drawerPosition` prop. You can also adjust the width of the drawer using the `drawerWidth` prop.

### Example

- TypeScript
- JavaScript

### Reference

### Props

#### View Props

The component inherits all properties available to a standard React `View`.

#### `drawerBackgroundColor`

This property sets the background color for the drawer, with the default being white. To adjust opacity, use an RGBA value. For example:

```typescript
<DrawerLayoutAndroid drawerBackgroundColor="rgba(0,0,0,0.5)" />
```

- **Type**: `color`
- **Required**: No

#### `drawerLockMode`

This property determines how the drawer responds to user interactions. It can be set to one of three modes:

- `unlocked` (default): The drawer will open or close in response to touch gestures.

- `locked-closed`: The drawer remains closed and does not respond to gestures.

- `locked-open`: The drawer stays open but can still be programmatically opened or closed using `openDrawer`/`closeDrawer`.

- **Type**: `enum('unlocked', 'locked-closed', 'locked-open')`

- **Required**: No

#### `drawerPosition`

This property specifies from which side of the screen the drawer will slide in. The default is set to `left`.

- **Type**: `enum('left', 'right')`
- **Required**: No

#### `drawerWidth`

Defines the width of the drawer, specifically the portion that slides in from the edge of the window.

- **Type**: `number`
- **Required**: No

#### `keyboardDismissMode`

Determines if the keyboard should be dismissed when a drag gesture is detected. Options include:

- `'none'` (default): Drags do not dismiss the keyboard.

- `'on-drag'`: The keyboard is dismissed as soon as a drag begins.

- **Type**: `enum('none', 'on-drag')`

- **Required**: No

#### `onDrawerClose`

A callback function that triggers when the navigation view is closed.

- **Type**: `function`
- **Required**: No

#### `onDrawerOpen`

A callback function that triggers when the navigation view is opened.

- **Type**: `function`
- **Required**: No

#### `onDrawerSlide`

This function is called during any interaction with the navigation view, such as sliding it open or closed.

- **Type**: `function`
- **Required**: No

#### `onDrawerStateChanged`

A callback that fires when the drawer's state changes. The possible states are:

- `idle`: No interaction with the navigation view.

- `dragging`: An ongoing interaction with the navigation view.

- `settling`: Interaction has ended, and the navigation view is completing its animation.

- **Type**: `function`

- **Required**: No

#### `renderNavigationView`

This required prop defines the content of the navigation view that appears from the side of the screen.

- **Type**: `function`
- **Required**: Yes

#### `statusBarBackgroundColor`

Allows the drawer to extend over the status bar by setting its background color. This is effective only on API 21 and above.

- **Type**: `color`
- **Required**: No

### Methods

#### `closeDrawer()`

```typescript
closeDrawer()
```

Closes the navigation drawer.

#### `openDrawer()`

```typescript
openDrawer()
```

Opens the navigation drawer.

## Layout with Flexbox

Flexbox provides a consistent way to design layouts across different screen sizes. In React Native, it shares similarities with CSS on the web but has specific differences such as default values for properties like `flexDirection`, `alignContent`, and `flexShrink`.

### Key Properties of Flexbox

#### Flex

The `flex` property determines how items distribute space along the main axis within a container. For instance:

- A container view with `flex: 1`.
- Child views with `flex: 1`, `flex: 2`, and `flex: 3`.

This means the red, orange, and green views will occupy `1/6`, `2/6`, and `3/6` of the available space respectively.

#### Flex Direction

The `flexDirection` property controls the layout direction of children within a node:

- **column** (default): Top to bottom.
- **row**: Left to right.
- **column-reverse**: Bottom to top.
- **row-reverse**: Right to left.

#### Layout Direction

The `direction` property specifies text and child element orientation:

- **LTR** (default): Left-to-right layout.
- **RTL**: Right-to-left layout.

#### Justify Content

This property aligns children along the main axis of their container:

- **flex-start** (default)
- **flex-end**
- **center**
- **space-between**
- **space-around**
- **space-evenly**

#### Align Items

`alignItems` aligns children along the cross axis:

- **stretch** (default): Stretch to match the height of the container's cross axis.
- **flex-start**
- **flex-end**
- **center**
- **baseline**

#### Align Self

Similar to `alignItems`, but applies to individual children, allowing them to override their parent's alignment.

#### Align Content

`alignContent` manages the distribution of lines along the cross-axis when wrapping is enabled:

- **flex-start** (default)
- **flex-end**
- **stretch** (default on web with Yoga)
- **center**
- **space-between**
- **space-around**
- **space-evenly**

#### Flex Wrap

The `flexWrap` property controls how children are wrapped within a container:

- Default: Single line.
- Allows wrapping into multiple lines if necessary.

#### Flex Basis, Grow, and Shrink

These properties manage the default size, growth, and shrinkage of items:

- **flexBasis**: Default size along the main axis.
- **flexGrow**: Distribution of remaining space among children.
- **flexShrink**: Shrinking of children when overflow occurs.

#### Row Gap, Column Gap, and Gap

These properties define spacing between rows and columns:

- **rowGap**
- **columnGap**
- **gap** (shorthand for both)

#### Width and Height

Specifies the dimensions of an element's content area:

- **auto**: Default; calculated based on content.
- **pixels**: Absolute size in pixels.
- **percentage**: Relative to parent's dimension.

#### Position

Defines how elements are positioned relative to their containing block:

- **relative** (default): Positioned according to normal flow with offsets.
- **absolute**: Positioned independently of the layout flow.
- **static**: Normal flow positioning, ignoring offset values. Available only on the New Architecture.

### Containing Block

The containing block is an ancestor element that influences an absolutely positioned element's position and size. The `top`, `right`, `bottom`, and `left` properties are relative to this block. Percentage lengths for dimensions are calculated based on the containing block's size.

#### Determining the Containing Block

- **Relative or Static Position**: Parent is the containing block.
- **Absolute Position**: Nearest ancestor with a non-static position or transform property.

### Further Exploration

For deeper understanding, explore interactive tools like the yoga playground. The full list of layout-controlling props and examples from Wix Engineers are available for further study.

## Images

### Static Image Resources

React Native offers a unified approach for managing images and other media assets in Android and iOS applications. To add a static image, place it within your source code directory and reference it as follows:

```typescript
<Image source={require('./my-icon.png')} />
```

The image name is resolved similarly to how JavaScript modules are resolved. In the example above, the bundler searches for `my-icon.png` in the same folder as the component that requires it.

You can use the `@2x` and `@3x` suffixes to provide images for different screen densities. For instance, with this file structure:

```
.
├── button.js
└── img
    ├── check.png
    ├── check@2x.png
    └── check@3x.png
```

...and the `button.js` code containing:

```typescript
<Image source={require('./img/check.png')} />
```

...the bundler will bundle and serve the image corresponding to the device's screen density. For example, `check@2x.png` is used on an iPhone 7, while `check@3x.png` is used on an iPhone 7 Plus or a Nexus 5. If no matching image for the screen density exists, the closest available option will be selected.

On Windows, you might need to restart the bundler if new images are added to your project.

Benefits include:

1. A unified system across Android and iOS.
1. Images reside in the same folder as JavaScript code, making components self-contained.
1. No global namespace, avoiding name collisions.
1. Only used images are packaged into your app.
1. Adding or changing images doesn't require recompilation; you can refresh the simulator as usual.
1. The bundler knows image dimensions, eliminating the need to duplicate this information in code.
1. Images can be distributed via npm packages.

For this to work, the image name in `require` must be known statically:

```typescript
// GOOD
<Image source={require('./my-icon.png')} />;

// BAD
const icon = this.props.active
  ? 'my-icon-active'
  : 'my-icon-inactive';
<Image source={require('./' + icon + '.png')} />;

// GOOD
const icon = this.props.active
  ? require('./my-icon-active.png')
  : require('./my-icon-inactive.png');
<Image source={icon} />;
```

Note that image sources required in this manner include size (width, height) information. If you need to scale the image dynamically (e.g., via flex), you may need to manually set `{width: undefined, height: undefined}` on the style attribute.

### Static Non-Image Resources

The `require` syntax described above can also be used to statically include audio, video, or document files in your project. Common file types supported include `.mp3`, `.wav`, `.mp4`, `.mov`, `.html`, and `.pdf`. See bundler defaults for the full list.

You can add support for other types by adding an `assetExts` resolver option in your Metro configuration.

A caveat is that videos must use absolute positioning instead of `flexGrow`, as size information is not currently passed for non-image assets. This limitation does not occur for videos linked directly into Xcode or the Assets folder for Android.

### Images From Hybrid App's Resources

If you are building a hybrid app (some UIs in React Native, some in platform code), you can still use images already bundled into the app.

For images included via Xcode asset catalogs or the Android Assets folder, reference them by name:

```typescript
<Image source={{ uri: 'image-name' }} />
```

Note that you must specify some width and height style attributes.

### iOS Border Radius Styles

Please note that the following corner-specific border radius style properties might be ignored by iOS's image component:

- `borderTopLeftRadius`
- `borderTopRightRadius`
- `borderBottomLeftRadius`
- `borderBottomRightRadius`

### Off-thread Decoding

Image decoding can take more than a frame-worth of time, which is a major source of frame drops on the web because decoding is done in the main thread. In React Native, image decoding occurs in a different thread. Practically, you already handle cases where the image isn't downloaded yet, so displaying a placeholder for a few extra frames while it decodes doesn't require any code changes.

### Configuring iOS Image Cache Limits

On iOS, an API is available to override React Native's default image cache limits. This should be called from within your native AppDelegate code (e.g., within `didFinishLaunchingWithOptions`):

```objective-c
RCTSetImageCacheLimits(4*1024*1024, 200*1024*1024);
```

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|imageSizeLimit|number|Yes|Image cache size limit.|
|totalCostLimit|number|Yes|Total cache cost limit.|

In the example above, the image size limit is set to 4 MB and the total cost limit to 200 MB.

### Source as an Object

In React Native, the `src` attribute is named `source` and doesn't take a string but an object with a `uri` attribute:

```typescript
<Image source={{ uri: 'something.jpg' }} />
```

On the infrastructure side, this allows attaching metadata to the object. For example, if you use `require('./my-icon.png')`, information about its actual location and size is added (though relying on this fact might change in the future!). This approach also future-proofs for features like sprites, where instead of outputting `{uri: ...}`, we can output `{uri: ..., crop: {left: 10, top: 50, width: 20, height: 40}}` and transparently support spriting on all existing call sites.

On the user side, this lets you annotate the object with useful attributes such as image dimensions to compute its display size. Feel free to use it as your data structure for storing more information about your image.

### Background Image via Nesting

A common feature request from developers familiar with web development is `background-image`. To handle this use case, use the `<ImageBackground>` component, which has the same props as `<Image>`, and add any children you want to layer on top of it:

```typescript
return (
  <ImageBackground source={...} style={{ width: '100%', height: '100%' }}>
    <Text>Inside</Text>
  </ImageBackground>
);
```

Note that you must specify some width and height style attributes.

### Best Camera Roll Image

iOS saves multiple sizes for the same image in your Camera Roll. It's crucial to pick the one closest to your display size for performance reasons. For example, avoid using a full-quality 3264x2448 image as a source when displaying a 200x200 thumbnail. If there's an exact match, React Native will select it; otherwise, it uses the first one that's at least 50% larger to prevent blurring during resizing. This process is automatic, so you don't need to write tedious code for it.

### Why Not Automatically Size Everything?

*In the browser*, if no size is given to an image, the browser renders a 0x0 element, downloads the image, and then displays it with the correct size. The issue here is that your UI will jump around as images load, leading to a poor user experience known as Cumulative Layout Shift.

*In React Native*, this behavior isn't implemented intentionally. It requires more work for developers to know the dimensions (or aspect ratio) of remote images in advance, but it leads to a better user experience. Static images loaded from the app bundle via `require('./my-icon.png')` can be automatically sized because their dimensions are available immediately at mounting time.

For example, the result of `require('./my-icon.png')` might be:

```json
{ "__packager_asset": true, "uri": "my-icon.png", "width": 591, "height": 573 }
```

### iOS Border Radius Styles

Please note that the following corner-specific border radius style properties might be ignored by iOS's image component:

- `borderTopLeftRadius`
- `borderTopRightRadius`
- `borderBottomLeftRadius`
- `borderBottomRightRadius`

## TouchableNativeFeedback

> For a more comprehensive and future-proof approach to handling touch-based input, consider using the Pressable API.

TouchableNativeFeedback is an Android-specific wrapper designed to ensure views respond appropriately to touch interactions. It utilizes native state drawables to provide visual feedback during touches.

Currently, it supports only a single View instance as a child node by replacing that View with another RCTView node, which includes additional properties.

The background drawable for the native feedback touchable can be customized using the `background` property.

### Example

### Reference

### Props

#### TouchableWithoutFeedback Props

Inherits props from TouchableWithoutFeedback.

#### `background`

Specifies the type of background drawable used to display feedback. It requires an object with a `type` property and additional data based on that `type`. Using static methods to generate this dictionary is recommended.

- **Type**: `backgroundPropType`

#### `useForeground`

When set to true, adds a ripple effect to the foreground of the view instead of the background. This is useful if child views have their own backgrounds or when displaying images where you don't want the ripple covered by them.

Ensure to check `TouchableNativeFeedback.canUseNativeForeground()` first, as this feature is only available on Android 6.0 and above. Using it on older versions will trigger a warning and fallback to background usage.

- **Type**: `bool`

#### `hasTVPreferredFocus` (Android)

Indicates TV preferred focus (refer to the View component documentation).

- **Type**: `bool`

#### `nextFocusDown` (Android)

Specifies TV next focus down (see View component documentation).

- **Type**: `number`

#### `nextFocusForward` (Android)

Specifies TV next focus forward (see View component documentation).

- **Type**: `number`

#### `nextFocusLeft` (Android)

Specifies TV next focus left (see View component documentation).

- **Type**: `number`

#### `nextFocusRight` (Android)

Specifies TV next focus right (see View component documentation).

- **Type**: `number`

#### `nextFocusUp` (Android)

Specifies TV next focus up (see View component documentation).

- **Type**: `number`

### Methods

#### `SelectableBackground()`

```typescript
static SelectableBackground(
  rippleRadius: number | null,
): ThemeAttributeBackgroundPropType;
```

Generates an object representing the Android theme's default background for selectable elements (`?android:attr/selectableItemBackground`). The `rippleRadius` parameter controls the radius of the ripple effect.

#### `SelectableBackgroundBorderless()`

```typescript
static SelectableBackgroundBorderless(
  rippleRadius: number | null,
): ThemeAttributeBackgroundPropType;
```

Generates an object representing the Android theme's default background for borderless selectable elements (`?android:attr/selectableItemBackgroundBorderless`). This is available on Android API level 21+. The `rippleRadius` parameter controls the radius of the ripple effect.

#### `Ripple()`

```typescript
static Ripple(
  color: ColorValue,
  borderless: boolean,
  rippleRadius?: number | null,
): RippleBackgroundPropType;
```

Creates an object representing a ripple drawable with a specified color (as a string). If the `borderless` property is true, the ripple will render outside of the view bounds (similar to native action bar buttons). This background type is available on Android API level 21+.

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|color|string|Yes|The ripple color|
|borderless|boolean|Yes|Determines if the ripple can render outside bounds|
|rippleRadius|?number|No|Controls the radius of the ripple effect|

#### `canUseNativeForeground()`

```typescript
static canUseNativeForeground(): boolean;
```

## InputAccessoryView

The `InputAccessoryView` component allows for customization of the keyboard input accessory view on iOS. This view appears above the keyboard when a `TextInput` is focused, enabling the creation of custom toolbars.

To utilize this component, wrap your custom toolbar with `InputAccessoryView` and assign it a `nativeID`. Then, use that `nativeID` as the `inputAccessoryViewID` for any desired `TextInput`. Here's a basic example:

This component can also facilitate sticky text inputs—text inputs anchored to the top of the keyboard. To achieve this, wrap a `TextInput` with `InputAccessoryView` without setting a `nativeID`. For an example, refer to `InputAccessoryViewExample.js`.

### Reference

#### Props

##### `backgroundColor`

|Type|
|-|
|color|

##### `nativeID`

A unique identifier used to associate this `InputAccessoryView` with specific TextInput(s).

|Type|
|-|
|string|

##### `style`

|Type|
|-|
|View Style|

### Known Issues

- **react-native#18997**: Does not support multiline `TextInput`.
- **react-native#20157**: Incompatible with a bottom tab bar.

## SafeAreaView

The `SafeAreaView` component ensures that content is displayed within the safe area boundaries of a device. It's specifically designed for iOS devices running version 11 or later.

This component automatically adjusts padding to account for areas not covered by navigation bars, tab bars, toolbars, and other ancestor views. Importantly, it also considers physical screen limitations like rounded corners or camera notches (e.g., the sensor housing area on iPhone 13).

### Usage Example

To implement `SafeAreaView`, wrap your top-level view with it and apply a style of `flex: 1`. Consider using a background color that aligns with your application's design.

### Reference Details

#### Props

##### View Props

`SafeAreaView` inherits all View Props. Note that any padding specified in styles applied to a `SafeAreaView` will be ignored, as the component uses its own padding logic. This can lead to different results across platforms. For more details, refer to issue #22211.

## Image Style Props

### Examples

#### Image Resize Mode

#### Image Border

#### Image Border Radius

#### Image Tint

### Reference

### Properties

#### `backfaceVisibility`

This property specifies whether the back face of a rotated image should be visible.

|Type|Default|
|-|-|
|enum(`'visible'`, `'hidden'`)|`'visible'`|

***

#### `backgroundColor`

|Type|
|-|
|color|

***

#### `borderBottomLeftRadius`

|Type|
|-|
|number|

***

#### `borderBottomRightRadius`

|Type|
|-|
|number|

***

#### `borderColor`

|Type|
|-|
|color|

***

#### `borderRadius`

|Type|
|-|
|number|

***

#### `borderTopLeftRadius`

|Type|
|-|
|number|

***

#### `borderTopRightRadius`

|Type|
|-|
|number|

***

#### `borderWidth`

|Type|
|-|
|number|

***

#### `opacity`

Sets the opacity level for the image, with values ranging from `0.0` to `1.0`.

|Type|Default|
|-|-|
|number|`1.0`|

***

#### `overflow`

|Type|Default|
|-|-|
|enum(`'visible'`, `'hidden'`)|`'visible'`|

***

#### `overlayColor` (Android)

When an image has rounded corners, specifying an `overlayColor` will fill the remaining corner space with a solid color. This is particularly useful for resize modes like `'contain'` and animated GIFs that are not fully supported by Android's implementation of rounded corners.

A common use case involves images on a solid background where the `overlayColor` matches the background color.

For more details, refer to the Fresco documentation.

|Type|
|-|
|string|

***

#### `resizeMode`

Defines how an image should be resized when its frame dimensions do not match the raw image dimensions. The default mode is `cover`.

- **`cover`:** Scale the image uniformly (maintaining aspect ratio) so that:

  - Both dimensions of the image are equal to or larger than those of the view (minus padding).
  - At least one dimension matches the corresponding dimension of the view (minus padding).

- **`contain`:** Scale the image uniformly (maintaining aspect ratio) so that both dimensions are equal to or less than those of the view (minus padding).

- **`stretch`:** Independently scale width and height, potentially altering the aspect ratio.

- **`repeat`:** Repeat the image to cover the frame. The image retains its size and aspect ratio unless larger than the view, in which case it is scaled down uniformly to fit within the view.

- **`center`:** Center the image along both dimensions. If larger than the view, scale it down uniformly to fit within the view.

|Type|Default|
|-|-|
|enum(`'cover'`, `'contain'`, `'stretch'`, `'repeat'`, `'center'`)|`'cover'`|

***

#### `objectFit`

Specifies how an image should be resized when its frame dimensions do not match the raw image dimensions.

|Type|Default|
|-|-|
|enum(`'cover'`, `'contain'`, `'fill'`, `'scale-down'`)|`'cover'`|

***

#### `tintColor`

Alters the color of all non-transparent pixels to the specified `tintColor`.

|Type|
|-|
|color|

## Shadow Props

- TypeScript
- JavaScript

### Overview

React Native provides three sets of APIs for implementing shadows:

1. **`boxShadow`:** A View style prop that aligns with the web's spec-compliant shadow implementation.
1. **`dropShadow`:** Available as a filter function within the `filter` View style prop.
1. **Native Shadow Props:** These include `shadowColor`, `shadowOffset`, `shadowOpacity`, and `shadowRadius`, which directly correspond to native platform-level APIs.

#### Differences Between `dropShadow` and `boxShadow`

- **Location:**

  - `dropShadow` is part of the `filter` prop, while `boxShadow` stands alone.

- **Rendering:**

  - `dropShadow` uses an alpha mask, casting shadows only for pixels with positive alpha values. In contrast, `boxShadow` casts around the element's border box regardless of its contents unless it is inset.

- **Platform Availability:**

  - `dropShadow` is exclusive to Android; `boxShadow` works on both iOS and Android.

- **Inset Capability:**

  - Unlike `boxShadow`, `dropShadow` cannot be inset.

- **Spread Distance:**
  - `dropShadow` lacks the `spreadDistance` feature available in `boxShadow`.

While `boxShadow` and `dropShadow` offer more advanced capabilities, native shadow props are recommended for straightforward shadows. Note that only `shadowColor` is supported on both Android and iOS; other shadow properties function solely on iOS.

### Properties

#### `boxShadow`

Refer to View Style Props documentation for details.

#### `dropShadow` (Android)

Refer to View Style Props documentation for details.

#### `shadowColor`

Sets the drop shadow color. This property functions only on Android API 28 and above. For similar effects on lower APIs, use the `elevation` property.

|Type|
|-|
|color|

#### `shadowOffset` (iOS)

Defines the drop shadow offset.

|Type|
|-|
|object: `{width: number,height: number}`|

#### `shadowOpacity` (iOS)

Determines the drop shadow opacity, factoring in the color's alpha component.

|Type|
|-|
|number|

#### `shadowRadius` (iOS)

Specifies the drop shadow blur radius.

|Type|
|-|
|number|

## Text Style Props

### Example

- TypeScript
- JavaScript

### Reference

### Properties

#### `color`

- **Type**: color

#### `fontFamily`

- **Type**: string

#### `fontSize`

- **Type**: number

#### `fontStyle`

- **Type**: enum
  - `'normal'`
  - `'italic'`

#### `fontWeight`

Specifies the font weight. The values `'normal'` and `'bold'` are supported for most fonts. If a font does not have variants for all numeric values, the closest available variant is used.

- **Type**: enum or number
  - `'normal'`
  - `'bold'`
  - `'100'`
  - `'200'`
  - `'300'`
  - `'400'`
  - `'500'`
  - `'600'`
  - `'700'`
  - `'800'`
  - `'900'`
- **Default**: `'normal'`

#### `includeFontPadding` (Android)

Set to `false` to remove extra font padding, which is intended for certain ascenders and descenders. This can help align text better when centered vertically. For optimal results, also set `textAlignVertical` to `center`.

- **Type**: bool
- **Default**: `true`

#### `fontVariant`

Allows setting all font variants using an array of enums or a space-separated string (e.g., `'small-caps common-ligatures'`).

- **Type**: array of enum or string
  - `'small-caps'`
  - `'oldstyle-nums'`
  - `'lining-nums'`
  - `'tabular-nums'`
  - `'proportional-nums'`
- **Default**: `[]`

#### `letterSpacing`

Adjusts the spacing between characters. By default, there is no extra letter spacing.

- **Type**: number

#### `lineHeight`

Controls vertical spacing between lines of text within a text element by specifying the distance between baselines of consecutive lines.

- **Type**: number

#### `textAlign`

Specifies text alignment. On Android, `'justify'` is supported only on Oreo (8.0) or above (API level >= 26). It falls back to `left` on lower versions.

- **Type**: enum
  - `'auto'`
  - `'left'`
  - `'right'`
  - `'center'`
  - `'justify'`
- **Default**: `'auto'`

#### `textAlignVertical` (Android)

- **Type**: enum
  - `'auto'`
  - `'top'`
  - `'bottom'`
  - `'center'`
- **Default**: `'auto'`

#### `textDecorationColor` (iOS)

- **Type**: color

#### `textDecorationLine`

- **Type**: enum
  - `'none'`
  - `'underline'`
  - `'line-through'`
  - `'underline line-through'`
- **Default**: `'none'`

#### `textDecorationStyle` (iOS)

- **Type**: enum
  - `'solid'`
  - `'double'`
  - `'dotted'`
  - `'dashed'`
- **Default**: `'solid'`

#### `textShadowColor`

- **Type**: color

#### `textShadowOffset`

- **Type**: object
  ```typescript
  { width?: number; height?: number }
  ```

#### `textShadowRadius`

- **Type**: number

#### `textTransform`

- **Type**: enum
  - `'none'`
  - `'uppercase'`
  - `'lowercase'`
  - `'capitalize'`
- **Default**: `'none'`

#### `verticalAlign` (Android)

- **Type**: enum
  - `'auto'`
  - `'top'`
  - `'bottom'`
  - `'middle'`
- **Default**: `'auto'`

#### `writingDirection` (iOS)

- **Type**: enum
  - `'auto'`
  - `'ltr'`
  - `'rtl'`
- **Default**: `'auto'`

#### `userSelect`

Allows text selection and native copy-paste functionality, taking precedence over the `selectable` prop.

- **Type**: enum
  - `'auto'`
  - `'text'`
  - `'none'`
  - `'contain'`
  - `'all'`
- **Default**: `none`

## View Style Props

### Example

### Reference

### Properties

#### `backfaceVisibility`

- **Type**: `enum('visible', 'hidden')`

#### `backgroundColor`

- **Type**: `color`

#### `borderBottomColor`

- **Type**: `color`

#### `borderBottomEndRadius`

- **Type**: `number`

#### `borderBottomLeftRadius`

- **Type**: `number`

#### `borderBottomRightRadius`

- **Type**: `number`

#### `borderBottomStartRadius`

- **Type**: `number`

#### `borderStartEndRadius`

- **Type**: `number`

#### `borderStartStartRadius`

- **Type**: `number`

#### `borderEndEndRadius`

- **Type**: `number`

#### `borderEndStartRadius`

- **Type**: `number`

#### `borderBottomWidth`

- **Type**: `number`

#### `borderColor`

- **Type**: `color`

#### `borderCurve` (iOS)

On iOS 13+, it is possible to change the corner curve of borders.

- **Type**: `enum('circular', 'continuous')`

#### `borderEndColor`

- **Type**: `color`

#### `borderLeftColor`

- **Type**: `color`

#### `borderLeftWidth`

- **Type**: `number`

#### `borderRadius`

If the rounded border is not visible, try applying `overflow: 'hidden'` as well.

- **Type**: `number`

#### `borderRightColor`

- **Type**: `color`

#### `borderRightWidth`

- **Type**: `number`

#### `borderStartColor`

- **Type**: `color`

#### `borderStyle`

- **Type**: `enum('solid', 'dotted', 'dashed')`

#### `borderTopColor`

- **Type**: `color`

#### `borderTopEndRadius`

- **Type**: `number`

#### `borderTopLeftRadius`

- **Type**: `number`

#### `borderTopRightRadius`

- **Type**: `number`

#### `borderTopStartRadius`

- **Type**: `number`

#### `borderTopWidth`

- **Type**: `number`

#### `borderWidth`

- **Type**: `number`

#### `boxShadow`

**Note:**\
`boxShadow` is only available on the New Architecture. Outset shadows are supported on Android 9+, and inset shadows on Android 10+. This prop adds a shadow effect to an element, allowing control over position, color, size, and blurriness of the shadow. It can be either outside or inside the border box depending on whether it is *inset*. This implementation follows web standards.

Multiple shadows can be combined into a single `boxShadow`.

- **Type**: `array of BoxShadowValue objects | string`

#### `cursor` (iOS)

On iOS 17+, setting to `pointer` enables hover effects when using a pointer device or gaze on visionOS.

- **Type**: `enum('auto', 'pointer')`

#### `elevation` (Android)

Sets the elevation of a view, adding a drop shadow and affecting z-order for overlapping views. Supported only on Android 5.0+; has no effect on earlier versions.

- **Type**: `number`

#### `filter`

**Note:**\
Adds graphical filters to the `View`, which can include multiple filter functions representing atomic changes. Filters apply to both the `View` and its descendants, implying `overflow: hidden`.

The following filter functions are cross-platform:

- `brightness`: Adjusts brightness (non-negative number or percentage).
- `opacity`: Changes opacity/alpha (non-negative number or percentage).

**Note:**\
On iOS, only `brightness` and `opacity` are available due to performance and compliance issues. Android plans to use SwiftUI for potential workarounds.

Android-specific filter functions:

- `blur`: Applies Gaussian blur with a specified radius (DIP value).

- `contrast`: Adjusts contrast (non-negative number or percentage).

- `dropShadow`: Adds shadow around alpha mask; requires color, offsets, and optional standard deviation.

- `grayscale`: Converts to grayscale by amount (non-negative number or percentage).

- `hueRotate`: Rotates hue on a color wheel (angle with `deg` or `rad` units).

- **Note:**\
  `blur` and `dropShadow` are supported only on Android 12+.

- `invert`: Inverts colors (non-negative number or percentage).

- `sepia`: Converts to sepia by amount (non-negative number or percentage).

- `saturate`: Changes saturation (non-negative number or percentage).

- **Type**: `array of objects: {brightness: number|string}, {opacity: number|string}, {blur: number|string}, {contrast: number|string}, {dropShadow: DropShadowValue|string}, {grayscale: number|string}, {hueRotate: number|string}, {invert: number|string}, {sepia: number|string}, {saturate: number|string}` or `string`

#### `opacity`

- **Type**: `number`

#### `outlineColor`

**Note:**\
Sets the color of an element's outline. See web documentation for more details.

- **Type**: `color`

#### `outlineOffset`

**Note:**\
Sets space between an outline and element bounds without affecting layout. See web documentation for more details.

- **Type**: `number`

#### `outlineStyle`

**Note:**\
Sets the style of an element's outline. See web documentation for more details.

- **Type**: `enum('solid', 'dotted', 'dashed')`

#### `outlineWidth`

**Note:**\
Defines the width of an outline drawn outside the border, without affecting layout. See web documentation for more details.

- **Type**: `number`

#### `pointerEvents`

Controls whether a `View` can be targeted by touch events:

- `'auto'`: The View can be targeted.

- `'none'`: The View is never targeted.

- `'box-none'`: Subviews can be targeted, but not the View itself.

- `'box-only'`: Only the View can be targeted, not its subviews.

- **Type**: `enum('auto', 'box-none', 'box-only', 'none')`

## BoxShadowValue Object Type

The `BoxShadowValue` object is utilized by the `boxShadow` style property. It consists of two to four length values, an optional color specification, and an optional boolean for inset shadows. These elements collectively define the shadow's color, position, size, and blurriness.

### Example

```typescript
{
  offsetX: 10,
  offsetY: -3,
  blurRadius: '15px',
  spreadDistance: '10px',
  color: 'red',
  inset: true,
}
```

### Keys and Values

#### `offsetX`

The x-axis offset, which can be positive or negative. A positive value indicates a rightward direction, while a negative value indicates leftward.

- **Type**: number | string
- **Optional**: No

#### `offsetY`

The y-axis offset, which can also be positive or negative. A positive value indicates an upward direction, and a negative value indicates downward.

- **Type**: number | string
- **Optional**: No

#### `blurRadius`

This represents the radius used in the Gaussian blur algorithm. Larger values result in a blurrier shadow. Only non-negative values are valid; the default is 0.

- **Type**: number | string
- **Optional**: Yes

#### `spreadDistance`

Determines how much larger or smaller the shadow grows or shrinks. A positive value enlarges the shadow, while a negative value reduces it.

- **Type**: number | string
- **Optional**: Yes

#### `color`

Specifies the color of the shadow. The default is `black`.

- **Type**: color
- **Optional**: Yes

#### `inset`

Indicates whether the shadow is inset or not. Inset shadows appear inside the element's border box, rather than outside.

- **Type**: boolean
- **Optional**: Yes

### Used by

- `boxShadow`

## Handling Touches

Users primarily interact with mobile applications through touch gestures such as tapping buttons, scrolling lists, or zooming maps. React Native offers components to manage common gestures and a comprehensive gesture responder system for advanced recognition. The `Button` component is particularly useful for basic interactions.

### Displaying a Basic Button

The `Button` component in React Native provides an easy way to create buttons that look consistent across platforms. Here's a minimal example:

```typescript
<Button
  onPress={() => {
    console.log('You tapped the button!');
  }}
  title="Press Me"
/>
```

On iOS, this renders as a blue label, while on Android it appears as a blue rounded rectangle with light text. Pressing the button triggers the `onPress` function, which logs a message to the console in this example. You can customize the button's color using the `color` prop.

Experiment with the `Button` component by adjusting platform settings and previewing changes.

### Touchables

For more customized buttons, React Native offers "Touchable" components that capture tapping gestures and provide feedback. These components require additional styling to fit your app's design.

Choose a "Touchable" component based on desired feedback:

- **TouchableHighlight**: Darkens the background when pressed, suitable for button or link-like interactions.

- **TouchableNativeFeedback**: On Android, it shows ink surface ripples in response to touch.

- **TouchableOpacity**: Reduces opacity during press, allowing background visibility.

- **TouchableWithoutFeedback**: Detects taps without providing visual feedback.

Long presses can be detected by using the `onLongPress` prop with any "Touchable" component.

### Scrolling and Swiping

For gestures like swipes and pans, which are common on touch devices, consider using the ScrollView Core Component to enable scrolling through lists or content pages.

### Known Issues

- **react-native#29308**: The touch area does not extend beyond parent view bounds, and negative margins are unsupported on Android.

## DropShadowValue Object Type

The `DropShadowValue` object is utilized by the `filter` style property for implementing the `dropShadow` function. It consists of two or three length values and an optional color, which together define the drop shadow's characteristics such as its color, position, and blurriness.

### Example

```typescript
{
  offsetX: 10,
  offsetY: -3,
  standardDeviation: '15px',
  color: 'blue',
}
```

### Keys and Values

#### `offsetX`

The offset on the x-axis. This value can be either positive or negative, where a positive value indicates a rightward shift and a negative value indicates a leftward shift.

|Type|Optional|
|-|-|
|number \| string|No|

#### `offsetY`

The offset on the y-axis. Similar to `offsetX`, this value can be either positive or negative, with a positive value indicating an upward shift and a negative value indicating a downward shift.

|Type|Optional|
|-|-|
|number \| string|No|

#### `standardDeviation`

This represents the standard deviation used in the Gaussian blur algorithm. A larger value results in a blurrier shadow. Only non-negative values are valid, with the default being 0.

|Type|Optional|
|-|-|
|number \| string|Yes|

#### `color`

The color of the shadow. By default, this is set to `black`.

|Type|Optional|
|-|-|
|color|Yes|

### Used by

- `filter`

## LayoutEvent Object Type

The `LayoutEvent` object is provided in the callback following a layout change of a component, such as when using the `onLayout` event in a View component.

### Example

```typescript
{
    layout: {
        width: 520,
        height: 70.5,
        x: 0,
        y: 42.5
    },
    target: 1127
}
```

### Keys and Values

#### `height`

Represents the component's height after a layout change.

|Type|Optional|
|-|-|
|number|No|

#### `width`

Indicates the component's width following a layout change.

|Type|Optional|
|-|-|
|number|No|

#### `x`

Specifies the X coordinate of the component within its parent component.

|Type|Optional|
|-|-|
|number|No|

#### `y`

Denotes the Y coordinate of the component inside its parent component.

|Type|Optional|
|-|-|
|number|No|

#### `target`

Identifies the node ID of the element that receives the PressEvent. It can be a number, or it may be `null` or `undefined`.

|Type|Optional|
|-|-|
|number, `null`, `undefined`|No|

### Components Utilizing LayoutEvent

- Image
- Pressable
- ScrollView
- Text
- TextInput
- TouchableWithoutFeedback
- View

## PressEvent Object Type

The `PressEvent` object is returned in the callback as a result of user press interactions, such as those triggered by the `onPress` event in Button components.

### Example

```typescript
{
    changedTouches: Array<PressEvent>,
    identifier: number,
    locationX: number,
    locationY: number,
    pageX: number,
    pageY: number,
    target: number | null | undefined,
    timestamp: number,
    touches: Array<PressEvent>
}
```

### Keys and Values

#### `changedTouches`

An array containing all `PressEvents` that have changed since the last event.

|Type|Optional|
|-|-|
|Array of PressEvents|No|

#### `force` (iOS)

The amount of force used during a 3D Touch press, represented as a float value ranging from `0.0` to `1.0`.

|Type|Optional|
|-|-|
|number|Yes|

#### `identifier`

A unique numeric identifier assigned to the event.

|Type|Optional|
|-|-|
|number|No|

#### `locationX`

The X coordinate of the touch origin within the touchable area, relative to the element.

|Type|Optional|
|-|-|
|number|No|

#### `locationY`

The Y coordinate of the touch origin within the touchable area, relative to the element.

|Type|Optional|
|-|-|
|number|No|

#### `pageX`

The X coordinate of the touch origin on the screen, relative to the root view.

|Type|Optional|
|-|-|
|number|No|

#### `pageY`

The Y coordinate of the touch origin on the screen, relative to the root view.

|Type|Optional|
|-|-|
|number|No|

#### `target`

The node ID of the element receiving the `PressEvent`. It can be a number or `null`/`undefined`.

|Type|Optional|
|-|-|
|number, null, undefined|No|

#### `timestamp`

A timestamp value indicating when the `PressEvent` occurred, represented in milliseconds.

|Type|Optional|
|-|-|
|number|No|

#### `touches`

An array containing all current `PressEvents` on the screen.

|Type|Optional|
|-|-|
|Array of PressEvents|No|

### Used By

- Button
- PanResponder
- Pressable
- ScrollView
- Text
- TextInput
- TouchableHighlight
- TouchableOpacity
- TouchableNativeFeedback
- TouchableWithoutFeedback
- View

## Rect Object Type

The `Rect` object type is designed to accept numeric pixel values, which are used to extend a rectangular area. These values modify the original dimensions of the rectangle.

### Example

```typescript
{
    bottom: 20,
    left: null,
    right: undefined,
    top: 50
}
```

### Keys and Values

#### `bottom`

|Type|Required|
|-|-|
|number, `null`, `undefined`|No|

#### `left`

|Type|Required|
|-|-|
|number, `null`, `undefined`|No|

#### `right`

|Type|Required|
|-|-|
|number, `null`, `undefined`|No|

#### `top`

|Type|Required|
|-|-|
|number, `null`, `undefined`|No|

### Used By

- `Image`
- `Pressable`
- `Text`
- `TouchableWithoutFeedback`

## Platform Support

- Android
- iOS
- macOS
- TV
- watchOS
- Web
- Windows
- visionOS

If your project constraints are not well-served by a Framework or you prefer creating your own, it's possible to develop a React Native app without using one. Begin by setting up your environment and follow the steps below to create an application.

### Step 1: Creating a New Application

> **Note:** If you have previously installed a global `react-native-cli` package, remove it to avoid unexpected issues:
>
> ```shell
> npm uninstall -g react-native-cli @react-native-community/cli
> ```

Use the React Native Community CLI to generate a new project. For example, create a new React Native project named "AwesomeProject":

```shell
npx @react-native-community/cli@latest init AwesomeProject
```

This step is unnecessary if you are integrating React Native into an existing application, using Expo, or adding Android support to an existing React Native project (refer to Integration with Existing Apps). Alternatively, a third-party CLI like Ignite CLI can be used for setup.

**Info:** If you encounter issues on iOS, try reinstalling dependencies by executing the following commands:

1. Navigate to the `ios` folder: `cd ios`
1. Install Bundler: `bundle install`
1. Install iOS dependencies with CocoaPods: `bundle exec pod install`

##### \[Optional] Using a Specific Version or Template

To start a new project with a specific React Native version, use the `--version` argument:

```shell
npx @react-native-community/cli@X.XX.X init AwesomeProject --version X.XX.X
```

You can also initiate a project using a custom template with the `--template` argument. More details are available in related documentation.

### Step 2: Start Metro

**Metro** is React Native's JavaScript build tool. To start the Metro development server, run one of these commands from your project folder:

- Using npm:

  ```shell
  npm start
  ```

- Using Yarn:

  ```shell
  yarn start
  ```

**Note:** For those familiar with web development, Metro is akin to bundlers like Vite and webpack but tailored for React Native. It uses Babel to transform syntax such as JSX into executable JavaScript.

### Step 3: Start Your Application

Keep the Metro Bundler running in its own terminal. Open a new terminal within your project folder and execute one of these commands:

- Using npm:

  ```shell
  npm run android
  ```

- Using Yarn:

  ```shell
  yarn android
  ```

If everything is configured correctly, your app should appear on the Android emulator shortly. Alternatively, you can launch it directly from within Android Studio.

> If issues arise, consult the Troubleshooting page for assistance.

### Step 4: Modifying Your App

With the app running successfully, proceed to modify it:

- Open `App.tsx` in your preferred text editor and make changes.
- Reload the app by pressing `R` twice or selecting `Reload` from the Dev Menu (`Ctrl + M`) to view updates.

### Congratulations!

You've run and modified your first barebone React Native app successfully.

#### Next Steps

- To integrate this new React Native code into an existing application, refer to the Integration guide.
- For more insights on React Native, explore the Introduction to React Native.

## Navigating Between Screens

Mobile applications typically consist of multiple screens, necessitating effective management of screen presentation and transitions. This is often achieved using a navigator component. This guide explores various navigation components available in React Native, with a focus on React Navigation for straightforward stack and tabbed navigation patterns across both Android and iOS platforms.

For projects integrating React Native into existing apps that manage navigation natively or seeking alternatives to React Navigation, consider the `react-native-navigation` library, which offers native navigation solutions for both platforms.

### React Navigation

React Navigation is a community-driven standalone library designed to simplify screen setup in an app with minimal code.

#### Installation and Setup

To begin using React Navigation, install the necessary packages:

```shell
npm install @react-navigation/native @react-navigation/native-stack
```

Next, install peer dependencies based on your project type:

- **Expo Managed Project:**

  ```shell
  npx expo install react-native-screens react-native-safe-area-context
  ```

- **Bare React Native Project:**

  ```shell
  npm install react-native-screens react-native-safe-area-context
  ```

  For iOS, ensure CocoaPods is installed and run:

  ```shell
  cd ios
  pod install
  cd ..
  ```

> Note: Post-installation warnings related to peer dependencies are common due to version range issues in some packages. These can generally be ignored if the app builds successfully.

Wrap your entire application within a `NavigationContainer`, typically done in your entry file (`index.js` or `App.js`):

```typescript
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';

const App = () => {
  return (
    <NavigationContainer>
      {/* Rest of your app code */}
    </NavigationContainer>
  );
};

export default App;
```

#### Usage

Create an application with a home screen and a profile screen as follows:

```typescript
import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

const Stack = createNativeStackNavigator();

const MyStack = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen
          name="Home"
          component={HomeScreen}
          options={{ title: 'Welcome' }}
        />
        <Stack.Screen name="Profile" component={ProfileScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

In this setup, two screens (`Home` and `Profile`) are defined using the `Stack.Screen` component. You can define additional screens as needed.

Options such as screen titles can be set via the `options` prop of `Stack.Screen`.

Each screen requires a `component` prop that is a React component. These components receive a `navigation` prop, which includes methods to navigate between screens. For instance, use `navigation.navigate` to transition to the `Profile` screen:

```typescript
const HomeScreen = ({ navigation }) => {
  return (
    <Button
      title="Go to Jane's profile"
      onPress={() =>
        navigation.navigate('Profile', { name: 'Jane' })
      }
    />
  );
};

const ProfileScreen = ({ navigation, route }) => {
  return <Text>This is {route.params.name}'s profile</Text>;
};
```

The `native-stack` navigator leverages native APIs (`UINavigationController` on iOS and `Fragment` on Android), ensuring consistent behavior and performance with natively built apps.

React Navigation also offers packages for different navigators, such as tabs and drawers, enabling various navigation patterns in your app. For a comprehensive introduction to React Navigation, refer to the React Navigation Getting Started Guide.

## Troubleshooting

This guide addresses common issues encountered during the setup of React Native. If you face an issue not listed here, consider searching for it on GitHub.

### Port Already in Use

The Metro bundler typically runs on port 8081. If this port is occupied by another process, you can either terminate that process or configure the bundler to use a different port.

#### Terminating a Process on Port 8081

To find and terminate the process using port 8081:

- **Linux/macOS:**

  ```shell
  sudo lsof -i :8081
  ```

  Identify the PID from the output, then run:

  ```shell
  kill -9 <PID>
  ```

- **Windows:** Use Resource Monitor to find and Task Manager to stop the process using port 8081.

#### Using a Different Port

Configure the bundler to use an alternative port by specifying it in your start command:

- **npm:**

  ```shell
  npm start -- --port=8088
  ```

- **Yarn:**

  ```shell
  yarn start --port 8088
  ```

Update your application configurations to load the JavaScript bundle from this new port. For iOS, modify occurrences of `8081` in the `ios/__App_Name__.xcodeproj/project.pbxproj` file.

### NPM Locking Error

If you encounter an error like `npm WARN locking Error: EACCES`, try running:

```shell
sudo chown -R $USER ~/.npm
sudo chown -R $USER /usr/local/lib/node_modules
```

### Missing Libraries for React

Ensure all necessary dependencies are included if React Native is added manually. Link the binaries built by these dependencies to your app binary using the `Linked Frameworks and Binaries` section in Xcode project settings.

For CocoaPods users, verify that React and its subspecs are specified in the `Podfile`. For example:

```ruby
pod 'React', :path => '../node_modules/react-native', :subspecs => [
  'RCTText',
  'RCTImage',
  'RCTNetwork',
  'RCTWebSocket',
]
```

Run `pod install` to create a `Pods/` directory with React installed. Use the generated `.xcworkspace` file for subsequent builds.

#### Additional CocoaPods Issues

- **React Native does not compile as a CocoaPod:** Consider using the `cocoapods-fix-react-native` plugin.

- **Argument list too long error:** Ensure `User Search Header Paths` and `Header Search Paths` are set to defaults by CocoaPods. Remove any custom overrides in Xcode's Build Settings.

### No Transports Available

React Native includes a WebSocket polyfill initialized with `import React from 'react'`. If using modules like Firebase that require WebSockets, ensure they are imported after React:

```javascript
import React from "react"
import Firebase from "firebase"
```

### Shell Command Unresponsive Exception

If you encounter an error such as:

```
Execution failed for task ':app:installDebug'.
  com.android.builder.testing.api.DeviceException: com.android.ddmlib.ShellCommandUnresponsiveException
```

Try downgrading your Gradle version to 1.2.3 in `android/build.gradle`.

### react-native init Hangs

If `npx react-native init` hangs, run it again with verbose mode:

```shell
npx react-native init --verbose
```

Refer to issue #2797 for common causes.

For more detailed logs during debugging, use the verbose option:

- **npm:**

  ```shell
  npm run android -- --verbose
  ```

- **Yarn:**

  ```shell
  yarn android --verbose
  ```

### Unable to Start React Native Package Manager (Linux)

#### Case 1: Error "code":"ENOSPC","errno":"ENOSPC"

This issue arises from the limit on directories inotify can monitor. Resolve it by running:

```shell
echo fs.inotify.max_user_watches=582222 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
```

#### Error: spawnSync ./gradlew EACCES

If executing `npm run android` or `yarn android` on macOS results in this error, make the `gradlew` file executable:

```shell
sudo chmod +x android/gradlew
```

## Animations

Animations enhance user experience by simulating physically believable motion in interfaces. React Native offers two animation systems: `Animated` for detailed control and `LayoutAnimation` for global layout transitions.

### `Animated` API

The `Animated` API allows expressive, performant animations through declarative relationships between inputs and outputs. It includes six animatable components: `View`, `Text`, `Image`, `ScrollView`, `FlatList`, and `SectionList`. Custom animated components can be created using `Animated.createAnimatedComponent()`.

#### Example

A container view that fades in on mount:

```typescript
import React, { useRef } from 'react';
import { Animated, View } from 'react-native';

const FadeInView = (props) => {
  const fadeAnim = useRef(new Animated.Value(0)).current;

  React.useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  }, [fadeAnim]);

  return (
    <Animated.View
      style={{
        ...props.style,
        opacity: fadeAnim,
      }}
    >
      {props.children}
    </Animated.View>
  );
};
```

#### Key Features

- **Native Driver**: Use `useNativeDriver: true` for better performance by offloading animations to the native thread.

- **Gesture Mapping**: Map gestures directly to animated values using `Animated.event`.

- **Responding to Values**: Use `addListener` or `stopAnimation` to respond to animation states.

#### Caveats

Not all properties are supported with the native driver. Only non-layout properties like `transform` and `opacity` can be animated natively.

### `LayoutAnimation` API

`LayoutAnimation` configures global animations for layout changes, useful for Flexbox updates without manual calculations. It requires enabling experimental features on Android:

```typescript
import { UIManager } from "react-native"

UIManager.setLayoutAnimationEnabledExperimental &&
  UIManager.setLayoutAnimationEnabledExperimental(true)
```

#### Usage Example

```typescript
import React, { useState } from 'react';
import { View, Button, LayoutAnimation, Platform } from 'react-native';

const ExpandableComponent = () => {
  const [expanded, setExpanded] = useState(false);

  if (Platform.OS === 'android') {
    UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
  }

  return (
    <View>
      <Button title="Toggle" onPress={() => {
        LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
        setExpanded(!expanded);
      }} />
      {expanded && <View style={{ height: 100, backgroundColor: 'lightblue' }} />}
    </View>
  );
};
```

### Additional Notes

- **`requestAnimationFrame`**: A polyfill for managing frame updates in animations.

- **`setNativeProps`**: Directly modify native component properties without re-rendering.

Optimize animations by using `shouldComponentUpdate`, `useNativeDriver`, or deferring work with `InteractionManager`. Monitor performance with the FPS Monitor tool.

## React Native: Building Cross-Platform Apps

React Native is an open-source framework designed for developing Android and iOS applications. It leverages React along with the native capabilities of each platform, allowing developers to use JavaScript to access platform-specific APIs and define UI components using React's component model.

### Understanding Views in Mobile Development

In both Android and iOS development, a **view** serves as the fundamental unit of user interface (UI). These are small rectangular elements on the screen that can display text, images, or respond to user interactions. Every visual element within an app, from lines of text to buttons, is considered a view. Some views can even contain other views, creating a hierarchical structure.

### Native Components in React Native

In traditional Android development, views are typically written using Kotlin or Java, while iOS developers use Swift or Objective-C. React Native bridges these platforms by allowing you to invoke native views through JavaScript via React components. At runtime, React Native translates these components into the corresponding native views for both Android and iOS. This ensures that React Native applications have a look, feel, and performance comparable to native apps. These platform-backed components are known as **Native Components**.

React Native provides a set of essential, ready-to-use Native Components called **Core Components**, which serve as building blocks for app development. However, it's important to note that this documentation references an older API version and should be updated to reflect the New Architecture.

Additionally, React Native allows developers to create custom Native Components tailored to their specific needs. There is also a vibrant ecosystem of community-contributed components available through resources like Native Directory.

### Core Components Overview

React Native includes numerous Core Components for various functionalities, from basic controls to activity indicators. These are documented in the API section. Key Core Components include:

|React Native UI Component|Android View|iOS View|Web Analog|Description|
|-|-|-|-|-|
|`<View>`|`<ViewGroup>`|`<UIView>`|A non-scrolling `<div>`|Acts as a container supporting layout with flexbox, style, touch handling, and accessibility controls.|
|`<Text>`|`<TextView>`|`<UITextView>`|`<p>`|Displays, styles, nests text strings, and handles touch events.|
|`<Image>`|`<ImageView>`|`<UIImageView>`|`<img>`|Used for displaying various types of images.|
|`<ScrollView>`|`<ScrollView>`|`<UIScrollView>`|`<div>`|A generic scrolling container that can hold multiple components and views.|
|`<TextInput>`|`<EditText>`|`<UITextField>`|`<input type="text">`|Enables user text input.|

In the following sections, you will learn how to combine these Core Components to understand React's workings better.

### Introduction to React Component APIs

React Native utilizes the same API structure as React components, so familiarity with React component APIs is essential for getting started. The next section provides a brief introduction or refresher on this topic. If you are already well-versed in React, feel free to proceed ahead.

A diagram illustrates that React Native's Core Components are a subset of React Components included with React Native.

## React Fundamentals

React Native is built upon React, a widely-used open-source library for creating user interfaces with JavaScript. Understanding React can enhance your experience with React Native. This section introduces the fundamental concepts of React:

- Components
- JSX
- Props
- State

For more in-depth knowledge, consider exploring React’s official documentation.

### Your First Component

This introduction to React uses cats as examples: friendly creatures that need names and a cafe to work in. Here's how you create your first `Cat` component:

Start by importing React and the `Text` Core Component from React Native using JavaScript’s `import` statement:

```typescript
import React from "react"
import { Text } from "react-native"
```

Define your `Cat` component as a function:

```typescript
const Cat = () => {}
```

Components act like blueprints, and what a function component returns is rendered as a **React element**. These elements describe the desired screen output.

The `Cat` component will render a `<Text>` element:

```typescript
const Cat = () => {
  return <Text>Hello, I am your cat!</Text>;
};
```

Export your function component using JavaScript’s `export default` for use throughout your app:

```typescript
const Cat = () => {
  return <Text>Hello, I am your cat!</Text>;
};

export default Cat;
```

> This is one of several ways to export a component. Depending on your app's file structure, you might need a different convention. A cheatsheet on JavaScript imports and exports can be helpful.

The `return` statement uses JSX syntax: `<Text>Hello, I am your cat!</Text>`.

### JSX

React and React Native utilize **JSX**, allowing elements to be written inside JavaScript like so: `<Text>Hello, I am your cat!</Text>`. The React docs provide a comprehensive guide on JSX. Since JSX is JavaScript, variables can be embedded within it using curly braces `{}`.

Any JavaScript expression works between curly braces, including function calls like `{getFullName("Rum", "Tum", "Tugger")}`:

- TypeScript
- JavaScript

Curly braces act as portals into JS functionality in your JSX!

> Ensure `import React from 'react'` is at the top of your file for JSX to work.

### Custom Components

React Native’s Core Components can be nested within each other to create new components. These nestable, reusable components are central to React's approach.

For instance, you can nest `Text` and `TextInput` inside a `View`, and React Native will render them together:

##### Developer Notes

- Android
- Web

> If familiar with web development, `<View>` and `<Text>` might resemble HTML tags like `<div>` and `<p>`. On Android, views are typically placed within layouts such as `LinearLayout`, `FrameLayout`, or `RelativeLayout` to define children arrangement. React Native uses Flexbox for layout in `View`.

Render the component multiple times using `<Cat>` without repeating code:

Any component rendering other components is a **parent component**. Here, `Cafe` is the parent, and each `Cat` is a **child component**.

You can customize each `<Cat>` with different props like `name`:

- TypeScript
- JavaScript

Most React Native Core Components are customizable via props. For example, `Image` uses a `source` prop to define its displayed image.

Props such as `style`, which accepts a JS object of design properties, allow customization:

> Notice the double curly braces `{{ }}` around `style`'s width and height in JSX. Curly braces `{}` reference JavaScript values in JSX, useful for passing non-string props like arrays or numbers: `<Cat food={["fish", "kibble"]} age={2} />`. JS objects also use curly braces: `{width: 200, height: 200}`, so pass a JS object in JSX with another pair of curly braces: `{{width: 200, height: 200}}`.

Props and Core Components like `Text`, `Image`, and `View` enable many customizations. For interactivity, state is necessary.

### State

While props configure component rendering, **state** serves as a component’s personal data storage, useful for handling dynamic or user-interactive data. State provides components with memory!

> Generally, use props to configure a component during render and state to track data expected to change over time.

Consider a cat cafe scenario where two hungry cats await feeding. Their hunger status, stored as state, changes over time (unlike their names). Feeding the cats involves pressing buttons that update their state.

Add state using React’s `useState` Hook, which allows adding state to function components:

- TypeScript
- JavaScript

Import `useState` from React:

```typescript
import React, { useState } from "react"
```

Declare the component’s state by calling `useState` inside its function. Here, `useState` creates an `isHungry` state variable:

```typescript
const Cat = (props: CatProps) => {
  const [isHungry, setIsHungry] = useState(true)
  // ...
}
```

> `useState` can track various data types: strings, numbers, Booleans, arrays, objects. For instance, track how many times a cat has been petted with `const [timesPetted, setTimesPetted] = useState(0)`!

Calling `useState` does two things:

- Creates a “state variable” with an initial value (e.g., `isHungry` initialized to `true`)
- Provides a function to update that state variable (`setIsHungry`)

The pattern is `[<getter>, <setter>] = useState(<initialValue>)`.

Add the `Button` Core Component with an `onPress` prop:

```typescript
<Button
  onPress={() => {
    setIsHungry(false);
  }}
  //..
/>
```

When pressed, `onPress` triggers `setIsHungry(false)`, updating `isHungry` to `false`. This change affects the `Button`’s `disabled` and `title` props:

```typescript
<Button
  //..
  disabled={!isHungry}
  title={isHungry ? 'Give me some food, please!' : 'Thank you!'}
/>
```

> Although `isHungry` is a const, it appears reassignable. When a state-setting function like `setIsHungry` is called, the component re-renders, and `useState` provides the updated value of `isHungry`.

Finally, place your cats inside a `Cafe` component:

```typescript
const Cafe = () => {
  return (
    <>
      <Cat name="Munkustrap" />
      <Cat name="Spot" />
    </>
  );
};
```

> The `<>` and `</>` are JSX fragments. Adjacent JSX elements must be wrapped in an enclosing tag, which fragments allow without adding unnecessary wrapping elements like `View`.

***

Having covered React and React Native’s Core Components, let's explore handling `<TextInput>` further.

## Core Components and APIs

React Native offers a variety of built-in core components that can be utilized directly within your application. These components are accessible via the navigation sidebar or the top menu for narrower screens.

### Categories to Explore

- **Basic Components**
- **User Interface**
- **List Views**
- **Android-specific**
- **iOS-specific**
- **Others**

Beyond these built-in options, React Native supports a vast community of developers who contribute additional libraries. For specific functionalities not covered by the core components, refer to guides on finding external libraries.

### Basic Components

These foundational elements are commonly used across most applications.

### User Interface

This category includes universal user interface controls that render consistently across different platforms.

### List Views

For optimal performance with long lists of data, consider using list view components. Unlike `ScrollView`, these components only render items currently visible on the screen.

### Android Components and APIs

These components often serve as wrappers for standard Android classes.

### iOS Components and APIs

Similarly, many components in this category wrap commonly used UIKit classes from iOS.

### Others

This section includes additional components that might be beneficial for specific applications. For a comprehensive list of all available components and APIs, refer to the navigation sidebar or top menu on narrow screens.

## Gesture Responder System

The gesture responder system orchestrates the lifecycle of gestures within your application. A touch can traverse multiple phases as the app discerns the user's intent—whether it involves scrolling, sliding on a widget, or tapping—and this determination may evolve during the touch duration. Additionally, there can be concurrent touches.

This system is essential for enabling components to negotiate touch interactions without requiring knowledge of their parent or child components.

### Best Practices

To enhance your app's usability and user experience, ensure every action possesses these attributes:

- **Feedback/Highlighting**: Clearly indicate what element is responding to the user's touch and what will occur upon gesture release.
- **Cancelability**: Allow users to abort an ongoing action mid-touch by dragging their finger away.

These features foster a comfortable interaction environment, encouraging experimentation without fear of errors.

### TouchableHighlight and Touchable\*

The responder system can be intricate. To simplify its use, we provide an abstract `Touchable` implementation for elements intended to be "tappable." This leverages the responder system, enabling you to configure tap interactions declaratively. Use `TouchableHighlight` in scenarios where buttons or links are typically employed on web platforms.

### Responder Lifecycle

A view can become a touch responder by implementing appropriate negotiation methods. There are two primary methods for querying if a view wishes to assume this role:

- `View.props.onStartShouldSetResponder: evt => true`: Should the view become the responder at the start of a touch?
- `View.props.onMoveShouldSetResponder: evt => true`: For every touch move on the View when it is not yet the responder, does it wish to claim touch responsiveness?

If the view returns true and attempts to become the responder, one of these events will occur:

- `View.props.onResponderGrant: evt => {}`: The view now handles touch events. This is an opportunity to provide feedback and highlight interactions.
- `View.props.onResponderReject: evt => {}`: Another entity currently holds the responder status and will not relinquish it.

If a view is responding, these handlers may be invoked:

- `View.props.onResponderMove: evt => {}`: The user moves their finger.
- `View.props.onResponderRelease: evt => {}`: This event marks the end of the touch (i.e., "touchUp").
- `View.props.onResponderTerminationRequest: evt => true`: Another entity seeks to become the responder. Should this view release it? Returning true permits release.
- `View.props.onResponderTerminate: evt => {}`: The responder status has been transferred from the View, possibly due to other views or system actions (e.g., control center/notification center on iOS).

The event (`evt`) is a synthetic touch event with attributes such as:

- `nativeEvent`
  - `changedTouches`: Array of all touch events that have changed since the last event.
  - `identifier`: The ID of the touch.
  - `locationX`: X position relative to the element.
  - `locationY`: Y position relative to the element.
  - `pageX`: X position relative to the root element.
  - `pageY`: Y position relative to the root element.
  - `target`: Node ID of the element receiving the touch event.
  - `timestamp`: Time identifier for the touch, useful for velocity calculations.
  - `touches`: Array of all current touches on the screen.

#### Capture ShouldSet Handlers

`onStartShouldSetResponder` and `onMoveShouldSetResponder` are invoked in a bubbling pattern, starting from the deepest node. This ensures that the deepest component becomes the responder when multiple Views return true for these handlers, which is generally desirable as it maintains control and button usability.

However, if a parent view needs to ensure it becomes the responder, this can be managed using the capture phase. Before the responder system bubbles up from the deepest component, it executes a capture phase, invoking `on*ShouldSetResponderCapture`. Thus, if a parent View intends to prevent a child from becoming the responder at touch start, it should implement an `onStartShouldSetResponderCapture` handler that returns true.

- `View.props.onStartShouldSetResponderCapture: evt => true`
- `View.props.onMoveShouldSetResponderCapture: evt => true`

#### PanResponder

For more advanced gesture interpretation, consider using PanResponder.

## Security

Security is often overlooked during app development. While completely impenetrable software remains elusive—similar to how bank vaults can still be breached—the likelihood of a security breach decreases with increased protective measures. Although ordinary locks are vulnerable, they offer more protection than basic alternatives like cabinet hooks.

This guide covers best practices for securing sensitive information, authentication, network security, and tools to enhance app security. It serves as an extensive resource rather than a checklist, offering various options to bolster your app's defenses.

### Storing Sensitive Information

Avoid embedding sensitive API keys directly in your application code, as they can be exposed by inspecting the app bundle. Tools like `react-native-dotenv` and `react-native-config` are useful for managing environment-specific variables such as API endpoints but should not replace server-side environment variables that often contain secrets.

For accessing resources requiring an API key or secret, consider implementing an orchestration layer between your app and the resource. This could involve using serverless functions (e.g., AWS Lambda or Google Cloud Functions) to forward requests with necessary credentials. Unlike client-side code, server-side secrets are not directly accessible by consumers.

**Choose appropriate storage for persisted user data based on its sensitivity.** As apps evolve, saving data locally may be necessary for offline functionality, reducing network requests, or maintaining session tokens without repeated authentication.

> **Persisted vs Unpersisted Data:** Persisted data is stored on the device's disk and remains accessible across app launches, but this increases vulnerability to unauthorized access. Unpersisted data never reaches the disk, eliminating such risks.

#### Async Storage

Async Storage is a community-maintained module for React Native that provides an asynchronous, unencrypted key-value store. Each app operates in its own sandbox environment, preventing cross-app data access.

|**Use Async Storage When**|**Avoid Using Async Storage For**|
|-|-|
|Persisting non-sensitive data across app runs|Token storage|
|Persisting Redux state|Secrets|
|Persisting GraphQL state||
|Storing global app-wide variables||

##### Developer Notes

- Web: Async Storage is akin to Local Storage in web development.

#### Secure Storage

React Native lacks built-in secure data storage, but existing solutions are available for Android and iOS:

- **iOS - Keychain Services:** Ideal for securely storing small amounts of sensitive information like certificates, tokens, and passwords.

- **Android - Secure Shared Preferences:** While not encrypted by default, Encrypted Shared Preferences provide automatic encryption for keys and values.

- **Android - Keystore:** This system stores cryptographic keys in a secure container to prevent extraction from the device.

To utilize iOS Keychain Services or Android Secure Shared Preferences, you can either develop a custom bridge or use libraries that offer unified APIs. Consider using:

- `expo-secure-store`
- `react-native-keychain`

> **Caution:** Avoid unintentionally storing or exposing sensitive information, such as saving sensitive form data in Redux state and persisting it with Async Storage, or sending user tokens to monitoring services like Sentry or Crashlytics.

### Authentication and Deep Linking

Mobile apps face a unique vulnerability through deep linking—a method of directing data directly to an app from external sources. A typical deep link format is `app://`, where `app` represents your app scheme. For instance, in an e-commerce app, `app://products/1` could open the product detail page for item 1.

Deep links resemble URLs but lack security measures, as there's no centralized registration system for URL schemes. Malicious apps can hijack deep links by registering the same scheme and accessing the data within them. Avoid sending sensitive information through deep links to mitigate this risk.

On Android, users are prompted with a Disambiguation dialog when multiple apps can handle a link. iOS previously made automatic choices but now uses universal links for secure content access starting from iOS 11.

#### OAuth2 and Redirects

OAuth2 is a widely-used authentication protocol known for its security features. It involves third-party authentication, where the user grants permission to an application via a verification code that can be exchanged for a JWT (JSON Web Token).

While redirects are secure on the web due to unique URLs, mobile apps lack this guarantee. To enhance security, PKCE (Proof of Key Code Exchange) is used. PKCE involves generating a `code_verifier` and its SHA 256 hash (`code_challenge`). The client sends both during authentication, ensuring that only the initiating app can exchange the verification code for a JWT.

Consider using `react-native-app-auth`, which supports OAuth2 providers and PKCE if supported by your Identity Provider.

### Network Security

Always use SSL encryption for APIs to protect data in transit. Secure endpoints begin with `https://` instead of `http://`.

#### SSL Pinning

SSL pinning enhances security by embedding trusted certificates within the client app, ensuring that only requests signed with these certificates are accepted. This prevents man-in-the-middle attacks where attackers install malicious root CA certificates on a user's device.

> Be aware of certificate expiry when using SSL pinning. Certificates typically expire every 1-2 years and must be updated in both the app and server to maintain functionality.

### Summary

While no security measure is foolproof, proactive efforts can significantly reduce breach risks. Security investments should align with data sensitivity, user base size, and potential damage from unauthorized access. Prioritize protecting information that isn't requested unnecessarily.

## Handling Text Input

`TextInput` is a Core Component designed to facilitate text entry by users. It includes two key properties: `onChangeText`, which triggers a function every time the text changes, and `onSubmitEditing`, which activates a function when the text is submitted.

Consider an example where user input is translated into another language. In this hypothetical scenario, each word translates to 🍕. Thus, "Hello there Bob" becomes "🍕 🍕 🍕". Here, we manage `text` within the component's state due to its dynamic nature.

Text inputs offer various functionalities beyond basic text entry. For instance, you can validate input in real-time as users type. To explore more comprehensive examples, refer to React documentation on controlled components or the reference materials for `TextInput`.

Text input represents one method of user interaction with an application. Next, we will examine another form of input and learn how to manage touch interactions.

## Using a ScrollView

A `ScrollView` is a versatile scrolling container capable of holding multiple components and views. It supports both vertical and horizontal scrolling by setting the `horizontal` property.

This example demonstrates creating a vertical `ScrollView` that mixes images and text.

To enable paging through views using swipe gestures, use the `pagingEnabled` prop. On Android, swiping horizontally between views can be implemented with the ViewPager component.

On iOS, a `ScrollView` containing a single item allows users to zoom content by setting the `maximumZoomScale` and `minimumZoomScale` props, enabling pinch-to-zoom functionality.

A `ScrollView` is ideal for displaying a small number of limited-size items. All elements within a `ScrollView` are rendered, even if not visible on screen. For long lists that exceed screen size, consider using a `FlatList`. Next, we'll explore list views.

```typescript
import React from 'react';
import { ScrollView, Image, Text, View } from 'react-native';

const MyScrollView = () => {
  return (
    <ScrollView pagingEnabled={true}>
      <View>
        <Image source={{ uri: 'https://example.com/image1.jpg' }} />
        <Text>Some text here</Text>
      </View>
      <View>
        <Image source={{ uri: 'https://example.com/image2.jpg' }} />
        <Text>More text here</Text>
      </View>
    </ScrollView>
  );
};

export default MyScrollView;
```

## Using List Views

React Native offers several components designed for presenting lists of data efficiently. The primary choices are `FlatList` and `SectionList`.

### FlatList Component

The `FlatList` component is ideal for displaying a scrolling list of items that share a similar structure but may change over time. It's particularly effective for long lists where the number of items can vary, as it only renders elements currently visible on the screen, unlike the more generic `ScrollView`, which renders all elements at once.

#### Key Props

- **data**: This prop provides the source information for the list.
- **renderItem**: This function takes an item from the data source and returns a formatted component to render.

#### Example Usage

Below is an example of how to create a basic `FlatList` using hardcoded data. Each item in the `data` prop is rendered as a `Text` component within the `FlatListBasics` component:

```typescript
import React from 'react';
import { FlatList, Text, View } from 'react-native';

const DATA = [
  { id: '1', title: 'First Item' },
  { id: '2', title: 'Second Item' },
  // Add more items as needed
];

const renderItem = ({ item }) => (
  <View>
    <Text>{item.title}</Text>
  </View>
);

const FlatListBasics = () => (
  <FlatList
    data={DATA}
    renderItem={renderItem}
  />
);
```

### SectionList Component

For displaying data divided into logical sections, possibly with section headers (similar to `UITableView` on iOS), the `SectionList` component is more appropriate.

#### Common Use Case

A frequent use case for list views in React Native involves rendering data fetched from a server. To achieve this, you'll need to understand networking within React Native.

By leveraging these components, developers can efficiently manage and display lists of data in their applications.

## Platform-Specific Code

When developing a cross-platform application, maximizing code reuse is ideal. However, there are instances where platform-specific implementations are necessary, such as creating distinct visual components for Android and iOS.

React Native offers two methods to organize and separate your code by platform:

- Using the `Platform` module.
- Utilizing platform-specific file extensions.

Certain component properties may be exclusive to a specific platform. These props are annotated with `@platform` and displayed with a badge on the website.

### Platform Module

The `Platform` module in React Native detects the current operating system, allowing you to implement platform-specific code. This approach is suitable when only minor parts of a component require differentiation.

```typescript
import { Platform, StyleSheet } from "react-native"

const styles = StyleSheet.create({
  height: Platform.OS === "ios" ? 200 : 100,
})
```

`Platform.OS` returns `ios` for iOS and `android` for Android.

The `Platform.select` method can be used to choose values based on the platform. It accepts an object with keys like `'ios' | 'android' | 'native' | 'default'`, returning the most appropriate value for the current platform. If running on a phone, it prioritizes `ios` and `android`. If neither is specified, it uses the `native` key, followed by the `default` key.

```typescript
import { Platform, StyleSheet } from "react-native"

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      ios: {
        backgroundColor: "red",
      },
      android: {
        backgroundColor: "green",
      },
      default: {
        // other platforms, such as web
        backgroundColor: "blue",
      },
    }),
  },
})
```

This results in a container with `flex: 1` on all platforms, a red background on iOS, green on Android, and blue on others.

Since it accepts any value, you can also use `Platform.select` to return platform-specific components:

```typescript
const Component = Platform.select({
  ios: () => require('ComponentIOS'),
  android: () => require('ComponentAndroid'),
})();

<Component />;
```

```typescript
const Component = Platform.select({
  native: () => require('ComponentForNative'),
  default: () => require('ComponentForWeb'),
})();

<Component />;
```

#### Detecting the Android Version

On Android, `Platform` can detect the API version:

```typescript
import { Platform } from "react-native"

if (Platform.Version === 25) {
  console.log("Running on Nougat!")
}
```

**Note**: `Version` refers to the Android API level, not the OS version. Refer to the Android Version History for details.

#### Detecting the iOS Version

On iOS, `Version` is derived from `-[UIDevice systemVersion]`, a string like "10.3". To detect the major iOS version:

```typescript
import { Platform } from "react-native"

const majorVersionIOS = parseInt(Platform.Version, 10)
if (majorVersionIOS <= 9) {
  console.log("Work around a change in behavior")
}
```

### Platform-Specific Extensions

For more complex platform-specific code, consider splitting it into separate files. React Native detects `.ios.` or `.android.` extensions and loads the appropriate file based on the running platform.

Example:

```shell
BigButton.ios.js
BigButton.android.js
```

Import as follows:

```typescript
import BigButton from "./BigButton"
```

React Native automatically selects the correct file for the current platform.

### Native-Specific Extensions

Use `.native.js` extensions when a module is shared between NodeJS/Web and React Native without Android/iOS differences. This is useful for projects sharing code among React Native and ReactJS.

Example:

```shell
Container.js # picked up by Web bundlers like webpack or Rollup
Container.native.js # picked up by the React Native bundler (Metro) for both Android and iOS
```

Import without `.native` extension:

```typescript
import Container from "./Container"
```

**Pro tip:** Configure your Web bundler to ignore `.native.js` extensions to avoid including unused code in production, reducing bundle size.

## Accessibility

#### Overview of Accessibility Features in React Native

React Native provides several accessibility features that help developers create applications usable by everyone, including people with disabilities. These features are crucial for ensuring inclusivity and compliance with accessibility standards like WCAG (Web Content Accessibility Guidelines).

##### Key Accessibility Properties

1. **`accessibilityRole`**: Defines the role of a component, such as button, link, or image. This helps assistive technologies understand how to interact with the element.

1. **`accessibilityLabel`**: Provides a text label for screen readers, describing what the element does or represents.

1. **`accessibilityHint`**: Offers additional information about an element's action when focused by a screen reader.

1. **`accessible`**: Determines if an element is accessible to assistive technologies.

1. **`accessibilityState`**: Describes the state of an element, such as selected or checked.

1. **`accessibilityActions`**: Defines actions that can be performed on an element, like activating a button or adjusting a slider.

1. **`onAccessibilityAction`**: Handles accessibility action requests, allowing custom behavior when an action is triggered.

1. **`role`**: Similar to `accessibilityRole`, it communicates the purpose of a component and takes precedence over `accessibilityRole`.

##### Accessibility Actions

Accessibility actions enable assistive technologies to programmatically invoke actions on components. To support these:

- Define supported actions using the `accessibilityActions` property.
- Implement an `onAccessibilityAction` function to handle action requests.

Standard actions include:

- `'activate'`: Activates a component.
- `'increment'` and `'decrement'`: Adjusts adjustable components.
- `'magicTap'` (iOS): Double-tap with two fingers while focused.
- `'escape'` (iOS): Performs a scrub gesture to exit focus.
- `'longpress'` (Android): Double-tap and hold.

##### Checking Screen Reader Status

The `AccessibilityInfo` API allows developers to check if a screen reader is active, enabling dynamic adjustments based on the user's needs.

##### Sending Accessibility Events (Android)

React Native's `UIManager` module can trigger accessibility events like focusing or clicking on a view. This is useful for custom views that need to announce their presence or state changes.

```javascript
import { Platform, UIManager, findNodeHandle } from "react-native"

if (Platform.OS === "android") {
  UIManager.sendAccessibilityEvent(
    findNodeHandle(this),
    UIManager.AccessibilityEventTypes.typeViewFocused
  )
}
```

##### Testing Accessibility

- **TalkBack (Android)**: Enable via Settings > Accessibility. Use the volume key shortcut or command line to toggle.

- **VoiceOver (iOS/iPadOS)**: Enable through Settings > General > Accessibility. Use the Home button triple-click or Accessibility Shortcut.

Testing on actual devices is recommended for accurate results, though tools like Xcode's Accessibility Inspector can simulate VoiceOver on macOS.

##### Additional Resources

For more detailed guidance, refer to resources like "Making React Native Apps Accessible," which provides comprehensive strategies and best practices for accessibility in React Native applications.

## Debugging Basics

> Note: Debugging features, such as the Dev Menu, LogBox, and React Native DevTools are disabled in release (production) builds.

### Opening the Dev Menu

React Native provides an in-app developer menu that offers access to debugging features. You can open this menu by shaking your device or using keyboard shortcuts:

- **iOS Simulator**: `Ctrl` + `Cmd ⌘` + `Z` (or Device > Shake)
- **Android Emulators**:
  - macOS: `Cmd ⌘` + `M`
  - Windows/Linux: `Ctrl` + `M`

Alternative for Android: Use the command `adb shell input keyevent 82`.

### Opening DevTools

React Native DevTools is an integrated debugger for React Native, allowing you to inspect and understand your JavaScript code execution. To open DevTools:

- Select "Open DevTools" in the Dev Menu.
- Press `j` from the CLI (`npx react-native start`).

Upon first launch, DevTools will display a welcome panel with an open console drawer for viewing logs and interacting with the JavaScript runtime. You can navigate to other panels like the React Components Inspector and Profiler from the top of the window.

React Native DevTools is built on a dedicated debugging architecture within React Native, using a customized version of the Chrome DevTools frontend. This integration provides familiar, browser-aligned debugging features designed for reliability.

> Note: React Native DevTools requires the Hermes engine and either Google Chrome or Microsoft Edge installed.

#### Flipper and Alternative Debugging Tools

React Native DevTools replaces older tools like Flipper, Experimental Debugger, and the Hermes debugger (Chrome). For older versions of React Native, refer to version-specific documentation.

For apps using JavaScriptCore instead of Hermes, Direct JSC Debugging is available (see Other Debugging Methods).

React Native DevTools focuses on debugging React app concerns and does not replace native tools. To inspect underlying platform layers, use Xcode or Android Studio's debugging tools.

Other useful links:

- [Why you don’t need Flipper in your React Native app … and how to get by without it](#)

### LogBox

LogBox is an in-app tool that displays warnings or errors logged by your app.

#### Fatal Errors

When a fatal error, such as a JavaScript syntax error, occurs, LogBox opens at the error's location. In this state, LogBox cannot be dismissed because code execution is halted. It will automatically dismiss once the syntax error is fixed via Fast Refresh or manual reload.

#### Console Errors and Warnings

Console errors and warnings appear as on-screen notifications with red or yellow badges:

- **Errors**: Display a notification count. Tap to view expanded details and paginate through logs.
- **Warnings**: Show a notification banner without details, prompting you to open React Native DevTools.

When React Native DevTools is active, all non-fatal errors are hidden from LogBox. It's recommended to use the Console panel within React Native DevTools as it provides comprehensive log information.

### Performance Monitor

On Android and iOS, an in-app performance overlay can be toggled during development by selecting **"Perf Monitor"** in the Dev Menu. Learn more about this feature [here](#).

> Info: The Performance Monitor is a guide for in-app use. For accurate performance measurements, investigate native tooling under Android Studio and Xcode.

## React Native DevTools

React Native DevTools offers a modern debugging experience specifically designed for React Native applications. Built from scratch, it aims to provide deeper integration and reliability compared to previous methods.

While React Native DevTools focuses on debugging React app concerns, it does not replace native tools. For inspecting the underlying platform layers of React Native (e.g., when developing a Native Module), use the debugging tools available in Android Studio and Xcode (see Debugging Native Code).

### Core Features

React Native DevTools is based on the Chrome DevTools frontend, making its features familiar to those with web development experience. For comprehensive guides and video resources, refer to the Chrome DevTools documentation.

#### Console

The Console panel allows you to view and filter messages, evaluate JavaScript, inspect object properties, among other functionalities.

Console features reference | [Chrome DevTools](https://developer.chrome.com/docs/devtools/console/)

##### Useful Tips

- Use the filter box or adjust log levels if your app generates many logs.
- Monitor values over time with Live Expressions.
- Preserve messages across reloads using Preserve Logs.
- Clear the console view with `Ctrl` + `L`.

#### Sources & Breakpoints

The Sources panel lets you view source files and set breakpoints. Breakpoints pause your app at specific lines of code, enabling inspection of the live state and step-by-step execution.

Pause your code with breakpoints | [Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript/breakpoints/)

##### Mini-Guide

Breakpoints are essential for debugging:

1. Navigate to a source file using the sidebar or `Cmd ⌘`+`P` / `Ctrl`+`P`.
1. Click in the line number column next to code to add a breakpoint.
1. Use navigation controls at the top right to step through code when paused.

##### Useful Tips

- A "Paused in Debugger" overlay appears when your app is paused; tap it to resume.
- Inspect the current scope and call stack, and set watch expressions using the panels on the right-hand side when paused.
- Insert a `debugger;` statement in your text editor to quickly set a breakpoint via Fast Refresh.
- Explore different types of breakpoints, such as Conditional Breakpoints and Logpoints.

#### Memory

The Memory panel allows you to take heap snapshots and monitor JavaScript memory usage over time.

Record heap snapshots | [Chrome DevTools](https://developer.chrome.com/docs/devtools/memory-problems/)

##### Useful Tips

- Use `Cmd ⌘`+`F` / `Ctrl`+`F` to filter for specific objects in the heap.
- Allocation timeline reports can help identify memory leaks by showing usage over time as a graph.

### React DevTools Features

The integrated Components and Profiler panels include all features of the React DevTools browser extension, working seamlessly within React Native DevTools.

#### React Components

The React Components panel lets you inspect and update the rendered React component tree.

- Highlight elements on device by hovering or selecting them in DevTools.
- Locate an element in DevTools using the "Select element" button, then tap any app element.

##### Useful Tips

- View and modify props and state at runtime using the right-hand panel.
- Components optimized with React Compiler are marked with a "Memo ✨" badge.

##### Protip: Highlight Re-renders

Highlighting component re-renders can help identify performance issues. Enable this feature by clicking the View Settings (`⚙︎`) icon and checking "Highlight updates when components render".

#### React Profiler

The React Profiler panel records performance profiles to analyze component render timings and React commits.

For more information, refer to the original 2018 guide (note that some parts may be outdated).

### Reconnecting DevTools

DevTools might disconnect from the target device due to:

- App closure.
- App rebuild (new native build installation).
- Native app crash.
- Metro dev server shutdown.
- Physical device disconnection.

Upon disconnection, a dialog with "Debugging connection was closed" will appear. You can either dismiss it or select "Reconnect DevTools" after addressing the disconnection cause.

## Debugging Native Code

### Projects with Native Code Only

This section is relevant for projects that expose native code. If you are using the managed Expo workflow, refer to the prebuild guide for API usage.

#### Accessing Logs

To view native logs for iOS or Android apps while they are running, use these terminal commands:

- **Android:**

  ```shell
  npx react-native log-android
  ```

- **iOS:**
  ```shell
  npx react-native log-ios
  ```

Alternatively, you can access these logs through the following methods:

- For iOS Simulator: Navigate to `Debug > Open System Log…`.
- For Android devices or emulators: Run the command in a terminal:
  ```shell
  adb logcat "*:S" ReactNative:V ReactNativeJS:V
  ```

#### Debugging in a Native IDE

When working with native code, such as writing native modules, you can launch the app from Android Studio or Xcode to utilize native debugging features like setting breakpoints.

You can also run your application using the React Native CLI and attach the native debugger of the IDE (Android Studio or Xcode) to the process.

##### Android Studio

To attach a debugger in Android Studio:

1. Go to the "Run" option on the menu bar.
1. Click on "Attach to Process..."
1. Select the running React Native app from the list.

##### Xcode

To attach a debugger in Xcode:

1. Click on "Debug" in the top menu bar.
1. Select the "Attach to process" option.
1. Choose your application from the list of "Likely Targets".

## Debugging Release Builds

### Symbolicating a Stack Trace

When a React Native app encounters an unhandled exception in a release build, the output can be obfuscated and difficult to interpret. For example:

```
07-15 10:58:25.820 18979 18998 E AndroidRuntime: FATAL EXCEPTION: mqt_native_modules
07-15 10:58:25.820 18979 18998 E AndroidRuntime: Process: com.awesomeproject, PID: 18979
07-15 10:58:25.820 18979 18998 E AndroidRuntime: com.facebook.react.common.JavascriptException: Failed, js engine: hermes, stack:
07-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:132161
07-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:132084
07-15 10:58:25.820 18979 18998 E AndroidRuntime: f@1:131854
07-15 10:58:25.820 18979 18998 E AndroidRuntime: anonymous@1:131119
```

In this stack trace, entries like `p@1:132161` are minified function names and bytecode offsets. To debug these calls effectively, we need to translate them into file, line, and function name format (e.g., `AwesomeProject/App.js:54:initializeMap`). This process is known as **symbolication**.

To symbolicate minified function names and bytecode, use the stack trace along with a generated source map in `metro-symbolicate`.

#### Enabling Source Maps

Source maps are essential for symbolication. Ensure that they are enabled within the build configuration for your target platform:

- **Android**: Source maps are enabled by default.

  To ensure source map generation, include the following `hermesFlags` in `android/app/build.gradle`:

  ```groovy
  react {
      hermesFlags = ["-O", "-output-source-map"]
  }
  ```

  If configured correctly, you should see the source map output location during Metro build output:

  ```
  Writing bundle output to:, android/app/build/generated/assets/react/release/index.android.bundle
  Writing sourcemap output to:, android/app/build/intermediates/sourcemaps/react/release/index.android.bundle.packager.map
  ```

- **iOS**: Source maps are disabled by default. Follow these steps to enable them:

  To generate source maps, open Xcode and edit the build phase "Bundle React Native code and images". Add a `SOURCEMAP_FILE` entry with the desired output path above other exports:

  ```diff
  + SOURCEMAP_FILE="$(pwd)/../main.jsbundle.map";
    WITH_ENVIRONMENT="../node_modules/react-native/scripts/xcode/with-environment.sh"
  ```

  If configured correctly, you should see the source map output location during Metro build output:

  ```
  Writing bundle output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle
  Writing sourcemap output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle.map
  ```

#### Using `metro-symbolicate`

With source maps generated, you can now translate stack traces using `metro-symbolicate`:

```shell
# Print usage instructions
npx metro-symbolicate

# From a file containing the stack trace
npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map < stacktrace.txt

# From adb logcat (Android)
adb logcat -d | npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map
```

#### Notes on Source Maps

- Multiple source maps may be generated during the build process. Ensure you use the one shown in the examples.
- The source map must correspond to the exact commit of the crashing app, as small changes in source code can lead to significant differences in offsets.
- If `metro-symbolicate` exits immediately with success, ensure that input is from a pipe or redirection rather than directly from a terminal.

## Other Debugging Methods

This section discusses legacy methods for JavaScript debugging in React Native or Expo apps. For new projects, it's recommended to use React Native DevTools.

### Safari Developer Tools (Direct JSC Debugging)

Safari can be used to debug the iOS version of your app when using JavaScriptCore (JSC) as the runtime environment.

1. **Physical Devices Only**: Open the Settings app on your device and navigate to `Safari > Advanced`. Ensure that "Web Inspector" is enabled.
1. On a Mac, open Safari and enable the Develop menu by going to `Safari > Preferences...`, selecting the `Advanced` tab, and checking "Show develop menu in menu bar".
1. Under the Develop menu, select your device and choose the "JSContext" option from the submenu. This action opens Safari's Web Inspector, which includes Console and Sources panels similar to Chrome DevTools.

> **Tip**: Source maps might not be enabled by default. You can follow a guide or video to enable them and set breakpoints in the source code.

> **Tip**: Each app reload creates a new JSContext. Enabling "Automatically Show Web Inspectors for JSContexts" eliminates the need to manually select the latest JSContext.

### Remote JavaScript Debugging (Removed)

*Note: This feature has been removed.*

***

**Previous:** Debugging Release Builds\
**Next:** Testing

- Safari Developer Tools (Direct JSC Debugging)
- Remote JavaScript Debugging (Removed)

## Testing

As your codebase grows, small errors can lead to significant failures. Bugs negatively impact user experience and business outcomes. To prevent fragile programming, testing is essential before releasing software.

### Why Test?

Humans make mistakes, and testing helps uncover these errors, ensuring that your code functions as intended. Testing also verifies future functionality when new features are added or existing ones refactored. Writing a failing test to expose bugs can be an effective way to fix them. Tests serve as documentation for team members unfamiliar with the codebase, reducing time spent on manual QA.

### Static Analysis

Static analysis tools check your code for errors without executing it. These include:

- **Linters**: Analyze code to catch common errors and enforce style guides.
- **Type checking**: Ensures that function arguments match expected types.

React Native includes ESLint for linting and TypeScript for type checking by default.

### Writing Testable Code

Testable code is akin to testing individual aircraft parts before assembly. Write modular, small code units rather than a single large file. Separate business logic from UI components to facilitate independent testing of each part.

### Writing Tests

React Native uses Jest as the default testing framework. It includes presets tailored for this environment, allowing you to write various tests without extensive configuration.

#### Structuring Tests

Tests should be concise and focused on specific functionalities. Use descriptive test names and assertions to verify expected outcomes. For example:

```javascript
test("given empty GroceryShoppingList, user can add an item to it", () => {
  const { getByPlaceholderText, getByText, getAllByText } = render(
    <GroceryShoppingList />
  )

  fireEvent.changeText(getByPlaceholderText("Enter grocery item"), "banana")
  fireEvent.press(getByText("Add the item to list"))

  const bananaElements = getAllByText("banana")
  expect(bananaElements).toHaveLength(1) // Expect 'banana' to be on the list
})
```

#### Testing User Interactions

Focus on user interactions rather than internal component states. Use libraries like React Native Testing Library to simulate user actions and verify outcomes.

#### Testing Rendered Output

Snapshot testing captures a textual representation of your component's render output. It helps detect unexpected changes but requires careful management to avoid false positives or negatives.

### End-to-End Tests

E2E tests validate app functionality from the user perspective on actual devices or simulators/emulators. They provide high confidence in app performance but are more time-consuming and prone to flakiness compared to other test types.

Focus E2E testing on critical app areas like authentication, core functionalities, and payments. Use faster JS tests for less critical parts.

### Summary

Testing is crucial for maintaining code quality and ensuring reliable software delivery. Various testing methods offer different benefits and trade-offs. Start incorporating tests into your React Native projects to enhance confidence in your app's performance.

#### Links

- [React Testing Overview](#)
- [React Native Testing Library](#)
- [Jest Docs](#)
- [Detox](#)
- [Appium](#)
- [Maestro](#)

*This guide was authored by Vojtech Novak.*

## Performance Overview

React Native offers a compelling advantage over WebView-based tools by aiming for smooth performance, specifically targeting 60 frames per second (FPS) with a native look and feel. While React Native handles many optimizations automatically, there are areas where manual intervention is necessary to achieve optimal performance. This guide provides insights into troubleshooting performance issues and addressing common problems.

### Understanding Frames

The concept of "frames" originates from the early days of cinema when movies were referred to as "moving pictures." Realistic motion in video or UI is achieved by rapidly displaying static images at a consistent rate. Each image is called a frame, and the number of frames displayed per second affects how smooth the motion appears.

iOS devices aim for 60 FPS, allowing approximately 16.67 milliseconds (ms) to generate each frame. If this time limit is exceeded, a "frame drop" occurs, making the UI seem unresponsive. To observe frame rates in your app, open the Dev Menu and toggle `Show Perf Monitor`. You'll notice two different frame rates:

#### JS Frame Rate (JavaScript Thread)

In most React Native applications, business logic runs on the JavaScript thread, which handles tasks like API calls and touch events. Updates to native views are batched and sent to the native side at each event loop iteration before the frame deadline. If the JavaScript thread is unresponsive for a frame, it's considered dropped. For instance, calling `this.setState` in a complex component might take 200ms, resulting in 12 frames being dropped and causing animations to freeze.

Common issues include:

- **Navigator Transitions**: Rendering components for new scenes can cause jank as transitions are controlled by the JavaScript thread.
- **Touch Responsiveness**: Delays in processing touch events due to a busy JavaScript thread can affect components like `TouchableOpacity`.

#### UI Frame Rate (Main Thread)

Performance differences between `NavigatorIOS` and `Navigator` arise because `NavigatorIOS` handles animations on the main thread, avoiding interruptions from JavaScript frame drops. Similarly, scrolling through a `ScrollView` remains smooth even if the JavaScript thread is busy.

### Common Performance Issues

#### Development Mode (`dev=true`)

JavaScript performance degrades in development mode due to additional runtime work for warnings and error messages. Always test performance in release builds.

#### Using `console.log`

In bundled apps, `console.log` statements can bottleneck the JavaScript thread. Remove them before bundling using a Babel plugin:

```json
{
  "env": {
    "production": {
      "plugins": ["transform-remove-console"]
    }
  }
}
```

Install with `npm i babel-plugin-transform-remove-console --save-dev`.

#### Slow ListView Rendering

Switch to `FlatList` or `SectionList` for better performance, especially with large lists. Implement `getItemLayout` to optimize rendering speed.

#### Re-rendering Unchanged Views

For `ListView`, use a `rowHasChanged` function to minimize unnecessary re-renders. For components, implement `shouldComponentUpdate` or use `PureComponent` with immutable data structures for efficient updates.

#### High JavaScript Thread Workload

Slow transitions often result from excessive work on the JavaScript thread. Use InteractionManager or LayoutAnimation to manage workload during animations. LayoutAnimation leverages Core Animation and is unaffected by frame drops.

#### UI Frame Drops During View Movement

Alpha compositing can cause FPS drops when moving views with transparent backgrounds. Enable `shouldRasterizeIOS` or `renderToHardwareTextureAndroid` for improvement, but monitor memory usage.

#### Image Size Animations

Animating image size on iOS involves re-cropping and scaling, which is costly. Use the `transform: [{scale}]` style property instead.

#### Unresponsive TouchableX Views

If actions in `onPress` cause frame drops, wrap them in `requestAnimationFrame`:

```typescript
handleOnPress() {
  requestAnimationFrame(() => {
    this.doExpensiveAction();
  });
}
```

#### Slow Navigator Transitions

Navigator animations are controlled by the JavaScript thread. Offloading animations to the native thread can improve performance. React Navigation addresses this by using native components and the `Animated` library for smooth, high-FPS animations.

This guide aims to help you identify and resolve common performance issues in React Native applications, ensuring a smoother user experience.

## Improving React Native Build Times

Building a React Native app can be resource-intensive, often taking several minutes of developer time. This becomes more challenging as projects grow or in larger organizations with multiple developers. To address these performance issues, consider the following advanced techniques to improve build times.

### Build Only One ABI During Development (Android-only)

By default, Android builds include all four Application Binary Interfaces (ABIs): `armeabi-v7a`, `arm64-v8a`, `x86`, and `x86_64`. However, during local development and testing on an emulator or physical device, building only the necessary ABI can reduce native build time by approximately 75%.

#### Using React Native CLI

To build a single ABI with the React Native CLI, use the `--active-arch-only` flag:

```bash
$ yarn react-native run-android --active-arch-only

[ ... ]
info Running jetifier to migrate libraries to AndroidX. You can disable it using "--no-jetifier" flag.
Jetifier found 1037 file(s) to forward-jetify. Using 32 workers...
info JS server already running.
info Detected architectures arm64-v8a
info Installing the app...
```

This approach uses the `reactNativeArchitectures` Gradle property.

#### Using Gradle Directly

For builds directly with Gradle, specify the desired ABI:

```bash
$ ./gradlew :app:assembleDebug -PreactNativeArchitectures=x86,x86_64
```

You can also override this value locally in `gradle.properties`:

```properties
# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64
```

For release builds, ensure all ABIs are included to support various devices.

### Enable Configuration Caching (Android-only)

Starting with React Native 0.79, Gradle Configuration Caching can be enabled to improve build times by skipping the configuration phase in subsequent builds:

Add this line to `android/gradle.properties`:

```properties
org.gradle.configuration-cache=true
```

Refer to the official Gradle documentation for more details on Configuration Caching.

### Use a Compiler Cache

Frequent native builds benefit from using a compiler cache, which can be either local or distributed.

#### Local Caches

Ccache is recommended for both Android and iOS. It wraps compilers, stores results, and skips recompilation if cached:

##### Installation

On macOS, install ccache with:

```bash
brew install ccache
```

Alternatively, follow the official installation instructions.

##### Usage

Perform two clean builds to observe speed improvements. Verify cache hits/misses with:

```bash
$ ccache -s
Summary:
  Hits:             196 /  3068 (6.39 %)
    Direct:           0 /  3068 (0.00 %)
    Preprocessed:   196 /  3068 (6.39 %)
  Misses:          2872
    Direct:        3068
    Preprocessed:  2872
  Uncacheable:        1
Primary storage:
  Hits:             196 /  6136 (3.19 %)
  Misses:          5940
  Cache size (GB): 0.60 / 20.00 (3.00 %)
```

Reset stats with `ccache --zero-stats` and clear cache with `ccache --clear`.

##### XCode Specific Setup

For iOS, enable ccache in `ios/Podfile`:

```ruby
post_install do |installer|
  react_native_post_install(
    installer,
    config[:reactNativePath],
    :mac_catalyst_enabled => false,
    # Uncomment the line below
    :ccache_enabled => true
  )
end
```

##### CI Considerations

On CI, consider a full clean build to avoid cache issues. Use `compiler_check content` for hashing file contents instead of relying on timestamps.

#### Distributed Caches

For larger organizations, distributed caches like sccache can be beneficial. Refer to the sccache quickstart guide for setup instructions.

## Optimizing Flatlist Configuration

### Key Concepts

- **VirtualizedList:** The underlying component for `FlatList` in React Native, implementing the virtual list concept.

- **Memory Consumption:** Refers to how much data about your list is stored in memory, potentially leading to app crashes.

- **Responsiveness:** Describes an application's ability to promptly respond to user interactions. Poor responsiveness can manifest as delays when interacting with components.

- **Blank Areas:** Occur when `VirtualizedList` cannot render items quickly enough, resulting in non-rendered components appearing as blank spaces.

- **Viewport:** The visible portion of content that is rendered on the screen.

- **Window:** The area where items are mounted, typically larger than the viewport.

### Properties for Performance Improvement

#### removeClippedSubviews

|Type|Default|
|-|-|
|Boolean|False|

**Description:** When set to `true`, views outside of the viewport are detached from the native view hierarchy.

- **Pros:** Reduces time on the main thread, minimizing dropped frames by excluding off-screen views from rendering and drawing.

- **Cons:** Potential bugs such as missing content (notably on iOS) if complex transforms or absolute positioning are used. Views remain in memory but are only detached.

#### maxToRenderPerBatch

|Type|Default|
|-|-|
|Number|10|

**Description:** Controls the number of items rendered per batch during scrolling.

- **Pros:** A higher value reduces visual blank areas by increasing the fill rate.

- **Cons:** More items per batch can lead to longer JavaScript execution times, potentially blocking other events and affecting responsiveness.

#### updateCellsBatchingPeriod

|Type|Default|
|-|-|
|Number|50|

**Description:** Sets the delay in milliseconds between batch renders for `VirtualizedList`.

- **Pros:** Allows control over rendering frequency and quantity of items per batch.

- **Cons:** Less frequent batches may cause blank areas, while more frequent batches can impact responsiveness.

#### initialNumToRender

|Type|Default|
|-|-|
|Number|10|

**Description:** Specifies the number of items to render initially.

- **Pros:** Precisely setting this value for different devices can significantly boost initial rendering performance.

- **Cons:** A low `initialNumToRender` may result in blank areas if it doesn't cover the viewport on initial load.

#### windowSize

|Type|Default|
|-|-|
|Number|21|

**Description:** Measured in units where 1 equals the viewport height. The default is 21 (10 viewports above, 10 below, and one in between).

- **Pros:** A larger `windowSize` reduces blank space during scrolling but increases memory usage.

- **Cons:** A smaller `windowSize` saves memory but may increase the likelihood of encountering blank areas.

### Tips for List Item Components

#### Use Basic Components

Complex components render more slowly. Minimize logic and nesting in list items, especially if they are reused frequently across your app.

#### Use Light Components

Heavier components take longer to render. Avoid large images by using cropped versions or thumbnails. Collaborate with the design team to minimize effects and interactions within list items.

#### Use `memo()`

`React.memo()` creates a memoized component that re-renders only when its props change, optimizing performance for FlatList components.

```typescript
import React, { memo } from 'react';
import { View, Text } from 'react-native';

const MyListItem = memo(
  ({ title }: { title: string }) => (
    <View>
      <Text>{title}</Text>
    </View>
  ),
  (prevProps, nextProps) => prevProps.title === nextProps.title
);

export default MyListItem;
```

#### Use Cached Optimized Images

Utilize community packages like `react-native-fast-image` for more efficient image handling. Faster loading images free up the JavaScript thread sooner.

#### Use getItemLayout

For list items with consistent height (or width in horizontal lists), use `getItemLayout` to avoid asynchronous layout calculations, enhancing performance.

#### Use keyExtractor or key

Set the `keyExtractor` prop on your `FlatList` for caching and React's `key` tracking. Alternatively, use a `key` prop within item components.

#### Avoid Anonymous Functions in renderItem

For functional components, define `renderItem` outside of JSX and wrap it with `useCallback`. For class components, place `renderItem` outside the render method to prevent recreation on each call.

```typescript
const renderItem = useCallback(({ item }) => (
  <View key={item.key}>
    <Text>{item.title}</Text>
  </View>
), []);

return (
  // ...
  <FlatList data={items} renderItem={renderItem} />
  // ...
);
```

## Alert

The `Alert` API is designed to work across both Android and iOS platforms, allowing for the display of static alerts. On iOS, it also supports prompts that request user input.

### Example Usage

#### iOS

On iOS, you can define any number of buttons within an alert. Each button may have a specific style or be emphasized using `AlertButtonStyle` enum and the `isPreferred` field on `AlertButton`.

#### Android

For Android, up to three buttons are allowed:

- A single button is treated as 'positive' (e.g., 'OK').
- Two buttons represent 'negative', 'positive' (e.g., 'Cancel', 'OK').
- Three buttons denote 'neutral', 'negative', 'positive' (e.g., 'Later', 'Cancel', 'OK').

Alerts on Android can be dismissed by tapping outside the alert box, which is disabled by default. This behavior can be enabled with `AlertOptions` using `{cancelable: true}`. The dismissal event can be managed via an `onDismiss` callback within the `options`.

### Reference

#### Methods

##### `alert()`

```typescript
static alert(
  title: string,
  message?: string,
  buttons?: AlertButton[],
  options?: AlertOptions
);
```

**Parameters:**

|Name|Type|Description|
|-|-|-|
|titleRequired|string|The dialog's title. Passing `null` or an empty string will hide the title.|
|message|string|An optional message displayed below the title.|
|buttons|AlertButton\[]|Optional array for button configurations.|
|options|AlertOptions|Optional configuration for the alert.|

##### `prompt()` (iOS Only)

```typescript
static prompt(
  title: string,
  message?: string,
  callbackOrButtons?: ((text: string) => void) | AlertButton[],
  type?: AlertType,
  defaultValue?: string,
  keyboardType?: string
);
```

Creates and displays a text input alert.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|titleRequired|string|The dialog's title.|
|message|string|An optional message displayed above the text input.|
|callbackOrButtons|function \| AlertButton\[]|If a function, it is invoked with the prompt's value `(text: string) => void` when 'OK' is tapped.\*\*\*If an array, buttons are configured based on its content.|
|type|AlertType|Configures the text input.|
|defaultValue|string|Default text in the input field.|
|keyboardType|string|Keyboard type for the first text field (if present). One of `TextInput` keyboard types.|
|options|AlertOptions|Optional configuration for the alert.|

#### Type Definitions

##### `AlertButtonStyle` (iOS Only)

An enum representing iOS Alert button styles.

**Constants:**

|Value|Description|
|-|-|
|`'default'`|Default button style.|
|`'cancel'`|Cancel button style.|
|`'destructive'`|Destructive button style.|

##### `AlertType` (iOS Only)

An enum representing iOS Alert types.

**Constants:**

|Value|Description|
|-|-|
|`'default'`|Default alert with no inputs|
|`'plain-text'`|Plain text input alert|
|`'secure-text'`|Secure text input alert|
|`'login-password'`|Login and password alert|

##### `AlertButton`

An object describing a button's configuration in an alert.

**Properties:**

|Name|Type|Description|
|-|-|-|
|text|string|Button label.|
|onPress|function|Callback when the button is pressed.|
|styleiOS|AlertButtonStyle|Button style, ignored on Android.|
|isPreferrediOS|boolean|Whether to emphasize the button, ignored on Android.|

##### `AlertOptions`

An object for optional alert configurations.

**Properties:**

|Name|Type|Description|
|-|-|-|
|cancelableAndroid|boolean|Determines if the alert can be dismissed by tapping outside of it.|
|userInterfaceStyleiOS|string|Interface style for the alert, set to `light` or `dark`, otherwise defaults to system style.|
|onDismissAndroid|function|Callback fired when the alert is dismissed.|

## Optimizing JavaScript loading

Parsing and executing JavaScript code requires both memory and time. As applications grow, it becomes beneficial to delay loading code until it's needed for the first time. React Native includes standard optimizations by default, but additional techniques can further enhance app efficiency. For very large apps, advanced automatic optimizations are available, though they come with tradeoffs.

### Recommended: Use Hermes

Hermes is the default engine for new React Native applications and is optimized for efficient code loading. In release builds, JavaScript code is precompiled to bytecode ahead of time. This bytecode is loaded into memory on-demand, eliminating the need for parsing plain JavaScript.

**Info:** Learn more about using Hermes in React Native [here](#).

### Recommended: Lazy-load Large Components

If a component with substantial code or dependencies isn't needed during initial app rendering, use React's `lazy` API to defer its loading until it is rendered for the first time. Typically, consider lazy-loading screen-level components to prevent new screens from increasing startup time.

**Info:**

#### Tip: Avoid Module Side Effects

Lazy-loading can alter app behavior if component modules or their dependencies have side effects, such as modifying global variables or subscribing to external events. Most React app modules should be free of side effects.

##### Example: SideEffects.tsx

```tsx
import Logger from "./utils/Logger"

// 🚩🚩🚩 Side effect! This must execute before React can render the SplashScreen component.
global.logger = new Logger()

export function SplashScreen() {
  // ...
}
```

### Advanced: Call `require` Inline

To defer loading code without using `lazy` or asynchronous `import()`, use the `require()` function where you would typically use a static `import`.

##### Example: VeryExpensive.tsx

```tsx
import { Component } from "react"
import { Text } from "react-native"

// ... import some very expensive modules

export default function VeryExpensive() {
  // ... lots and lots of rendering logic
  return <Text>Very Expensive Component</Text>
}
```

##### Example: Optimized.tsx

```tsx
import { useCallback, useState } from "react"
import { TouchableOpacity, View, Text } from "react-native"

let VeryExpensive = null

export default function Optimize() {
  const [needsExpensive, setNeedsExpensive] = useState(false)

  const didPress = useCallback(() => {
    if (VeryExpensive == null) {
      VeryExpensive = require("./VeryExpensive").default
    }
    setNeedsExpensive(true)
  }, [])

  return (
    <View style={{ marginTop: 20 }}>
      <TouchableOpacity onPress={didPress}>
        <Text>Load</Text>
      </TouchableOpacity>
      {needsExpensive ? <VeryExpensive /> : null}
    </View>
  )
}
```

### Advanced: Automatically Inline `require` Calls

When using the React Native CLI to build your app, `require` calls (but not `import`s) are automatically inlined for you and any third-party packages (`node_modules`) used.

```tsx
import { useCallback, useState } from "react"
import { TouchableOpacity, View, Text } from "react-native"

// This top-level require call will be evaluated lazily as part of the component below.
const VeryExpensive = require("./VeryExpensive").default

export default function Optimize() {
  const [needsExpensive, setNeedsExpensive] = useState(false)

  const didPress = useCallback(() => {
    setNeedsExpensive(true)
  }, [])

  return (
    <View style={{ marginTop: 20 }}>
      <TouchableOpacity onPress={didPress}>
        <Text>Load</Text>
      </TouchableOpacity>
      {needsExpensive ? <VeryExpensive /> : null}
    </View>
  )
}
```

**Info:** Some React Native frameworks, like Expo projects, do not inline `require` calls by default. Enable this optimization in your project's Metro config by setting `inlineRequires: true` in `getTransformOptions`.

#### Pitfalls of Inline `require`s

Inlining `require` calls alters the order in which modules are evaluated and can prevent some from being evaluated at all. This is generally safe as JavaScript modules are often side-effect-free.

If a module has side effects, such as initializing logging or patching global APIs, unexpected behavior or crashes may occur. In these cases, exclude certain modules from this optimization or disable it entirely.

To **disable automatic inlining of `require` calls**:

Update your `metro.config.js` to set the `inlineRequires` transformer option to `false`:

```js
module.exports = {
  transformer: {
    async getTransformOptions() {
      return {
        transform: {
          inlineRequires: false,
        },
      }
    },
  },
}
```

To **exclude certain modules from `require` inlining**:

Use the transformer options `inlineRequires.blockList` and `nonInlinedRequires`. See the code snippet for examples of how to use each one.

```js
module.exports = {
  transformer: {
    async getTransformOptions() {
      return {
        transform: {
          inlineRequires: {
            blockList: {
              // require() calls in `DoNotInlineHere.js` will not be inlined.
              [require.resolve("./src/DoNotInlineHere.js")]: true,

              // require() calls elsewhere will be inlined unless they match any entry nonInlinedRequires (see below).
            },
          },
          nonInlinedRequires: [
            // require('react') calls will not be inlined anywhere
            "react",
          ],
        },
      }
    },
  },
}
```

See the documentation for `getTransformOptions` in Metro for more details on setting up and fine-tuning your inline `require`s.

### Advanced: Use Random Access Module Bundles (Non-Hermes)

**Not supported when using Hermes.** Hermes bytecode is incompatible with RAM bundle format, offering similar or better performance across all use cases.

Random access module bundles (RAM bundles) work alongside the techniques mentioned above to limit JavaScript code parsing and memory loading. Each module is stored as a separate string or file, parsed only when needed for execution.

RAM bundles may be physically split into files or use an indexed format with a lookup table of multiple modules in one file.

#### Android

Enable RAM format by editing your `android/app/build.gradle` file. Before the line `apply from: "../../node_modules/react-native/react.gradle"`, add or amend the `project.ext.react` block:

```gradle
project.ext.react = [
  bundleCommand: "ram-bundle",
]
```

For a single indexed file on Android, use:

```gradle
project.ext.react = [
  bundleCommand: "ram-bundle",
  extraPackagerArgs: ["--indexed-ram-bundle"]
]
```

#### iOS

RAM bundles are always indexed (single file) on iOS.

Enable RAM format in Xcode by editing the build phase "Bundle React Native code and images". Before `../node_modules/react-native/scripts/react-native-xcode.sh`, add:

```sh
export BUNDLE_COMMAND="ram-bundle"
export NODE_BINARY=node
../node_modules/react-native/scripts/react-native-xcode.sh
```

See the documentation for `getTransformOptions` in Metro for more details on setting up and fine-tuning your RAM bundle build.

## Profiling

Profiling involves analyzing an app's performance, resource usage, and behavior to identify potential bottlenecks or inefficiencies. Utilizing profiling tools ensures your app runs smoothly across various devices and conditions.

For iOS, Instruments is a valuable tool, while on Android, the Android Studio Profiler should be used.

**Important:** Ensure Development Mode is OFF! Your application logs should indicate `__DEV__ === false`, meaning development-level warnings are off and performance optimizations are enabled.

### Profiling Android UI Performance with System Tracing

Android supports over 10,000 different phones and generalizes to support software rendering. This means you might not get as much optimization out-of-the-box compared to iOS. However, there are often areas for improvement that aren't related to native code.

The first step in debugging performance issues is determining where time is spent during each 16ms frame using the built-in System Tracing profiler in Android Studio.

#### 1. Collecting a Trace

- Connect your device exhibiting stuttering via USB.
- Open your project's `android` folder in Android Studio, select your device, and run your project as profileable.
- With your app running on the device, navigate to the point just before the animation or interaction you want to profile.
- Start "Capture System Activities" in the Android Studio Profiler pane.
- Perform the desired action, then press "Stop recording."
- Inspect the trace directly in Android Studio or export it for analysis with tools like Perfetto.

#### 2. Reading the Trace

After opening the trace in Android Studio or Perfetto:

- Use WASD keys to navigate and zoom within the tool.
- Enable VSync highlighting at the top right of the screen to see frame boundaries as zebra stripes. If not visible, try profiling on a different device (e.g., Nexus series).

#### 3. Find Your Process

Scroll to find your package name in the trace. For example, `com.facebook.adsmanager` might appear as `book.adsmanager`.

Identify key threads:

- **UI Thread:** Handles standard Android measure/layout/draw operations. Look for events related to `Choreographer`, `traversals`, and `DispatchUI`.
- **JS Thread:** Executes JavaScript code. Identify it by looking for `JSCall` or `Bridge.executeJSCall`.
- **Native Modules Thread:** Manages native module calls (e.g., `UIManager`). Look for `NativeCall` or `callJavaModuleMethod`.
- **Render Thread (Android 5+):** Generates OpenGL commands. Identify it by looking for `DrawFrame` and `queueBuffer`.

### Identifying a Culprit

A smooth animation should show no thread working near frame boundaries, indicating 60 FPS rendering.

If choppy performance is observed:

- **JS Issues:** If the JS thread works continuously across frames, the problem lies in JavaScript execution.
- **Native UI Issues:** If the UI or Render threads work across frame boundaries, the issue is with native views being rendered.

### Resolving JavaScript Issues

For JS problems:

- Investigate specific JS code. Look for frequent calls like `RCTEventEmitter`.
- Consider optimizing component updates using methods like `shouldComponentUpdate`.

### Resolving Native UI Issues

Native UI issues can arise from:

1. **Excessive GPU Work:** Long durations in `DrawFrame` indicate heavy GPU load.

   - Use `renderToHardwareTextureAndroid` for complex animations.
   - Avoid `needsOffscreenAlphaCompositing`, which increases GPU load.

1. **Creating New Views on the UI Thread:**
   - Postpone creating new UI until after interactions or simplify the UI being created.
   - The React Native team is developing solutions to create and configure UI off the main thread.

### Finding Native CPU Hotspots

For native-side issues:

- Use the Android Studio Profiler's "Find CPU Hotspots (Java/Kotlin Method Recording)" feature.
- Select Java/Kotlin recording, perform interactions, and stop recording after a short interaction.
- Analyze the trace in Android Studio or export it for further analysis with tools like Firefox Profiler.

CPU hotspot profiling is resource-intensive and may not provide precise measurements but can highlight native methods consuming time during each frame.

## ECMAScript Features Overview

### ECMAScript 5 Reserved Words

- **Example**:
  ```typescript
  promise.catch(function() {...});
  ```

### ECMAScript 2015 (ES6) Arrow Functions

- **Example**:
  ```typescript
  <C onPress={() => this.setState({pressed: true})} />
  ```

### Block Scoping

- **Example**:
  ```typescript
  let greeting = "hi"
  ```

### Call Spread

- **Example**:
  ```typescript
  Math.max(...array)
  ```

### Classes

- **Example**:
  ```typescript
  class C extends React.Component {render() { return <View />; }}
  ```

### Computed Properties

- **Example**:
  ```typescript
  const key = "abc"
  const obj = { [key]: 10 }
  ```

### Constants

- **Example**:
  ```typescript
  const answer = 42
  ```

### Destructuring

- **Example**:
  ```typescript
  const { isActive, style } = this.props
  ```

### for…of Loop

- **Example**:
  ```typescript
  for (var num of [1, 2, 3]) {...};
  ```

### Function Name

- **Example**:
  ```typescript
  let number = (x) => x
  ```

### Literals

- **Example**:
  ```typescript
  const b = 0b11
  const o = 0o7
  const u = "Hello\u{000A}\u{0009}!"
  ```

### Modules

- **Example**:
  ```typescript
  import React, { Component } from "react"
  ```

### Object Concise Method

- **Example**:
  ```typescript
  const obj = {
    method() {
      return 10
    },
  }
  ```

### Object Short Notation

- **Example**:
  ```typescript
  const name = "vjeux"
  const obj = { name }
  ```

### Parameters with Default Values and Destructuring

- **Example**:
  ```typescript
  function test(x = "hello", { a, b }, ...args) {}
  ```

### Rest Params

- **Example**:
  ```typescript
  function(type, ...args) {};
  ```

### Shorthand Properties

- **Example**:
  ```typescript
  const o = { a, b, c }
  ```

### Sticky Regex

- **Example**:
  ```typescript
  const a = /o+/y
  ```

### Template Literals

- **Example**:
  ```typescript
  const who = "world"
  const str = `Hello ${who}`
  ```

### Unicode Regex

- **Example**:
  ```typescript
  const string = "foo💩bar"
  const match = string.match(/foo(.)bar/u)
  ```

### ECMAScript 2016 (ES7) Exponentiation Operator

- **Example**:
  ```typescript
  let x = 10 ** 2
  ```

### ECMAScript 2017 (ES8) Async Functions

- **Example**:
  ```typescript
  async function doStuffAsync() {
    const foo = await doOtherStuffAsync()
  }
  ```

### Function Trailing Comma

- **Example**:
  ```typescript
  function f(a, b, c) {}
  ```

### ECMAScript 2018 (ES9) Object Spread

- **Example**:
  ```typescript
  const extended = { ...obj, a: 10 }
  ```

### ECMAScript 2019 (ES10) Optional Catch Binding

- **Example**:
  ```typescript
  try {
    throw 0
  } catch {
    doSomethingWhichDoesNotCareAboutTheValueThrown()
  }
  ```

### ECMAScript 2020 (ES11) Dynamic Imports

- **Example**:
  ```typescript
  const package = await import("package")
  package.function()
  ```

### Nullish Coalescing Operator

- **Example**:
  ```typescript
  const foo = object.foo ?? "default"
  ```

### Optional Chaining

- **Example**:
  ```typescript
  const name = obj.user?.name
  ```

### ECMAScript 2022 (ES13) Class Fields

- **Example**:
  ```typescript
  class Bork {
    static a = "foo"
    static b
    x = "bar"
    y
  }
  ```

### Stage 1 Proposal: Export Default From

- **Example**:
  ```typescript
  export v from 'mod';
  ```

### Miscellaneous Features

#### Babel Template

- **Example**:
  ```typescript
  template(`const %%importName%% = require(%%source%%);`)
  ```

#### Flow Typing

- **Example**:
  ```typescript
  function foo(x: ?number): string {}
  ```

#### ESM to CJS

- **Example**:
  ```typescript
  export default 42
  ```

#### JSX Syntax

- **Example**:
  ```typescript
  <View style={{color: 'red'}} />
  ```

#### Object Assign

- **Example**:
  ```typescript
  Object.assign(a, b)
  ```

#### React Display Name

- **Example**:
  ```typescript
  const bar = createReactClass({})
  ```

#### TypeScript Typing

- **Example**:
  ```typescript
  function foo(x: { hello: true; target: "react native!" }): string {}
  ```

## Timers

Timers play a crucial role in applications and React Native implements browser-like timers.

### Overview of Timers

React Native provides several timer functions:

- `setTimeout`, `clearTimeout`
- `setInterval`, `clearInterval`
- `setImmediate`, `clearImmediate`
- `requestAnimationFrame`, `cancelAnimationFrame`

It's important to note that `requestAnimationFrame(fn)` differs from `setTimeout(fn, 0)`. The former executes after all frames have been processed, while the latter runs as soon as possible (potentially over 1000 times per second on an iPhone 5S).

`setImmediate` is executed at the end of the current JavaScript execution block, just before sending a batched response back to native. If `setImmediate` is called within its own callback, it executes immediately without yielding back to native.

The implementation of `Promise` in React Native uses `setImmediate` for asynchronicity.

**Note:** When debugging on Android, if there's a time drift between the debugger and device, animations or event behaviors might not function correctly. To correct this, run `adb shell "date `date +%m%d%H%M%Y.%S%3N`"` on your debugger machine. Root access is required for real devices.

### InteractionManager

Native apps often feel smooth because they avoid expensive operations during interactions and animations. React Native has a limitation of a single JS execution thread, but you can use `InteractionManager` to schedule long-running tasks after interactions or animations have completed.

To schedule tasks post-interaction:

```typescript
InteractionManager.runAfterInteractions(() => {
  // ...long-running synchronous task...
})
```

#### Comparison with Other Scheduling Methods

- **requestAnimationFrame()**: Use for code that animates a view over time.
- **setImmediate/setTimeout/setInterval()**: Run code later, but may delay animations.
- **runAfterInteractions()**: Run code later without delaying active animations.

The touch handling system considers one or more active touches as an 'interaction' and delays `runAfterInteractions()` callbacks until all touches have ended or been canceled.

`InteractionManager` also allows applications to register animations by creating an interaction 'handle' at the start of an animation, and clearing it upon completion:

```typescript
const handle = InteractionManager.createInteractionHandle()
// run animation... (`runAfterInteractions` tasks are queued)
// later, on animation completion:
InteractionManager.clearInteractionHandle(handle)
// queued tasks run if all handles were cleared
```

This approach ensures that animations remain smooth while deferring other operations until interactions have concluded.

## Using Hermes

Hermes is an open-source JavaScript engine optimized for React Native. Many applications experience improved start-up time, reduced memory usage, and smaller app size when using Hermes compared to JavaScriptCore. By default, React Native uses Hermes without requiring additional configuration.

### Bundled Hermes

React Native includes a **bundled version** of Hermes. Each new release of React Native comes with a compatible version of Hermes, ensuring seamless integration. This change is transparent for React Native users, who can still disable Hermes if needed. Further technical details are available on the official documentation page.

### Confirming Hermes Usage

For newly created apps, check if Hermes is enabled in the welcome view:

A `HermesInternal` global variable will be present in JavaScript to verify Hermes usage:

```typescript
const isHermes = () => !!global.HermesInternal
```

> **Caution:** If you use a non-standard method for loading the JS bundle, the `HermesInternal` variable might exist without utilizing the optimized pre-compiled bytecode. Ensure that you are using the `.hbc` file and benchmark performance as described below.

To observe Hermes' benefits, create a release build of your app:

#### Android

```shell
npm run android -- --mode="release"
```

```shell
yarn android --mode release
```

#### iOS

```shell
npm run ios -- --mode="Release"
```

```shell
yarn ios --mode Release
```

This process compiles JavaScript to Hermes Bytecode during build time, enhancing your app's startup speed on devices.

### Switching Back to JavaScriptCore

React Native also supports using JavaScriptCore as the JavaScript engine. Follow these steps to opt-out of Hermes:

#### Android

Edit `android/gradle.properties` and set `hermesEnabled` to false:

```diff
# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
- hermesEnabled=true
+ hermesEnabled=false
```

#### iOS

Edit `ios/Podfile` as shown below:

```diff
   use_react_native!(
     :path => config[:reactNativePath],
+    :hermes_enabled => false,
     # An absolute path to your application root.
     :app_path => "#{Pod::Config.instance.installation_root}/.."
   )
```

## What is Codegen?

**Codegen** is designed to minimize repetitive coding tasks by generating scaffolding code automatically. While not mandatory—allowing manual writing of generated code—it can significantly save time.

React Native triggers **Codegen** during the build process for both iOS and Android apps. Developers may also run **Codegen** scripts manually, especially when working on Turbo Native Modules and Fabric Native Components, to review the types and files produced.

### How Codegen Works

**Codegen** is an integral part of a React Native app's development process. The scripts reside within the `react-native` NPM package and are executed during the build phase.

The **Codegen** process begins by scanning directories specified in your `package.json`, searching for JavaScript files that define specifications (specs) for custom modules and components. These spec files use a typed dialect, with React Native supporting both Flow and TypeScript.

Upon identifying a spec file, **Codegen** generates the necessary boilerplate code. This includes C++ glue-code and platform-specific implementations: Java for Android and Objective-C++ for iOS.

## Using Codegen

This guide covers how to:

- Configure **Codegen**.
- Manually invoke it for each platform.

It also describes the generated code.

### Prerequisites

A React Native app is required to generate code properly, even when invoking **Codegen** manually. The process is integrated with the app build and relies on scripts in the `react-native` NPM package.

To create a project using the React Native CLI:

```bash
npx @react-native-community/cli@latest init SampleApp --version 0.76.0
```

**Codegen** generates glue-code for custom modules or components. Refer to guides for Turbo Native Modules and Fabric Native Components for more details on creating them.

### Configuring **Codegen**

Configure **Codegen** in your app by modifying the `package.json` file using a custom field called `codegenConfig`.

```json
"codegenConfig": {
  "name": "<SpecName>",
  "type": "<types>",
  "jsSrcsDir": "<source_dir>",
  "android": {
    "javaPackageName": "<java.package.name>"
  },
  "ios": {
    "modulesConformingToProtocol": {
      "RCTImageURLLoader": [
        "<iOS-class-conforming-to-RCTImageURLLoader>"
      ],
      "RCTURLRequestHandler": [
        "<iOS-class-conforming-to-RCTURLRequestHandler>"
      ],
      "RCTImageDataDecoder": [
        "<iOS-class-conforming-to-RCTImageDataDecoder>"
      ]
    },
    "componentProvider": {
      "<componentName>": "<iOS-class-implementing-the-component>"
    },
    "modulesProvider": {
      "<moduleName>": "<iOS-class-implementing-the-RCTModuleProvider-protocol>"
    }
  }
}
```

Customize the fields as follows:

- `name`: The name for files containing your specs, typically ending with `Spec`.
- `type`: Specifies code generation type. Allowed values are `modules`, `components`, `all`.
  - `modules`: For Turbo Native Modules.
  - `components`: For Native Fabric Components.
  - `all`: For both components and modules.
- `jsSrcsDir`: Root folder for your specs.
- `android.javaPackageName`: Custom package name for Android code generation.

The `ios` field is optional and allows advanced configurations:

- `modulesConformingToProtocol`: Define iOS native modules conforming to specific protocols, injected into the React Native runtime at app start.
  - `RCTImageURLLoader`, `RCTURLRequestHandler`, `RCTImageDataDecoder`: List classes implementing these protocols as Native Modules.
- `componentProvider`: Map JS React components to their native implementations.
- `modulesProvider`: Map JS Native Modules to their native providers.

**Codegen** searches for JS files following specific conventions among app dependencies:

- Turbo Native Modules: Spec files prefixed with `Native` (e.g., `NativeLocalStorage.ts`).
- Native Fabric Components: Spec files suffixed with `NativeComponent` (e.g., `WebViewNativeComponent.ts`).

### Running **Codegen**

Assuming you have a Native Turbo Module, Native Fabric Component, or both set up in your project, and valid specification files in the `jsSrcsDir`, follow these steps:

#### Android

**Codegen** for Android is integrated with the React Native Gradle Plugin (RNGP). The RNGP task reads configurations from `package.json` and executes **Codegen**. Run this command inside the `android` folder of your project:

```bash
./gradlew generateCodegenArtifactsFromSchema
```

This generates code in the corresponding `node_modules/<dependency>/android/build/generated/source/codegen` folder.

##### The Generated Code

After running the gradle task, find the generated code in the `SampleApp/android/app/build` folder. The structure is:

```
build
└── generated
    └── source
        └── codegen
            ├── java
            │   └── com
            │       ├── facebook
            │       │   └── react
            │       │       └── viewmanagers
            │       │           ├── <nativeComponent>ManagerDelegate.java
            │       │           └── <nativeComponent>ManagerInterface.java
            │       └── sampleapp
            │           └── NativeLocalStorageSpec.java
            ├── jni
            │   ├── <codegenConfig.name>-generated.cpp
            │   ├── <codegenConfig.name>.h
            │   ├── react
            │   │   └── renderer
            │   │       └── components
            │   │           ├── <codegenConfig.name>
            │   │           │   ├── ComponentDescriptors.cpp
            │   │           │   ├── ComponentDescriptors.h
            │   │           │   ├── EventEmitters.cpp
            │   │           │   ├── EventEmitters.h
            │   │           │   ├── Props.cpp
            │   │           │   ├── Props.h
            │   │           │   ├── RCTComponentViewHelpers.h
            │   │           │   ├── ShadowNodes.cpp
            │   │           │   ├── ShadowNodes.h
            │   │           │   └── States.cpp
            │   │           └── schema.json
            └── schema.json
```

The generated code is split into:

- `java`: Platform-specific code.
- `jni`: C++ code for JS and Java interaction.

In the `java` folder, Fabric Native component code resides in `com/facebook/viewmanagers`, including:

- `<nativeComponent>ManagerDelegate.java`: Methods callable by `ViewManager`.
- `<nativeComponent>ManagerInterface.java`: Interface of the `ViewManager`.

The Turbo Native Module abstract class is in the folder specified by `codegenConfig.android.javaPackageName`.

In the `jni` folder, you find:

- `<codegenConfig.name>.h`: Interface for custom C++ Turbo Native Modules.
- `<codegenConfig.name>-generated.cpp`: Glue code for custom C++ Turbo Native Modules.
- `react/renderer/components/<codegenConfig.name>`: Glue-code for your component.

This structure is generated using the value `all` for `codegenConfig.type`. Use `modules` to exclude `react/renderer/components/`, and `components` to exclude other files.

#### iOS

**Codegen** for iOS uses Node scripts invoked during the build process, located in `SampleApp/node_modules/react-native/scripts/`.

The main script is `generate-codegen-artifacts.js`. Invoke it from your app's root folder:

```bash
node node_modules/react-native/scripts/generate-codegen-artifacts.js

Usage: generate-codegen-artifacts.js -p [path to app] -t [target platform] -o [output path]

Options:
      --help            Show help                                      [boolean]
      --version         Show version number                            [boolean]
  -p, --path            Path to the React Native project root.        [required]
  -t, --targetPlatform  Target platform. Supported values: "android", "ios",
                        "all".                                        [required]
  -o, --outputPath      Path where generated artifacts will be output to.
```

Arguments:

- `--path`: Path to the app's root folder.
- `--outputPath`: Destination for generated files.
- `--targetPlatform`: Platform for code generation.

##### The Generated Code

Run this command to generate files in the `ios/build` folder:

```bash
node node_modules/react-native/scripts/generate-codegen-artifacts.js \
    --path . \
    --outputPath ios/ \
    --targetPlatform ios
```

Generated files include:

```
build
└── generated
    └── ios
        ├── <codegenConfig.name>
        │   ├── <codegenConfig.name>-generated.mm
        │   └── <codegenConfig.name>.h
        ├── <codegenConfig.name>JSI-generated.cpp
        ├── <codegenConfig.name>JSI.h
        ├── FBReactNativeSpec
        │   ├── FBReactNativeSpec-generated.mm
        │   └── FBReactNativeSpec.h
        ├── FBReactNativeSpecJSI-generated.cpp
        ├── FBReactNativeSpecJSI.h
        ├── RCTModulesConformingToProtocolsProvider.h
        ├── RCTModulesConformingToProtocolsProvider.mm
        └── react
            └── renderer
                └── components
                    └── <codegenConfig.name>
                        ├── ComponentDescriptors.cpp
                        ├── ComponentDescriptors.h
                        ├── EventEmitters.cpp
                        ├── EventEmitters.h
                        ├── Props.cpp
                        ├── Props.h
                        ├── RCTComponentViewHelpers.h
                        ├── ShadowNodes.cpp
                        ├── ShadowNodes.h
                        └── States.cpp
```

Files include:

- `<codegenConfig.name>/<codegenConfig.name>.h`: Interface for custom iOS Turbo Native Modules.
- `<codegenConfig.name>/<codegenConfig.name>-generated.mm`: Glue code for custom iOS Turbo Native Modules.
- `<codegenConfig.name>JSI.h`: Interface for custom C++ Turbo Native Modules.
- `<codegenConfig.name>JSI-generated.cpp`: Glue code for custom C++ Turbo Native Modules.
- `react/renderer/components/<codegenConfig.name>`: Glue-code for your component.

This structure is generated using the value `all` for `codegenConfig.type`. Use `modules` to exclude `react/renderer/components/`, and `components` to exclude other files.

## The Codegen CLI

The **Codegen** CLI simplifies running tasks by eliminating the need to remember complex commands or manually execute scripts. It facilitates executing `@react-native/codegen` for React Native projects with ease.

### Usage

To view available options, use:

```sh
npx @react-native-community/cli codegen --help
```

#### Options

- **--verbose**: Increases logging verbosity.
- **--path <path>**: Specifies the path to the React Native project root. Default is `/Users/MyUsername/projects/my-app`.
- **--platform <string>**: Targets a specific platform. Supported values: `android`, `ios`, `all`. Default is `all`.
- **--outputPath <path>**: Defines where generated artifacts will be output.
- **-h, --help**: Displays help for the command.

### Examples

1. Generate code based on `package.json` in the current directory:

   ```sh
   npx @react-native-community/cli codegen
   ```

1. Generate iOS-specific code using the configuration from `package.json`:

   ```sh
   npx @react-native-community/cli codegen --platform ios
   ```

1. Generate Android code for a library located in `third-party/some-library`, outputting to `third-party/some-library/android/generated`:

   ```sh
   npx @react-native-community/cli codegen \
       --path third-party/some-library \
       --platform android \
       --outputPath third-party/some-library/android/generated
   ```

### Including Generated Code in Libraries

The **Codegen** CLI is particularly useful for library developers. It allows previewing generated code to determine necessary interfaces.

#### Benefits of `includesGeneratedCode = true`

- Eliminates dependency on the app to run **Codegen**.
- Ensures consistency between implementation files and generated interfaces, enhancing resilience against API changes.
- Reduces redundancy by supporting only one architecture set for Android, ensuring backward compatibility.
- Enables shipping native code as a prebuild.

#### Drawbacks

- Generated code will use the React Native version specified in your library. This may lead to compatibility issues with apps using older React Native versions.

### Enabling `includesGeneratedCode`

To incorporate generated code into your library:

1. Add `includesGeneratedCode: true` to the `codegenConfig` field in your `package.json`.
1. Execute **Codegen** locally using the CLI.
1. Update `package.json`, `podspec`, and `build.gradle` files to include the generated code.
1. Modify `cmakeListsPath` in `react-native.config.js` to direct Gradle to the correct output directory instead of the build directory.

By following these steps, you can streamline your development process and ensure that your library remains compatible with various React Native versions.

## Native Platform

### Overview

This guide covers how to integrate native platform features into your React Native application, which may not be directly accessible through React Native or third-party libraries. It also addresses the reuse of existing code written in Objective-C, Swift, Java, Kotlin, or C++ from within the JavaScript runtime.

#### Key Concepts

- **Native Modules:** These are native libraries without a user interface (UI). They include functionalities like persistent storage, notifications, and network events, accessible as JavaScript functions and objects.

- **Native Components:** These refer to platform-specific views, widgets, and controllers that can be utilized in your application's JavaScript code through React components.

> **Note:** Legacy Native Modules and Native Components are deprecated. However, they can still function with the New Architecture via interop layers. Consider:

- Using alternative libraries.
- Upgrading to newer library versions supporting the New Architecture.
- Porting these libraries to Turbo Native Modules or Fabric Native Components.

### Sections

1. **Native Modules**

   - Android & iOS
   - Cross-Platform with C++
   - Advanced: Custom C++ Types

1. **Fabric Native Components**
   - Android & iOS

***

**Previous:** The Codegen CLI\
**Next:** Android and iOS

## BackHandler

The **BackHandler** API is designed for Android devices to manage hardware button presses related to back navigation. It allows developers to register event listeners and control the application's response to these events.

### Key Features

- **Event Subscription Order**: Subscriptions are processed in reverse order, meaning the last registered listener is invoked first.
- **Subscription Behavior**:
  - If a subscription returns `true`, subsequent subscriptions will not be called.
  - If no subscription returns `true` or if none are registered, the default back button functionality (exiting the app) is triggered.

> **Note for Modal Users**: When an app displays an open `Modal`, `BackHandler` does not trigger any events. Refer to the `Modal` documentation for more details.

### Implementation Pattern

Below is a TypeScript example demonstrating how to use the BackHandler API:

```typescript
const subscription = BackHandler.addEventListener(
  "hardwareBackPress",
  function () {
    // Example logic: Check if on main screen or navigate back.
    if (!this.onMainScreen()) {
      this.goBack()
      // Returning true prevents further event propagation.
      return true
    }
    // Returning false allows the event to propagate further.
    return false
  }
)

// Ensure to remove the listener when it's no longer needed
subscription.remove()
```

### Example Scenario

Consider a scenario where you need user confirmation before exiting the app. The `BackHandler.addEventListener` method creates an event listener and returns a `NativeEventSubscription` object, which should be removed using the `remove` method.

### Integration with React Navigation

For those utilizing **React Navigation**, refer to their guide on customizing Android back button behavior for seamless integration.

### Using Hooks

The **React Native Hooks** library offers a convenient `useBackHandler` hook that simplifies setting up event listeners.

***

## Reference Methods

#### `addEventListener()`

Registers an event listener for the specified event name and returns a subscription object.

```typescript
static addEventListener(
  eventName: BackPressEventName,
  handler: () => boolean | null | undefined,
): NativeEventSubscription;
```

#### `exitApp()`

Programmatically exits the application.

```typescript
static exitApp();
```

## Native Modules

To implement a cross-platform `localStorage` solution using React Native's TurboModule system, you need to set up both Android and iOS platforms. Below is a step-by-step guide based on the provided instructions:

#### Android Setup

1. **Define the JavaScript Interface:**

   Create a TypeScript file for your module interface.

   ```typescript
   // specs/NativeLocalStorageSpec.ts
   import { TurboModule, TurboModuleRegistry } from 'react-native';

   export interface Spec extends TurboModule {
     getItem(key: string): Promise<string | null>;
     setItem(value: string, key: string): Promise<void>;
     removeItem(key: string): Promise<void>;
     clear(): Promise<void>;
   }

   export default NativeLocalStorage as unknown as typeof TurboModuleRegistry.get<Spec>('NativeLocalStorage');
   ```

1. **Implement the Android Module:**

   Create a Java class that implements the `NativeLocalStorageSpec`.

   ```java
   // android/src/main/java/com/nativelocalstorage/NativeLocalStoragePackage.java
   package com.nativelocalstorage;

   import androidx.annotation.NonNull;
   import com.facebook.react.ReactPackage;
   import com.facebook.react.bridge.NativeModule;
   import com.facebook.react.bridge.ReactApplicationContext;
   import com.facebook.react.uimanager.ViewManager;
   import java.util.ArrayList;
   import java.util.Collections;
   import java.util.List;

   public class NativeLocalStoragePackage implements ReactPackage {
     @NonNull
     @Override
     public List<NativeModule> createNativeModules(@NonNull ReactApplicationContext reactContext) {
       List<NativeModule> modules = new ArrayList<>();
       modules.add(new NativeLocalStorage(reactContext));
       return modules;
     }

     @Override
     public List<ViewManager> createViewManagers(@NonNull ReactApplicationContext reactContext) {
       return Collections.emptyList();
     }
   }
   ```

   ```java
   // android/src/main/java/com/nativelocalstorage/NativeLocalStorage.java
   package com.nativelocalstorage;

   import androidx.annotation.NonNull;
   import com.facebook.react.bridge.Promise;
   import com.facebook.react.bridge.ReactApplicationContext;
   import com.facebook.react.bridge.ReactContextBaseJavaModule;
   import com.facebook.react.module.annotations.ReactModule;
   import java.util.HashMap;
   import java.util.Map;

   @ReactModule(name = NativeLocalStorage.NAME)
   public class NativeLocalStorage extends ReactContextBaseJavaModule {
     public static final String NAME = "NativeLocalStorage";

     private final Map<String, String> storage = new HashMap<>();

     public NativeLocalStorage(@NonNull ReactApplicationContext reactContext) {
       super(reactContext);
     }

     @Override
     @NonNull
     public String getName() {
       return NAME;
     }

     @ReactMethod
     public void getItem(String key, Promise promise) {
       promise.resolve(storage.get(key));
     }

     @ReactMethod
     public void setItem(String value, String key, Promise promise) {
       storage.put(key, value);
       promise.resolve(null);
     }

     @ReactMethod
     public void removeItem(String key, Promise promise) {
       storage.remove(key);
       promise.resolve(null);
     }

     @ReactMethod
     public void clear(Promise promise) {
       storage.clear();
       promise.resolve(null);
     }
   }
   ```

1. **Register the Package:**

   Update your `MainApplication.java` to include the new package.

   ```java
   // android/app/src/main/java/com/yourapp/MainApplication.java
   import com.nativelocalstorage.NativeLocalStoragePackage;

   @Override
   protected List<ReactPackage> getPackages() {
     return Arrays.<ReactPackage>asList(
       new MainReactPackage(),
       new NativeLocalStoragePackage()
     );
   }
   ```

#### iOS Setup

1. **Prepare the Xcode Project:**

   - Open `TurboModuleExample.xcworkspace`.
   - Create a group named `NativeLocalStorage`.
   - Add a new Objective-C++ file `RCTNativeLocalStorage.mm`.

1. **Implement the Module Interface:**

   Update `RCTNativeLocalStorage.h` and `RCTNativeLocalStorage.mm`.

   ```objc
   // NativeLocalStorage/RCTNativeLocalStorage.h
   #import <Foundation/Foundation.h>
   #import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>

   NS_ASSUME_NONNULL_BEGIN

   @interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>
   @end

   NS_ASSUME_NONNULL_END
   ```

   ```objc
   // NativeLocalStorage/RCTNativeLocalStorage.mm
   #import "RCTNativeLocalStorage.h"

   static NSString *const RCTNativeLocalStorageKey = @"local-storage";

   @interface RCTNativeLocalStorage()
   @property (strong, nonatomic) NSUserDefaults *localStorage;
   @end
   ```

@implementation RCTNativeLocalStorage

- (instancetype)init { if (self = \[super init]) { \_localStorage = \[\[NSUserDefaults alloc] initWithSuiteName:RCTNativeLocalStorageKey]; } return self; }

- (std::shared\_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params { return std::make\_shared<facebook::react::NativeLocalStorageSpecJSI>(params); }

- (NSString \* \_Nullable)getItem:(NSString \*)key { return \[self.localStorage stringForKey:key]; }

- (void)setItem:(NSString \*)value key:(NSString \*)key { \[self.localStorage setObject:value forKey:key]; }

- (void)removeItem:(NSString \*)key { \[self.localStorage removeObjectForKey:key]; }

- (void)clear { NSDictionary \*keys = \[self.localStorage dictionaryRepresentation]; for (NSString \*key in keys) { \[self removeItem:key]; } }

* (NSString \*)moduleName { return @"NativeLocalStorage"; }

@end

````

3. **Register the Module:**

Update `package.json` to link the JS interface with the native implementation.

```json
"codegenConfig": {
  "name": "AppSpecs",
  "type": "modules",
  "jsSrcsDir": "specs",
  "android": {
    "javaPackageName": "com.sampleapp.specs"
  },
  "ios": {
    "modulesProvider": {
      "NativeLocalStorage": "RCTNativeLocalStorage"
    }
  }
}
````

4. **Reinstall Pods:**

   Run the following commands to ensure everything is set up correctly.

   ```bash
   bundle exec pod install
   open TurboModuleExample.xcworkspace
   ```

#### Build and Run

- For Android:

  ```bash
  npm run android
  # or
  yarn run android
  ```

- For iOS:

  ```bash
  npm run ios
  # or
  yarn run ios
  ```

This setup provides a consistent `localStorage` API across both platforms using React Native's TurboModule system.

## Cross-Platform Native Modules (C++)

Creating a cross-platform native module using C++ is an efficient way to share platform-agnostic code between Android and iOS. This guide walks through the process of creating a pure C++ Turbo Native Module, which allows you to write your logic once and reuse it across platforms.

#### Prerequisites

Ensure you have the following setup:

- React Native environment set up for both Android and iOS.
- Basic understanding of C++, Objective-C, and JavaScript/TypeScript.

#### Steps to Create a C++ Turbo Native Module

##### 1. Set Up Your Project

Start by creating a new React Native project if you haven't already:

```bash
npx react-native init SampleApp
cd SampleApp
```

##### 2. Define the JS Spec

Create a TypeScript file for your module spec in `specs/NativeSampleModule.ts`:

```typescript
import { TurboModule } from "react-native"

export interface Spec extends TurboModule {
  reverseString(value: string): string
}

export default NativeModules.NativeSampleModule as Spec | null
```

##### 3. Implement the C++ Module

###### Android Implementation

1. **Create Header and Source Files**

   Create `NativeSampleModule.h`:

   ```cpp
   #pragma once

   #include <react/TurboModule.h>
   #include <react/uimanager/ViewManager.h>

   namespace facebook {
   namespace react {

   class NativeSampleModule : public TurboModule {
   public:
     using TurboModule::TurboModule;

     virtual ~NativeSampleModule() = default;

     DECLARE_TURBO_MODULE(NativeSampleModule, TurboModule);
     static constexpr auto kName = "NativeSampleModule";

     virtual std::string reverseString(std::string value) = 0;
   };

   } // namespace react
   } // namespace facebook

   #ifdef __cplusplus
   extern "C" {
   #endif

   JNIEXPORT void JNICALL
   Java_com_sampleapp_NativeSampleModule_init(JNIEnv* env, jclass clazz);

   #ifdef __cplusplus
   }
   #endif
   ```

   Create `NativeSampleModule.cpp`:

   ```cpp
   #include "NativeSampleModule.h"

   namespace facebook {
   namespace react {

   class NativeSampleModuleImpl : public NativeSampleModule {
   public:
     explicit NativeSampleModuleImpl(const std::shared_ptr<CallInvoker>& jsInvoker)
         : TurboModule("NativeSampleModule", jsInvoker) {}

     std::string reverseString(std::string value) override {
       std::reverse(value.begin(), value.end());
       return value;
     }
   };

   // Register the module
   void registerNativeSampleModule(
       ReactApplicationContext& context,
       const std::shared_ptr<CallInvoker>& jsInvoker) {
     auto moduleHolder = std::make_shared<std::weak_ptr<NativeSampleModule>>();
     getOrSetTurboModule(context, *moduleHolder, NativeSampleModule::kName, []() -> std::shared_ptr<TurboModule> {
       return std::make_shared<NativeSampleModuleImpl>(jsInvoker);
     });
   }

   } // namespace react
   } // namespace facebook

   #ifdef __cplusplus
   extern "C" {
   #endif

   JNIEXPORT void JNICALL
   Java_com_sampleapp_NativeSampleModule_init(JNIEnv* env, jclass clazz) {
     auto& context = getReactApplicationContext();
     auto jsInvoker = getJavaScriptCallInvoker(context);
     facebook::react::registerNativeSampleModule(context, jsInvoker);
   }

   #ifdef __cplusplus
   }
   #endif
   ```

1. **Register the Module in Java**

   Create `com/sampleapp/NativeSampleModule.java`:

   ```java
   package com.sampleapp;

   import com.facebook.react.bridge.ReactApplicationContext;
   import com.facebook.react.bridge.ReactContextBaseJavaModule;
   import com.facebook.react.module.annotations.ReactModule;
   import com.facebook.react.turbomodule.core.interfaces.TurboModule;
   import com.facebook.react.turbomodule.core.internal.TurboReactPackage;

   @ReactModule(name = NativeSampleModule.NAME)
   public class NativeSampleModule extends ReactContextBaseJavaModule {
     static final String NAME = "NativeSampleModule";

     private final TurboReactPackage mTurboReactPackage;

     public NativeSampleModule(ReactApplicationContext reactContext, TurboReactPackage turboReactPackage) {
       super(reactContext);
       mTurboReactPackage = turboReactPackage;
     }

     @Override
     public String getName() {
       return NAME;
     }

     static void registerNativeModules(ReactPackageList packages, ReactApplicationContext context) {
       packages.add(new NativeSampleModule(context, (TurboReactPackage) packages.get(0)));
     }
   }
   ```

1. **Modify `MainApplication.java`**

   Ensure your `MainApplication.java` includes the Turbo module package:

   ```java
   import com.facebook.react.ReactNativeHost;
   import com.facebook.react.ReactPackage;
   import com.facebook.react.shell.MainReactPackage;
   import com.facebook.soloader.SoLoader;
   import java.util.List;

   public class MainApplication extends Application implements ReactApplication {
     private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
       @Override
       public boolean getUseDeveloperSupport() {
         return BuildConfig.DEBUG;
       }

       @Override
       protected List<ReactPackage> getPackages() {
         List<ReactPackage> packages = new PackageList(this).getPackages();
         packages.add(new MainReactPackage());
         // Add this line
         packages.add(new TurboReactPackage());
         return packages;
       }
     };

     @Override
     public ReactNativeHost getReactNativeHost() {
       return mReactNativeHost;
     }

     @Override
     public void onCreate() {
       super.onCreate();
       SoLoader.init(this, /* native exopackage */ false);
     }
   }
   ```

###### iOS Implementation

1. **Create the Module Provider**

   Create `SampleNativeModuleProvider.mm`:

   ```objc
   #import "SampleNativeModuleProvider.h"
   #import <React/RCTBridge+Private.h>
   #import <ReactCommon/TurboModule.h>
   #import "NativeSampleModule.h"

   @implementation SampleNativeModuleProvider

   - (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {
     return std::make_shared<facebook::react::NativeSampleModule>(params.jsInvoker);
   }

   @end
   ```

1. **Register the Module in `package.json`**

   Update your `package.json`:

   ```json
   "codegenConfig": {
     "name": "AppSpecs",
     "type": "modules",
     "jsSrcsDir": "specs",
     "android": {
       "javaPackageName": "com.sampleapp"
     },
     "ios": {
       "modulesProvider": {
         "NativeSampleModule": "SampleNativeModuleProvider"
       }
     }
   }
   ```

1. **Reinstall Pods**

   Run the following commands in the `ios` directory:

   ```bash
   bundle install
   bundle exec pod install
   open SampleApp.xcworkspace
   ```

##### 4. Test Your Module

Modify `App.tsx` to use your Turbo Native Module:

```tsx
import React, { useState } from "react"
import {
  Button,
  SafeAreaView,
  StyleSheet,
  Text,
  TextInput,
  View,
} from "react-native"
import SampleTurboModule from "./specs/NativeSampleModule"

function App(): JSX.Element {
  const [value, setValue] = useState("")
  const [reversedValue, setReversedValue] = useState("")

  const onPress = () => {
    const revString = SampleTurboModule?.reverseString(value) || ""
    setReversedValue(revString)
  }

  return (
    <SafeAreaView style={styles.container}>
      <View>
        <Text style={styles.title}>
          Welcome to C++ Turbo Native Module Example
        </Text>
        <TextInput
          style={styles.textInput}
          placeholder="Write your text here"
          onChangeText={setValue}
          value={value}
        />
        <Button title="Reverse" onPress={onPress} />
        <Text>Reversed text: {reversedValue}</Text>
      </View>
    </SafeAreaView>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  title: {
    fontSize: 18,
    marginBottom: 20,
  },
  textInput: {
    borderColor: "black",
    borderWidth: 1,
    borderRadius: 5,
    padding: 10,
    marginTop: 10,
  },
})

export default App
```

#### Conclusion

You've successfully created a C++ Turbo Native Module that works on both Android and iOS. This setup allows you to write platform-agnostic code in C++, reducing redundancy and improving maintainability across platforms.

## Native Components

To create a native web view component in React Native, you need to implement platform-specific code for both Android and iOS. Below is a step-by-step guide on how to achieve this:

#### Step 1: Set Up Your Project

Ensure your project is set up with the necessary dependencies for React Native development.

```bash
npx react-native init WebViewDemo
cd WebViewDemo
```

#### Step 2: Run Codegen

Codegen helps generate boilerplate code based on your component specifications. This step is crucial for both Android and iOS platforms.

##### For iOS:

1. Navigate to the `ios` directory:

   ```bash
   cd ios
   ```

1. Install dependencies using CocoaPods:

   ```bash
   bundle install
   bundle exec pod install
   ```

1. Open the generated Xcode workspace:
   ```bash
   open Demo.xcworkspace
   ```

##### For Android:

1. Navigate to the `android` directory:

   ```bash
   cd android
   ```

1. Run Codegen using your terminal or command prompt.

#### Step 3: Implement Native Components

##### Android Implementation

1. **Create a New Group**: In Android Studio, right-click on the app and select `New → Directory`. Name it `WebView`.

1. **Add Java Files**:

   - Create `RCTWebView.java` and `RCTWebViewPackage.java`.

1. **Implement RCTWebView\.java**:

```java
package com.webviewdemo;

import android.content.Context;
import android.util.AttributeSet;
import androidx.annotation.Nullable;
import com.facebook.react.uimanager.SimpleViewManager;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.views.view.ReactViewGroup;
import android.webkit.WebView;
import android.webkit.WebViewClient;

public class RCTWebView extends ReactViewGroup {

    private WebView webView;

    public RCTWebView(ThemedReactContext context) {
        super(context);
        init();
    }

    public RCTWebView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        webView = new WebView(getContext());
        addView(webView);
        webView.setWebViewClient(new WebViewClient() {
            @Override
            public void onPageFinished(WebView view, String url) {
                // Emit event when page is loaded
            }
        });
    }

    public void loadUrl(String url) {
        webView.loadUrl(url);
    }
}
```

4. **Implement RCTWebViewPackage.java**:

```java
package com.webviewdemo;

import androidx.annotation.NonNull;
import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class RCTWebViewPackage implements ReactPackage {

    @NonNull
    @Override
    public List<NativeModule> createNativeModules(@NonNull ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }

    @NonNull
    @Override
    public List<ViewManager> createViewManagers(@NonNull ReactApplicationContext reactContext) {
        List<ViewManager> viewManagers = new ArrayList<>();
        viewManagers.add(new RCTWebViewManager());
        return viewManagers;
    }
}
```

5. **Register the Package**: Add `RCTWebViewPackage` to your `MainApplication.java`.

```java
@Override
protected List<ReactPackage> getPackages() {
  return Arrays.<ReactPackage>asList(
      new MainReactPackage(),
      new RCTWebViewPackage()
  );
}
```

##### iOS Implementation

1. **Create Files**: In Xcode, create `RCTWebView.h` and `RCTWebView.mm`.

1. **Implement RCTWebView\.h**:

```objc
#import <React/RCTViewComponentView.h>
#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface RCTWebView : RCTViewComponentView

@end

NS_ASSUME_NONNULL_END
```

3. **Implement RCTWebView\.mm**:

```objc
#import "RCTWebView.h"
#import <WebKit/WebKit.h>

@implementation RCTWebView {
  NSURL *_sourceURL;
  WKWebView *_webView;
}

- (instancetype)init {
  if (self = [super init]) {
    _webView = [[WKWebView alloc] initWithFrame:CGRectZero];
    [_webView setNavigationDelegate:self];
    [self addSubview:_webView];
  }
  return self;
}

- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps {
  auto newViewProps = *std::static_pointer_cast<CustomWebViewProps const>(props);
  NSString *urlString = [NSString stringWithCString:newViewProps.sourceURL.c_str() encoding:NSUTF8StringEncoding];
  _sourceURL = [NSURL URLWithString:urlString];

  if (_sourceURL) {
    [_webView loadRequest:[NSURLRequest requestWithURL:_sourceURL]];
  }
}

- (void)layoutSubviews {
  [super layoutSubviews];
  _webView.frame = self.bounds;
}

#pragma mark - WKNavigationDelegate

- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
  // Emit event when page is loaded
}

@end
```

#### Step 4: Use Your Native Component in React Native

Update your `App.tsx` to use the new WebView component:

```tsx
import React from "react"
import { Alert, StyleSheet, View } from "react-native"
import { WebView as CustomWebView } from "./specs/WebViewNativeComponent"

function App(): React.JSX.Element {
  return (
    <View style={styles.container}>
      <CustomWebView
        sourceURL="https://react.dev/"
        style={styles.webview}
        onScriptLoaded={() => Alert.alert("Page Loaded")}
      />
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  webview: {
    width: "100%",
    height: "100%",
  },
})

export default App
```

#### Step 5: Run Your App

##### Android:

```bash
npx react-native run-android
```

##### iOS:

```bash
npx react-native run-ios
```

This setup will allow you to use a native web view component in your React Native application, providing better performance and integration with platform-specific features.

## Appendix

### I. Terminology

- **Spec**: TypeScript or Flow code that defines the API for a Turbo Native Module or Fabric Native component. Utilized by **Codegen** to generate boilerplate code.

- **Native Modules**: Native libraries without a User Interface (UI) for users, such as persistent storage, notifications, and network events. These are accessible in your JavaScript application code as functions and objects.

- **Native Component**: Native platform views available to your application's JavaScript code through React Components.

- **Legacy Native Components**: Components operating on the old React Native architecture.

- **Legacy Native Modules**: Modules functioning on the old React Native architecture.

### II. Codegen Typings

The following table serves as a reference for supported types and their mappings across different platforms:

|Flow|TypeScript|Flow Nullable Support|TypeScript Nullable Support|Android (Java)|iOS (ObjC)|
|-|-|-|-|-|-|
|`string`|`string`|`?string`|`string \| null`|`string`|`NSString`|
|`boolean`|`boolean`|`?boolean`|`boolean \| null`|`Boolean`|`NSNumber`|
|Object Literal `{ foo: string, ...}`|`{ foo: string, ...} as const`|`?{ foo: string, ...}`|`?{ foo: string, ...} as const`|-|-|
|Object \[1]|Object \[1]|`?Object`|`Object \| null`|`ReadableMap`|`@` (untyped dictionary)|
|`Array<T>`|`Array<T>`|`?Array<T>`|`Array<T> \| null`|`ReadableArray`|`NSArray` (or `RCTConvertVecToArray` when used inside objects)|
|`Function`|`Function`|`?Function`|`Function \| null`|-|-|
|`Promise<T>`|`Promise<T>`|`?Promise<T>`|`Promise<T> \| null`|`com.facebook.react.bridge.Promise`|`RCTPromiseResolve` and `RCTPromiseRejectBlock`|
|Type Unions `'SUCCESS'\|'FAIL'`|Type Unions `'SUCCESS'\|'FAIL'`|Only as callbacks||-|-|
|Callbacks `() =>`|Callbacks `() =>`|Yes||`com.facebook.react.bridge.Callback`|`RCTResponseSenderBlock`|
|`number`|`number`|No||`double`|`NSNumber`|

#### Notes:

**\[1]** It is strongly recommended to use Object literals instead of Objects.

For additional reference, consider the JavaScript specifications for core modules in React Native located within the `Libraries/` directory of the React Native repository.

## Guide: Extracting and Distributing a React Native Module as a Library

React Native offers an extensive ecosystem of libraries to address common challenges. The [reactnative.directory](https://reactnative.directory) is a valuable resource for developers, providing a collection of these libraries.

If you're working on a module that could be beneficial across multiple apps or the broader community, consider extracting it into a separate library. This guide will walk you through:

- Extracting a module into a library
- Distributing the library using NPM

### Extracting the Module into a Library

To extract a module into its own library, use the `create-react-native-library` tool. It sets up all necessary boilerplate code and configuration files for various platforms.

#### Steps to Create a Library

1. **Create the New Library**

   Start by running:

   ```sh
   npx create-react-native-library@latest <Name of Your Library>
   ```

1. Provide details such as:

   - A valid npm name (all lowercase, using `-` for word separation)
   - A description for your package

1. Follow the interactive menu until you reach the question: *"What type of library do you want to develop?"*

1. Select *Turbo module* for this guide. You can create libraries for both New and Legacy Architectures.

1. Choose whether your library will access platform-specific code (Kotlin & Objective-C) or use a shared C++ library.

1. Opt for the `Test App` option, which sets up a separate app within the library folder.

After completing these steps, you'll have a structured project in Visual Studio Code:

- **Android**: Contains Android-specific code.
- **CPP**: Houses C++ code.
- **iOS**: Includes iOS-specific code.
- **Src**: Holds JavaScript code.

The `package.json` is pre-configured with necessary details and includes a setup for running Codegen:

```json
"codegenConfig": {
  "name": "RN<your module name>Spec",
  "type": "all",
  "jsSrcsDir": "src",
  "outputDir": {
    "ios": "ios/generated",
    "android": "android/generated"
  },
  "android": {
    "javaPackageName": "com.<name-of-the-module>"
  }
}
```

The library is ready to be linked with iOS and Android.

#### Copy the Code from Your App

Assuming you have a local Turbo Native Module in your app, follow these steps:

1. **\[Not required for legacy architecture modules]** Move code from the `specs` folder in your app to the `src` folder of the new library.

1. Update the `index.ts` file to export the Turbo Native Module spec:

   ```typescript
   import NativeSampleModule from "./NativeSampleModule"

   export default NativeSampleModule
   ```

1. Copy native module code:

   - Replace content in `android/src/main/java/com/<name-of-the-module>` with your app's native module code.
   - Update the `ios` folder with your iOS native module code.
   - Modify the `cpp` folder with your C++ native module code.

1. **\[Not required for legacy architecture modules]** Update references from the old spec name to the new one defined in `codegenConfig.name`.

### Testing Your Library

The tool provides an example application configured to work with your library, ideal for testing:

1. Navigate to the `example` folder.
1. Run `yarn install`.
1. For iOS, run `cd ios && pod install`.
1. Build and run Android with `yarn android`.
1. Build and run iOS with `yarn ios`.

### Using Your Library as a Local Module

To reuse your library locally without publishing:

1. Add the library to your app by running `yarn add ../Library` in the `App` folder.

1. For iOS, navigate to `App/ios` and run `bundle exec pod install`.

1. Update `App.tsx` to import from your library:

   ```typescript
   import NativeSampleModule from "../Library/src/index"
   ```

1. Modify `metro.config.js` to include the library's path:

   ```diff
   const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');
   const path = require('path');

   const config = {
     watchFolders: [
       path.resolve(__dirname, '../Library'),
     ],
     resolver: {
       extraNodeModules: {
         'react-native': path.resolve(__dirname, 'node_modules/react-native'),
       },
     },
   };

   module.exports = mergeConfig(getDefaultConfig(__dirname), config);
   ```

1. Build and run your app:
   - Android: `yarn android`
   - iOS: `yarn ios`

### Publishing the Library on NPM

The setup for publishing is ready:

1. Install dependencies with `yarn install`.
1. Build the library using `yarn prepare`.
1. Release it via `yarn release`.

Verify your library's presence on NPM:

```bash
npm view <package.name>
```

Install in your application with:

```bash
yarn add <package.name>
```

**Note**: For iOS, reinstall CocoaPods after adding a new module by running `bundle exec pod install` or `pod install`.

Congratulations! You've published your first React Native library.

## ToastAndroid

The `ToastAndroid` API in React Native provides access to Android's native toast notifications. It offers methods for displaying short or long messages with optional positioning and offset adjustments.

### Methods

#### `show()`

Displays a simple toast message on the screen.

```typescript
static show(message: string, duration: number): void;
```

- **message**: The text content of the toast.
- **duration**: Duration of the toast display. Use either `ToastAndroid.SHORT` or `ToastAndroid.LONG`.

#### `showWithGravity()`

Displays a toast with specified gravity (position). This method is applicable only on Android API 29 and below.

```typescript
static showWithGravity(message: string, duration: number, gravity: number): void;
```

- **message**: The text content of the toast.
- **duration**: Duration of the toast display. Use either `ToastAndroid.SHORT` or `ToastAndroid.LONG`.
- **gravity**: Position on the screen—options are `ToastAndroid.TOP`, `ToastAndroid.BOTTOM`, or `ToastAndroid.CENTER`.

#### `showWithGravityAndOffset()`

Displays a toast with specified gravity and offset. This method is applicable only on Android API 29 and below.

```typescript
static showWithGravityAndOffset(
  message: string,
  duration: number,
  gravity: number,
  xOffset: number,
  yOffset: number
): void;
```

- **message**: The text content of the toast.
- **duration**: Duration of the toast display. Use either `ToastAndroid.SHORT` or `ToastAndroid.LONG`.
- **gravity**: Position on the screen—options are `ToastAndroid.TOP`, `ToastAndroid.BOTTOM`, or `ToastAndroid.CENTER`.
- **xOffset**, **yOffset**: Offsets in pixels for positioning.

> Note: Starting with Android 11 (API level 30), setting gravity has no effect on text toasts. For similar functionality, consider using snackbar or notification.

### Properties

#### `SHORT`

Indicates a short duration for the toast display.

```typescript
static SHORT: number;
```

#### `LONG`

Indicates a long duration for the toast display.

```typescript
static LONG: number;
```

#### `TOP`

Specifies the top position on the screen for the toast.

```typescript
static TOP: number;
```

#### `BOTTOM`

Specifies the bottom position on the screen for the toast.

```typescript
static BOTTOM: number;
```

#### `CENTER`

Specifies the center position on the screen for the toast.

```typescript
static CENTER: number;
```

## React Native Gradle Plugin

This guide provides instructions on configuring the **React Native Gradle Plugin** (RNGP) when building your React Native application for Android.

### Using the Plugin

The React Native Gradle Plugin is distributed as a separate NPM package, automatically installed with `react-native`.

For new projects created using `npx react-native init`, the plugin is pre-configured. No additional steps are required to install it if you used this command.

If integrating React Native into an existing project, refer to specific instructions for installing the plugin.

### Configuring the Plugin

The plugin works with sensible defaults and requires customization only when necessary. Configuration can be done in the `react` block within your `android/app/build.gradle` file:

```groovy
apply plugin: "com.facebook.react"

/**
 * This is the configuration block to customize your React Native Android app.
 * By default, no configuration is needed; uncomment lines as required.
 */
react {
  // Custom configuration goes here.
}
```

#### Configuration Keys

##### `root`

Specifies the root folder of your React Native project (where `package.json` resides). Default: `..`.

```groovy
root = file("../")
```

##### `reactNativeDir`

Defines the directory for the `react-native` package. Default: `../node_modules/react-native`. Adjust if using a monorepo or different package manager.

```groovy
reactNativeDir = file("../node_modules/react-native")
```

##### `codegenDir`

Specifies the folder for the `react-native-codegen` package. Default: `../node_modules/@react-native/codegen`.

```groovy
codegenDir = file("../node_modules/@react-native/codegen")
```

##### `cliFile`

The entry point for the React Native CLI, needed for bundling and app creation. Default: `../node_modules/react-native/cli.js`.

```groovy
cliFile = file("../node_modules/react-native/cli.js")
```

##### `debuggableVariants`

Lists variants considered debuggable (e.g., `debug`, not `release`). Adjust if using other variants like `staging` or `lite`.

```groovy
debuggableVariants = ["liteDebug", "prodDebug"]
```

##### `nodeExecutableAndArgs`

Specifies the node command and arguments for scripts. Default: `[node]`. Customize to add extra flags.

```groovy
nodeExecutableAndArgs = ["node"]
```

##### `bundleCommand`

Name of the `bundle` command for app bundling, useful with RAM Bundles. Default: `bundle`.

```groovy
bundleCommand = "ram-bundle"
```

##### `bundleConfig`

Path to a configuration file passed to `bundle --config <file>`. Default is empty.

```groovy
bundleConfig = file("../rn-cli.config.js")
```

##### `bundleAssetName`

Name of the generated bundle file. Default: `index.android.bundle`.

```groovy
bundleAssetName = "MyApplication.android.bundle"
```

##### `entryFile`

Entry file for bundle generation, defaulting to `index.android.js` or `index.js`.

```groovy
entryFile = file("../js/MyApplication.android.js")
```

##### `extraPackagerArgs`

Extra flags passed to the `bundle` command. Default is empty.

```groovy
extraPackagerArgs = []
```

##### `hermesCommand`

Path to the `hermesc` command (Hermes Compiler). React Native includes a bundled version, so customization is usually unnecessary.

##### `hermesFlags`

Flags for `hermesc`. Default: `["-O", "-output-source-map"]`.

```groovy
hermesFlags = ["-O", "-output-source-map"]
```

##### `enableBundleCompression`

Determines if the Bundle Asset should be compressed in `.apk` packaging. Disabled by default to improve startup time at the cost of larger app size on disk.

### Using Flavors & Build Variants

Custom flavors allow different versions of your app from a single project. Refer to the official Android guide for configuring custom build types (e.g., `staging`) or flavors (e.g., `full`, `lite`). New apps default to two build types (`debug` and `release`) with no custom flavors.

Build variants are combinations of all build types and flavors. For example, with `debug`/`staging`/`release` build types and `full`/`lite` flavors, you get 6 variants: `fullDebug`, `fullStaging`, `fullRelease`, etc.

For custom variants beyond `debug` and `release`, specify which are **debuggable** using the `debuggableVariants` configuration:

```diff
apply plugin: "com.facebook.react"

react {
+ debuggableVariants = ["fullStaging", "fullDebug"]
}
```

This is necessary because the plugin skips JS bundling for all `debuggableVariants`, requiring Metro to run them. Listing `fullStaging` in `debuggableVariants` means it won't have a bundle, preventing store publication.

### Plugin Responsibilities

The React Native Gradle Plugin configures your Application build for production and is used by 3rd party libraries for Codegen with the New Architecture. Key responsibilities include:

- Adding a `createBundle<Variant>JsAndAssets` task for non-debuggable variants to invoke `bundle`, `hermesc`, and `compose-source-map`.
- Setting up dependencies like `com.facebook.react:react-android` and `com.facebook.react:hermes-android` based on React Native version.
- Configuring Maven repositories (Maven Central, Google Maven Repo, JSC local Maven repo) for necessary dependencies.
- Setting up the NDK for apps using the New Architecture.
- Defining `buildConfigFields` to determine runtime if Hermes or the New Architecture are enabled.
- Configuring the Metro DevServer Port as an Android resource.
- Invoking React Native Codegen for libraries/apps using it with the New Architecture.

## Linking Libraries

Not every application utilizes all native capabilities, and including code for all features would increase binary size. However, we aim to support adding these features when needed.

To address this, many features are exposed as independent static libraries.

For most libraries, linking is quick—typically involving dragging two files, with a third step sometimes necessary.

**Note:** All React Native libraries reside in the `Libraries` folder at the repository's root. Some are pure JavaScript and require only a `require`. Libraries relying on native code need these files added to your app; otherwise, an error occurs when using the library.

### Steps to Link Libraries with Native Code

#### Automatic Linking

1. Install a library with native dependencies:

   ```shell
   npm install <library-with-native-dependencies> --save
   ```

1. **Important:** Use the `--save` or `--save-dev` flag. React Native links libraries based on `dependencies` and `devDependencies` in your `package.json`.

That's it! The next build will link native code via autolinking.

#### Manual Linking

##### Step 1

If the library includes native code, an `.xcodeproj` file should be present. Drag this file into your Xcode project (typically under the `Libraries` group).

##### Step 2

Select your main project file (representing the `.xcodeproj`) and choose `Build Phases`. Drag the static library from the `Products` folder of the imported Library to `Link Binary With Libraries`.

##### Step 3

Not all libraries require this step. Consider:

*Do I need to know the contents of the library at compile time?*

This means, are you using the library on the native side or only in JavaScript? If it's just JavaScript, no further action is needed.

If native usage is required, include the library's headers by going to your project file, selecting `Build Settings`, and searching for `Header Search Paths`. Add the path to your library. (Previously recommended using `recursive` is now discouraged due to potential build failures, especially with CocoaPods.)

## Running On Simulator

### Starting the Simulator

After initializing your React Native project, you can start it using either npm or Yarn within the project directory.

#### Commands:

- **npm**

  ```shell
  npm run ios
  ```

- **Yarn**

  ```shell
  yarn ios
  ```

If everything is configured correctly, your app should appear in the iOS Simulator shortly after running these commands.

### Specifying a Device

To specify which device to use with the simulator, utilize the `--simulator` flag followed by the desired device name as a string. By default, it uses `"iPhone 14"`. For example, to run your app on an iPhone SE (3rd generation), execute:

- **npm**

  ```shell
  npm run ios -- --simulator="iPhone SE (3rd generation)"
  ```

- **Yarn**

  ```shell
  yarn ios --simulator "iPhone SE (3rd generation)"
  ```

The device names should match those available in Xcode. You can verify the list of devices by running `xcrun simctl list devices` from your console.

#### Specifying a Device Version

If multiple iOS versions are installed, specify the version as well. For instance, to run on an iPhone 14 Pro with iOS 16.0, use:

- **npm**

  ```shell
  npm run ios -- --simulator="iPhone 14 Pro (16.0)"
  ```

- **Yarn**

  ```shell
  yarn ios --simulator "iPhone 14 Pro (16.0)"
  ```

### Specifying a UDID

You can also specify the device using its UDID, which you can find by running `xcrun simctl list devices`. For example, to run your app with a specific UDID:

- **npm**

  ```shell
  npm run ios -- --udid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"
  ```

- **Yarn**

  ```shell
  yarn ios --udid "AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"
  ```

## FlatList

A performant interface for rendering basic, flat lists with a variety of features:

- Fully cross-platform.
- Optional horizontal mode.
- Configurable viewability callbacks.
- Header and footer support.
- Separator support.
- Pull-to-refresh functionality.
- Scroll loading.
- `ScrollToIndex` support.
- Multiple column support.

For sectioned lists, use `<SectionList>` instead.

### Example

#### TypeScript & JavaScript

To render multiple columns, utilize the `numColumns` prop. This method avoids conflicts with item height logic that might arise from using a `flexWrap` layout.

A more complex example includes:

- Passing `extraData={selectedId}` to `FlatList` ensures it re-renders when state changes. Without this prop, `FlatList`, being a `PureComponent`, wouldn't recognize the need for re-rendering due to unchanged props.
- The `keyExtractor` prop allows using item `id`s as React keys instead of default `key` properties.

This component is a convenience wrapper around `<VirtualizedList>`, inheriting its and `<ScrollView>`'s unlisted props, with specific considerations:

- Internal state isn't preserved when content scrolls out of view. Ensure all data is captured in the item data or external stores like Flux, Redux, or Relay.
- As a `PureComponent`, it won't re-render if `props` remain shallow-equal. Pass everything your `renderItem` function depends on as props (e.g., `extraData`) that aren't strictly equal after updates to ensure UI updates on changes. This includes the `data` prop and parent component state.
- Content is rendered asynchronously offscreen for memory constraints and smooth scrolling, which might lead to blank content during fast scrolls. This tradeoff can be adjusted per application needs.
- By default, it looks for a `key` prop on each item for React keys or uses a custom `keyExtractor`.

### Reference

#### Props

##### VirtualizedList Props

Inherits from VirtualizedList Props.

##### Required: `renderItem`

```typescript
renderItem({
  item: ItemT,
  index: number,
  separators: {
    highlight: () => void;
    unhighlight: () => void;
    updateProps: (select: 'leading' | 'trailing', newProps: any) => void;
  }
}): JSX.Element;
```

- **item**: The item to be rendered.
- **index**: Index of the item in the list.
- **separators**: Object containing methods for separator interactions.

##### Required: `data`

An array of items to render. Each item should have a unique key or use the `keyExtractor` prop.

#### Methods

##### `flashScrollIndicators()`

Displays scroll indicators momentarily.

```typescript
flashScrollIndicators(): void;
```

##### `getNativeScrollRef()`

Provides a reference to the underlying scroll component.

```typescript
getNativeScrollRef(): React.ElementRef<typeof ScrollViewComponent>;
```

##### `getScrollResponder()`

Provides access to the underlying scroll responder.

```typescript
getScrollResponder(): ScrollResponderMixin;
```

##### `getScrollableNode()`

Provides access to the underlying scroll node.

```typescript
getScrollableNode(): any;
```

##### `scrollToEnd(params?: { animated?: boolean })`

Scrolls to the end of the content. May be less smooth without `getItemLayout`.

**Parameters:**

- **params**: Optional object with:
  - `animated`: Whether to animate the scroll (default is `true`).

##### `scrollToIndex(params: { index: number; animated?: boolean; viewOffset?: number; viewPosition?: number })`

Scrolls to a specific item index, positioning it based on `viewPosition`.

**Parameters:**

- **params**: Required object with:
  - `index`: Index of the item.
  - `animated`: Whether to animate (default is `true`).
  - `viewOffset`: Pixels to offset the final position.
  - `viewPosition`: Position in view (`0` for top, `1` for bottom, `0.5` for center).

##### `scrollToItem(params: { animated?: boolean; item: Item; viewPosition?: number })`

Scrolls to a specific item. Requires linear scan through data.

**Parameters:**

- **params**: Required object with:
  - `item`: The item to scroll to.
  - `animated`: Whether to animate (default is `true`).
  - `viewPosition`: Position in view (`0` for top, `1` for bottom, `0.5` for center).

##### `scrollToOffset(params: { offset: number; animated?: boolean })`

Scrolls to a specific content pixel offset.

**Parameters:**

- **params**: Required object with:
  - `offset`: The offset to scroll to.
  - `animated`: Whether to animate (default is `true`).

## LayoutAnimation

Automatically animates views to their new positions when the next layout occurs. This API is typically used by calling it before updating state in functional components or using `setState` in class components.

To enable this functionality on **Android**, you must set specific flags via `UIManager`:

```typescript
if (Platform.OS === "android") {
  if (UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true)
  }
}
```

### Example

### Reference

### Methods

#### `configureNext()`

```typescript
static configureNext(
  config: LayoutAnimationConfig,
  onAnimationDidEnd?: () => void,
  onAnimationDidFail?: () => void,
): void;
```

Schedules an animation for the next layout.

##### Parameters:

|Name|Type|Required|Description|
|-|-|-|-|
|config|object|Yes|Configuration details (see below).|
|onAnimationDidEnd|function|No|Callback when the animation finishes.|
|onAnimationDidFail|function|No|Callback if the animation fails.|

The `config` parameter is an object with the following keys:

- `duration`: Duration in milliseconds.
- `create`: Optional configuration for animating new views.
- `update`: Optional configuration for animating updated views.
- `delete`: Optional configuration for animating removed views.

Each of these configurations (`create`, `update`, `delete`) includes:

- `type`: The animation type to use.
- `property`: The layout property to animate (optional, recommended for `create` and `delete`).
- `springDamping`: A number used only with `type: Type.spring`.
- `initialVelocity`: An optional number.
- `delay`: An optional number.
- `duration`: An optional number.

#### `create()`

```typescript
static create(duration: number, type: string, creationProp?: string): LayoutAnimationConfig;
```

Helper function to generate an object with `create`, `update`, and `delete` fields for use in `configureNext`. The `type` parameter specifies the animation type, while `creationProp` is a layout property.

**Example:**

### Properties

#### Types

An enumeration of animation types used in the `create` method or within the `create`/`update`/`delete` configurations for `configureNext`.

|Type|
|-|
|spring|
|linear|
|easeInEaseOut|
|easeIn|
|easeOut|
|keyboard|

#### Properties

An enumeration of layout properties that can be animated, used in the `create` method or within the `create`/`update`/`delete` configurations for `configureNext`.

|Property|
|-|
|opacity|
|scaleX|
|scaleY|
|scaleXY|

#### Presets

Predefined animation configurations to use with `configureNext`.

|Preset|Value|
|-|-|
|easeInEaseOut|`{ create: { type: 'easeInEaseOut', property: 'opacity' } }`|
|linear|`{ create: { type: 'linear', property: 'opacity' } }`|
|spring|`{ duration: 700, create: { type: 'linear', property: 'opacity' }, update: { type: 'spring', springDamping: 0.4 }, delete: { type: 'linear', property: 'opacity' } }`|

#### `easeInEaseOut`

Invokes `configureNext()` with the `Presets.easeInEaseOut`.

#### `linear`

Invokes `configureNext()` with the `Presets.linear`.

#### `spring`

Invokes `configureNext()` with the `Presets.spring`.

**Example:**

## Appearance

The `Appearance` module provides information about the user's appearance preferences, such as their preferred color scheme (light or dark).

### Developer Notes

- **Android**: On Android 10 (API level 29) and higher, the color scheme preference corresponds to the user's Light or Dark theme setting.

- **iOS**: On iOS 13 and above, it maps to the user's Light or Dark Mode preference. Note that screenshots may flicker between light and dark modes due to asynchronous updates.

### Example Usage

To determine if a user prefers a dark color scheme:

```typescript
import { Appearance } from "react-native"

const colorScheme = Appearance.getColorScheme()
if (colorScheme === "dark") {
  // Implement logic for dark color scheme
}
```

Since the color scheme can change (e.g., due to scheduled changes at sunrise or sunset), it's recommended to call this function on every render. You might use the `useColorScheme` React hook, which subscribes to updates, or inline styles instead of a static `StyleSheet`.

### Reference

#### Methods

##### `getColorScheme()`

```typescript
static getColorScheme(): 'light' | 'dark' | null;
```

Returns the current user's preferred color scheme. This value can change due to direct user actions (e.g., theme selection) or scheduled changes.

Supported values:

- `'light'`: User prefers a light theme.
- `'dark'`: User prefers a dark theme.
- `null`: No preference indicated.

*Note*: When debugging with Chrome, this method always returns `'light'`.

##### `setColorScheme()`

```typescript
static setColorScheme('light' | 'dark' | null): void;
```

Forces the application to use a specified interface style. The default is `null`, which follows the system's style.

Supported values:

- `'light'`: Apply light user interface.
- `'dark'`: Apply dark user interface.
- `null`: Follow the system's interface style.

*Note*: This change does not affect other applications or the system's overall settings.

##### `addChangeListener()`

```typescript
static addChangeListener(
  listener: (preferences: { colorScheme: 'light' | 'dark' | null }) => void,
): NativeEventSubscription;
```

Adds an event handler that triggers when appearance preferences change.

## AppRegistry

### Project with Native Code Required

In the managed Expo workflow, there's only one entry component registered with `AppRegistry`, handled automatically or through `registerRootComponent`. This API isn't necessary in this context.

`AppRegistry` serves as the JavaScript entry point for all React Native applications. Root components should register themselves using `AppRegistry.registerComponent`. The native system then loads the app bundle and runs it by invoking `AppRegistry.runApplication`.

```typescript
import { Text, View } from 'react-native';

const App = () => (
  <View>
    <Text>App1</Text>
  </View>
);

AppRegistry.registerComponent('AppName', () => App);
```

To stop an application when a view is destroyed, use `AppRegistry.unmountApplicationComponentAtRootTag` with the tag passed to `runApplication`. These should always be used as pairs.

Ensure `AppRegistry` is required early in the sequence to set up the JavaScript execution environment before other modules are loaded.

### Reference

#### Methods

##### `getAppKeys()`

```typescript
static getAppKeys(): string[];
```

Returns an array of strings.

##### `getRegistry()`

```typescript
static getRegistry(): { sections: string[]; runnables: Runnable[] };
```

Returns a Registry object.

##### `getRunnable()`

```typescript
static getRunnable(appKey: string): Runnable | undefined;
```

**Parameters:**

- **appKey**: Required, type: `string`.

Returns a Runnable object.

##### `getSectionKeys()`

```typescript
static getSectionKeys(): string[];
```

Returns an array of strings.

##### `getSections()`

```typescript
static getSections(): Record<string, Runnable>;
```

Returns a Runnables object.

##### `registerCancellableHeadlessTask()`

```typescript
static registerCancellableHeadlessTask(
  taskKey: string,
  taskProvider: TaskProvider,
  taskCancelProvider: TaskCancelProvider
);
```

Registers a headless task that can be cancelled. A headless task runs without a UI.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**taskKey**|`string`|Required, the native ID for this task instance used when startHeadlessTask was called.|
|**taskProvider**|`TaskProvider`|Required, a promise-returning function that takes data from the native side as an argument. When resolved or rejected, the native side is notified and may destroy the JS context.|
|**taskCancelProvider**|`TaskCancelProvider`|Required, a void-returning function with no arguments; when cancellation is requested, the taskProvider should wrap up and return ASAP.|

##### `registerComponent()`

```typescript
static registerComponent(
  appKey: string,
  getComponentFunc: ComponentProvider,
  section?: boolean
): string;
```

**Parameters:**

|Name|Type||
|-|-|-|
|**appKey**|`string`||
|**getComponentFunc**|`ComponentProvider`|Required|
|**section**|`boolean`||

##### `registerConfig()`

```typescript
static registerConfig(config: AppConfig[]);
```

**Parameters:**

- **config**: Required, type: `AppConfig[]`.

##### `registerHeadlessTask()`

```typescript
static registerHeadlessTask(
  taskKey: string,
  taskProvider: TaskProvider
);
```

Registers a headless task. A headless task runs without a UI and can be used for background tasks like syncing data, handling notifications, or playing music.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**taskKey**|`string`|Required, the native ID for this task instance used when startHeadlessTask was called.|
|**taskProvider**|`TaskProvider`|Required, a promise-returning function that takes data from the native side as an argument. When resolved or rejected, the native side is notified and may destroy the JS context.|

##### `registerRunnable()`

```typescript
static registerRunnable(appKey: string, func: Runnable): string;
```

**Parameters:**

|Name|Type|
|-|-|
|**appKey**|`string`|
|**func**|`function`|

##### `registerSection()`

```typescript
static registerSection(
  appKey: string,
  component: ComponentProvider
);
```

**Parameters:**

|Name|Type||
|-|-|-|
|**appKey**|`string`||
|**component**|`ComponentProvider`|Required|

##### `runApplication()`

```typescript
static runApplication(appKey: string, appParameters: any): void;
```

Loads the JavaScript bundle and runs the app.

**Parameters:**

|Name|Type|
|-|-|
|**appKey**|`string`|
|**appParameters**|`any`|

##### `setComponentProviderInstrumentationHook()`

```typescript
static setComponentProviderInstrumentationHook(
  hook: ComponentProviderInstrumentationHook
);
```

**Parameters:**

- **hook**: Required, type: `function`.

A valid `hook` function accepts the following as arguments:

|Name|Type||
|-|-|-|
|**component**|`ComponentProvider`|Required|
|**scopedPerformanceLogger**|`IPerformanceLogger`|Required|

The function must return a React Component.

##### `setWrapperComponentProvider()`

```typescript
static setWrapperComponentProvider(
  provider: WrapperComponentProvider
);
```

**Parameters:**

- **provider**: Required, type: `ComponentProvider`.

##### `startHeadlessTask()`

```typescript
static startHeadlessTask(
  taskId: number,
  taskKey: string,
  data: any
);
```

Only called from native code. Starts a headless task.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|**taskId**|`number`|Required, the native ID for this task instance to track its execution.|
|**taskKey**|`string`|Required, the key for the task to start.|
|**data**|`any`|Required, the data to pass to the task.|

##### `unmountApplicationComponentAtRootTag()`

```typescript
static unmountApplicationComponentAtRootTag(rootTag: number);
```

Stops an application when a view should be destroyed.

**Parameters:**

- **rootTag**: Required, type: `number`.

### Type Definitions

#### AppConfig

Application configuration for the `registerConfig` method.

- Type: `object`

**Properties:**

|Name|Type||
|-|-|-|
|**appKey**|`string`|Required|
|component|`ComponentProvider`||
|run|`function`||
|section|`boolean`||

> **Note:** Every config must set either the `component` or `run` function.

#### Registry

- Type: `object`

**Properties:**

|Name|Type|
|-|-|
|runnables|Array of Runnables|
|sections|Array of strings|

#### Runnable

- Type: `object`

**Properties:**

|Name|Type|
|-|-|
|component|`ComponentProvider`|
|run|`function`|

#### Runnables

An object with a key of `appKey` and value of type `Runnable`.

- Type: `object`

#### Task

A `Task` is a function that accepts any data as an argument and returns a Promise resolving to `undefined`.

- Type: `function`

#### TaskCanceller

A `TaskCanceller` is a function that accepts no arguments and returns void.

- Type: `function`

#### TaskCancelProvider

A valid `TaskCancelProvider` is a function returning a `TaskCanceller`.

- Type: `function`

#### TaskProvider

A valid `TaskProvider` is a function returning a `Task`.

- Type: `function`

## React Native and Frameworks

React Native enables developers familiar with React to build native applications. It also allows native developers to achieve parity across platforms by writing shared features once.

The optimal way to experience React Native is through a **Framework**, which provides all necessary APIs for building production-ready apps.

While it's possible to use React Native without a Framework, many developers find that using one like Expo offers significant benefits. Expo includes features such as file-based routing, high-quality universal libraries, and the ability to write plugins that modify native code without managing native files directly.

### Start a New Project with Expo

#### Platform Support

- Android
- iOS
- TV
- Web

Expo is a production-grade React Native Framework offering developer tooling to simplify app development. This includes file-based routing, a standard library of native modules, and more.

The Expo Framework is free, open-source, and supported by an active community on GitHub and Discord. The Expo team collaborates closely with the React Native team at Meta to integrate the latest features into the Expo SDK.

Additionally, Expo provides Expo Application Services (EAS), which are optional services that enhance the development process alongside the Expo Framework.

#### Creating a New Expo Project

To start a new project using Expo, execute the following command in your terminal:

```shell
npx create-expo-app@latest
```

After creating your app, refer to Expo’s getting started guide for further development steps.

## PixelRatio

`PixelRatio` provides access to the device's pixel density and font scale.

### Fetching a Correctly Sized Image

To ensure optimal image quality on high pixel density devices, it is advisable to adjust the image size by multiplying it with the pixel ratio. Here’s how you can achieve this:

```typescript
const image = getImage({
  width: PixelRatio.getPixelSizeForLayoutSize(200),
  height: PixelRatio.getPixelSizeForLayoutSize(100),
});
<Image source={image} style={{width: 200, height: 100}} />;
```

### Pixel Grid Snapping

On iOS devices, you can specify element positions and dimensions with high precision. However, due to the fixed number of pixels on displays (e.g., 640×1136 for iPhone SE or 828×1792 for iPhone 11), iOS attempts to maintain user-defined values by spreading a single pixel across multiple ones, which may result in blurriness.

Developers often prefer manual rounding to avoid this blurriness. React Native handles automatic rounding of pixels to prevent such issues. It's crucial to ensure that rounded and unrounded values are not mixed to prevent cumulative rounding errors, as even minor discrepancies can significantly affect element borders.

In React Native, calculations in JavaScript and the layout engine use arbitrary precision numbers. Rounding occurs only when setting native element positions and dimensions on the main thread, relative to the root rather than the parent, to minimize rounding errors.

### Reference

#### Methods

##### `get()`

```typescript
static get(): number;
```

Returns the device pixel density with examples:

- `PixelRatio.get() === 1`: mdpi Android devices
- `PixelRatio.get() === 1.5`: hdpi Android devices
- `PixelRatio.get() === 2`: iPhone SE, 6S, 7, 8; iPhone XR; iPhone 11; xhdpi Android devices
- `PixelRatio.get() === 3`: iPhone 6S Plus, 7 Plus, 8 Plus; iPhone X, XS, XS Max; iPhone 11 Pro, 11 Pro Max; Pixel, Pixel 2; xxhdpi Android devices
- `PixelRatio.get() === 3.5`: Nexus 6; Pixel XL, Pixel 2 XL; xxxhdpi Android devices

##### `getFontScale()`

```typescript
static getFontScale(): number;
```

Returns the scaling factor for font sizes based on user preferences:

- On Android: Reflects settings in **Settings > Display > Font size**
- On iOS: Reflects settings in **Settings > Display & Brightness > Text Size** or **Settings > Accessibility > Display & Text Size > Larger Text**

If no font scale is set, it returns the device pixel ratio.

##### `getPixelSizeForLayoutSize()`

```typescript
static getPixelSizeForLayoutSize(layoutSize: number): number;
```

Converts a layout size (dp) to pixel size (px), ensuring an integer return value.

##### `roundToNearestPixel()`

```typescript
static roundToNearestPixel(layoutSize: number): number;
```

Rounds a layout size (dp) to the nearest size that corresponds to an integer number of pixels. For instance, on a device with a PixelRatio of 3, `PixelRatio.roundToNearestPixel(8.4)` results in 8.33, which equals exactly 25 pixels when multiplied by 3.

## SectionList

A performant interface for rendering sectioned lists with features such as:

- Cross-platform compatibility.
- Configurable viewability callbacks.
- Support for list headers and footers.
- Item and section separator support.
- Heterogeneous data and item rendering.
- Pull to Refresh functionality.
- Scroll loading.

For simpler interfaces without section support, consider using `<FlatList>`.

### Example

`<SectionList>` is a convenience wrapper around `<VirtualizedList>`, inheriting its props (and those of `<ScrollView>`) that aren't explicitly listed here. Note the following:

- Internal state isn't preserved when content scrolls out of view. Ensure all data is captured in item data or external stores like Flux, Redux, or Relay.
- As a `PureComponent`, it won't re-render if `props` remain shallow-equal. Pass everything your `renderItem` function depends on as props (e.g., `extraData`) that change after updates to ensure UI updates correctly.
- Content is rendered asynchronously offscreen for memory constraints and smooth scrolling, which may result in blank content during fast scrolls. This tradeoff can be adjusted per application needs.
- By default, the list uses a `key` prop on each item as the React key or allows a custom `keyExtractor`.

### Reference

#### Props

##### VirtualizedList Props

Inherits props from `VirtualizedList`.

##### Required: `renderItem`

Default renderer for every item in every section. Can be overridden per-section. Should return a React element.

|Type|
|-|
|function|

The render function receives an object with:

- 'item' (object) - the item as specified in this section's `data` key.
- 'index' (number) - Item's index within the section.
- 'section' (object) - The full section object as specified in `sections`.
- 'separators' (object) with:
  - 'highlight' (function) - `() => void`
  - 'unhighlight' (function) - `() => void`
  - 'updateProps' (function) - `(select, newProps) => void` where:
    - 'select' (enum) - possible values are 'leading', 'trailing'
    - 'newProps' (object)

##### Required: `sections`

The data to render, similar to the `data` prop in `FlatList`.

|Type|
|-|
|array of Sections|

##### `extraData`

A marker property for re-rendering since it implements `PureComponent`. Use this if your `renderItem`, Header, Footer, etc., depend on anything outside the `data` prop. Treat it immutably.

|Type|
|-|
|any|

##### `initialNumToRender`

Number of items to render initially. Should fill the screen but not much more. These items won't be unmounted for improved scroll-to-top performance.

|Type|Default|
|-|-|
|number|`10`|

##### `inverted`

Reverses the direction of scroll using scale transforms of -1.

|Type|Default|
|-|-|
|boolean|`false`|

##### `ItemSeparatorComponent`

Rendered between each item, excluding top and bottom. By default, provides `highlighted`, `section`, and `[leading/trailing][Item/Section]` props. `renderItem` offers `separators.highlight`/`unhighlight` to update the `highlighted` prop, with custom props via `separators.updateProps`. Can be a React Component or element.

|Type|
|-|
|component, function, element|

##### `keyExtractor`

Extracts a unique key for an item at a specified index. Used for caching and tracking item re-ordering. Defaults to checking `item.key`, then `item.id`, and falls back to the index.

|Type|
|-|
|(item: object, index: number) => string|

##### `ListEmptyComponent`

Rendered when the list is empty. Can be a React Component or element.

|Type|
|-|
|component, element|

##### `ListFooterComponent`

Rendered at the end of the list. Can be a React Component or element.

|Type|
|-|
|component, element|

##### `ListHeaderComponent`

Rendered at the beginning of the list. Can be a React Component or element.

|Type|
|-|
|component, element|

##### `onRefresh`

Adds "Pull to Refresh" functionality if provided. Ensure the `refreshing` prop is set correctly. Use `progressViewOffset={100}` to offset from the top.

|Type|
|-|
|function|

##### `onViewableItemsChanged`

Called when viewability of rows changes, as defined by the `viewabilityConfig` prop.

|Type|
|-|
|`(callback: {changed: ViewToken[], viewableItems: ViewToken[]}) => void`|

##### `refreshing`

Set to true while waiting for new data from a refresh.

|Type|Default|
|-|-|
|boolean|`false`|

##### `removeClippedSubviews`

> Note: May have bugs (missing content) in some circumstances - use at your own risk. This may improve scroll performance for large lists.

|Type|Default|
|-|-|
|boolean|`false`|

##### `renderSectionFooter`

Rendered at the bottom of each section.

|Type|
|-|
|`(info: {section: Section}) => element ｜ null`|

##### `renderSectionHeader`

Rendered at the top of each section. Sticks to the top by default on iOS unless `stickySectionHeadersEnabled` is set otherwise.

|Type|
|-|
|`(info: {section: Section}) => element ｜ null`|

##### `SectionSeparatorComponent`

Rendered at the top and bottom of each section, different from `ItemSeparatorComponent`. Receives `highlighted`, `[leading/trailing][Item/Section]`, and custom props via `separators.updateProps`.

|Type|
|-|
|component, element|

##### `stickySectionHeadersEnabled`

Makes section headers stick to the top of the screen until pushed off by the next one. Enabled by default on iOS.

|Type|Default|
|-|-|
|boolean|`false`Android\*\*\*`true`iOS|

### Methods

#### `flashScrollIndicators()` (iOS)

```typescript
flashScrollIndicators()
```

Displays scroll indicators momentarily.

#### `recordInteraction()`

```typescript
recordInteraction()
```

Informs the list of an interaction, triggering viewability calculations if `waitForInteractions` is true and the user hasn't scrolled. Typically called by taps on items or navigation actions.

#### `scrollToLocation()`

```typescript
scrollToLocation(params: SectionListScrollParams);
```

Scrolls to the item at the specified `sectionIndex` and `itemIndex`, positioning it in the viewable area based on `viewPosition`. Note: Cannot scroll outside the render window without `getItemLayout` or `onScrollToIndexFailed`.

**Parameters:**

|Name|Type|
|-|-|
|paramsRequired|object|

Valid `params` keys:

- 'animated' (boolean) - Whether to animate while scrolling. Defaults to `true`.
- 'itemIndex' (number) - Index within section for the item to scroll to. Required.
- 'sectionIndex' (number) - Section index containing the item to scroll to. Required.
- 'viewOffset' (number) - Fixed pixel offset for final target position, e.g., for sticky headers.
- 'viewPosition' (number) - `0` places the item at the top, `1` at the bottom, and `0.5` centered.

### Type Definitions

#### Section

An object identifying data to be rendered for a given section.

|Type|
|-|
|any|

**Properties:**

|Name|Type|Description|
|-|-|-|
|dataRequired|array|Data for rendering items in this section. Array of objects, similar to `FlatList`'s data prop.|
|key|string|Optional key for tracking section re-ordering. Defaults to array index if not specified.|
|renderItem|function|Optionally define an arbitrary item renderer for this section, overriding the default `renderItem`.|
|ItemSeparatorComponent|component, element|Optionally define an arbitrary item separator for this section, overriding the default `ItemSeparatorComponent`.|
|keyExtractor|function|Optionally define a custom key extractor for this section, overriding the default `keyExtractor`.|

## AccessibilityInfo

The `AccessibilityInfo` API is designed to determine if a screen reader or other accessibility services are active on a device. It allows querying the current state of these services and registering for notifications when their states change.

### Example

*Example content omitted.*

### Reference

#### Methods

##### `addEventListener()`

```typescript
static addEventListener(
  eventName: AccessibilityChangeEventName | AccessibilityAnnouncementEventName,
  handler: (
    event: AccessibilityChangeEvent | AccessibilityAnnouncementFinishedEvent,
  ) => void,
): EmitterSubscription;
```

Adds an event handler for various accessibility-related events. Supported events include:

|Event Name|Description|
|-|-|
|`accessibilityServiceChanged` (Android)|Fires when any accessibility services, such as TalkBack or third-party apps, are enabled. The argument is a boolean: `true` if enabled, otherwise `false`.|
|`announcementFinished` (iOS)|Fires after the screen reader finishes an announcement. Argument includes: - `announcement`: The announced string.<br>- `success`: Boolean indicating success of the announcement.|
|`boldTextChanged` (iOS)|Fires when bold text toggle state changes. Argument is a boolean: `true` if enabled, otherwise `false`.|
|`grayscaleChanged` (iOS)|Fires when grayscale toggle state changes. Argument is a boolean: `true` if enabled, otherwise `false`.|
|`invertColorsChanged` (iOS)|Fires when invert colors toggle state changes. Argument is a boolean: `true` if enabled, otherwise `false`.|
|`reduceMotionChanged`|Fires when reduce motion toggle state changes. Argument is a boolean: `true` if enabled or "Animation off" in Developer options, otherwise `false`.|
|`reduceTransparencyChanged` (iOS)|Fires when reduce transparency toggle state changes. Argument is a boolean: `true` if enabled, otherwise `false`.|
|`screenReaderChanged`|Fires when the screen reader's state changes. Argument is a boolean: `true` if enabled, otherwise `false`.|

##### `announceForAccessibility()`

```typescript
static announceForAccessibility(announcement: string);
```

Posts a string to be announced by the screen reader.

##### `announceForAccessibilityWithOptions()`

```typescript
static announceForAccessibilityWithOptions(
  announcement: string,
  options: { queue?: boolean },
);
```

Posts a string for the screen reader with modification options. By default, announcements interrupt existing speech; on iOS, they can be queued by setting `queue` to `true`.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|announcement|string|The string to be announced.|
|options|object|Contains `queue`: If set to `true`, queues the announcement behind existing speech on iOS.|

##### `getRecommendedTimeoutMillis()` (Android)

```typescript
static getRecommendedTimeoutMillis(originalTimeout: number): Promise<number>;
```

Returns the recommended timeout in milliseconds based on "Accessibility timeout" settings.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|originalTimeout|number|The fallback timeout in milliseconds if no accessibility timeout is set.|

##### `isAccessibilityServiceEnabled()` (Android)

```typescript
static isAccessibilityServiceEnabled(): Promise<boolean>;
```

Checks if any accessibility service, including TalkBack or third-party apps, is enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

> **Note**: Use `isScreenReaderEnabled` for checking only the status of TalkBack.

##### `isBoldTextEnabled()` (iOS)

```typescript
static isBoldTextEnabled(): Promise<boolean>;
```

Checks if bold text is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `isGrayscaleEnabled()` (iOS)

```typescript
static isGrayscaleEnabled(): Promise<boolean>;
```

Checks if grayscale mode is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `isInvertColorsEnabled()` (iOS)

```typescript
static isInvertColorsEnabled(): Promise<boolean>;
```

Checks if invert colors mode is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `isReduceMotionEnabled()`

```typescript
static isReduceMotionEnabled(): Promise<boolean>;
```

Checks if reduce motion is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `isReduceTransparencyEnabled()` (iOS)

```typescript
static isReduceTransparencyEnabled(): Promise<boolean>;
```

Checks if reduce transparency mode is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `isScreenReaderEnabled()`

```typescript
static isScreenReaderEnabled(): Promise<boolean>;
```

Checks if a screen reader is currently enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `prefersCrossFadeTransitions()` (iOS)

```typescript
static prefersCrossFadeTransitions(): Promise<boolean>;
```

Checks if reduce motion and prefer cross-fade transitions settings are enabled. Returns a promise resolving to a boolean: `true` if enabled, otherwise `false`.

##### `setAccessibilityFocus()`

```typescript
static setAccessibilityFocus(reactTag: number);
```

Sets accessibility focus on a React component by calling `UIManager.sendAccessibilityEvent` with the specified `reactTag` and `UIManager.AccessibilityEventTypes.typeViewFocused`.

> **Note**: Ensure any `View` intended to receive accessibility focus has `accessible={true}`.

## AppState

The `AppState` module provides information about whether an application is in the foreground or background and notifies you of any state changes. It's particularly useful for determining how to handle push notifications based on the app's current state.

### App States

- **active**: The app is running in the foreground.
- **background**: The app is running in the background, with the user either:
  - In another application
  - On the home screen
  - \[Android] Engaged in a different `Activity`, even if initiated by your app
- \[iOS] **inactive**: This state occurs during transitions between foreground and background or when the device is inactive, such as entering multitasking view, opening Notification Center, or receiving an incoming call.

For more details, refer to Apple's documentation.

### Basic Usage

To check the current state of the app, use `AppState.currentState`, which remains updated. Note that `currentState` will be null at launch while `AppState` retrieves it over the bridge. This example typically displays "Current state is: active" because the app is visible only in the `active` state, and the null state occurs briefly. For experimentation, using your own device instead of an embedded preview is recommended.

### Reference

#### Events

- **change**: Triggered when the app state changes. The listener receives one of the current app state values.

- **memoryWarning**: Used to handle memory warnings or release resources as needed.

- **focus** \[Android]: Fired when the app gains focus, indicating user interaction with the app.

- **blur** \[Android]: Triggered when the user is not actively interacting with the app. Useful for detecting actions like pulling down the notification drawer. The `AppState` state remains unchanged, but the `blur` event is fired.

#### Methods

##### `addEventListener()`

```typescript
static addEventListener(
  type: AppStateEvent,
  listener: (state: AppStateStatus) => void,
): NativeEventSubscription;
```

Sets up a function to be called whenever the specified event type on `AppState` occurs. Valid values for `type` are listed above. Returns an `EventSubscription`.

#### Properties

##### `currentState`

```typescript
static currentState: AppStateStatus;
```

## Platform

### Example

***

### Reference

### Properties

#### `constants`

```typescript
static constants: PlatformConstants;
```

Returns an object containing all common and specific platform-related constants.

**Properties:**

|Name|Type|Optional|Description|
|-|-|-|-|
|isTesting|boolean|No||
|reactNativeVersion|object|No|Information about React Native version. Keys are `major`, `minor`, `patch` with optional `prerelease` and values are `number`s.|
|VersionAndroid|number|No|OS version constant specific to Android.|
|ReleaseAndroid|string|No||
|SerialAndroid|string|No|Hardware serial number of an Android device.|
|FingerprintAndroid|string|No|A unique identifier for the build.|
|ModelAndroid|string|No|The end-user-visible name for the Android device.|
|BrandAndroid|string|No|The consumer-visible brand associated with the product/hardware.|
|ManufacturerAndroid|string|No|The manufacturer of the Android device.|
|ServerHostAndroid|string|Yes||
|uiModeAndroid|string|No|Possible values: `'car'`, `'desk'`, `'normal'`,`'tv'`, `'watch'` and `'unknown'`. Read more about Android ModeType.|
|forceTouchAvailableiOS|boolean|No|Indicates the availability of 3D Touch on a device.|
|interfaceIdiomiOS|string|No|The interface type for the device. Read more about UIUserInterfaceIdiom.|
|osVersioniOS|string|No|OS version constant specific to iOS.|
|systemNameiOS|string|No|OS name constant specific to iOS.|

***

#### `isPad`iOS

```typescript
static isPad: boolean;
```

Returns a boolean indicating if the device is an iPad.

|Type|
|-|
|boolean|

***

#### `isTV`

```typescript
static isTV: boolean;
```

Returns a boolean indicating if the device is a TV.

|Type|
|-|
|boolean|

***

#### `isVision`

```typescript
static isVision: boolean;
```

Returns a boolean indicating if the device is an Apple Vision. Note that for Apple Vision Pro (Designed for iPad), `isVision` will be `false`, but `isPad` will be `true`.

|Type|
|-|
|boolean|

***

#### `isTesting`

```typescript
static isTesting: boolean;
```

Returns a boolean indicating if the application is running in Developer Mode with the testing flag set.

|Type|
|-|
|boolean|

***

#### `OS`

```typescript
static OS: 'android' | 'ios';
```

Returns a string representing the current operating system.

|Type|
|-|
|enum(`'android'`, `'ios'`)|

***

#### `Version`

```typescript
static Version: 'number' | 'string';
```

Returns the version of the OS, as either a number for Android or a string for iOS.

|Type|
|-|
|numberAndroid\*\*\*stringiOS|

### Methods

#### `select()`

```typescript
static select<T>(config: Record<string, T>): T;
```

Returns the most fitting value for the platform you are currently running on.

##### Parameters:

|Name|Type|Required|Description|
|-|-|-|-|
|config|object|Yes|See configuration description below.|

The `select` method returns the most appropriate value based on the current platform. If running on a phone, keys for `android` and `ios` take precedence. If these are not specified, the `native` key is used, followed by the `default` key.

The `config` parameter is an object with the following keys:

- `android`: any
- `ios`: any
- `native`: any
- `default`: any

**Example usage:**

```typescript
import { Platform, StyleSheet } from "react-native"

const styles = StyleSheet.create({
  container: {
    flex: 1,
    ...Platform.select({
      android: {
        backgroundColor: "green",
      },
      ios: {
        backgroundColor: "red",
      },
      default: {
        // other platforms, web for example
        backgroundColor: "blue",
      },
    }),
  },
})
```

This results in a container with `flex: 1` on all platforms. It has a green background color on Android, red on iOS, and blue on other platforms.

Since the value of the corresponding platform key can be of type `any`, the `select` method can also return platform-specific components:

```typescript
const Component = Platform.select({
  ios: () => require('ComponentIOS'),
  android: () => require('ComponentAndroid'),
})();

<Component />;
```

```typescript
const Component = Platform.select({
  native: () => require('ComponentForNative'),
  default: () => require('ComponentForWeb'),
})();

<Component />;
```

## Using TypeScript

TypeScript enhances JavaScript by adding type definitions. New React Native projects target TypeScript by default, but also support JavaScript and Flow.

### Getting Started with TypeScript

React Native CLI or popular templates like Ignite create new projects using TypeScript by default.

TypeScript can be used with Expo, which provides TypeScript templates or prompts for automatic installation and configuration when a `.ts` or `.tsx` file is added to your project.

```shell
npx create-expo-app --template
```

### Adding TypeScript to an Existing Project

1. Install TypeScript, types, and ESLint plugins:

   - **npm**

     ```shell
     npm install -D typescript @react-native/typescript-config @types/jest @types/react @types/react-test-renderer
     ```

   - **Yarn**
     ```shell
     yarn add --dev typescript @react-native/typescript-config @types/jest @types/react @types/react-test-renderer
     ```

   > Note: This command installs the latest versions of dependencies. You may need to adjust versions to match existing packages in your project using tools like React Native Upgrade Helper.

1. Create a `tsconfig.json` file at the root of your project:

   ```json
   {
     "extends": "@react-native/typescript-config"
   }
   ```

1. Rename a JavaScript file to use `.tsx`.

   > Keep the `./index.js` entrypoint file unchanged to avoid bundling issues in production builds.

1. Run `tsc` for type-checking:

   - **npm**

     ```shell
     npx tsc
     ```

   - **Yarn**
     ```shell
     yarn tsc
     ```

### Using JavaScript Instead of TypeScript

React Native defaults to TypeScript, but `.jsx` files are treated as JavaScript and won't be type-checked. JavaScript modules can still be imported by TypeScript modules and vice versa.

### How TypeScript and React Native Work

TypeScript sources are transformed by Babel during bundling. It's recommended to use the TypeScript compiler only for type checking, which is `tsc`'s default behavior in new applications. Existing TypeScript code ported to React Native may require adjustments when using Babel instead of TypeScript.

### Example: React Native + TypeScript

You can define interfaces for a React Component's Props and State using `React.Component<Props, State>`, enabling type-checking and editor auto-completion:

```tsx
import { useState } from "react"
import { Button, StyleSheet, Text, View } from "react-native"

export type Props = {
  name: string
  baseEnthusiasmLevel?: number
}

function Hello({ name, baseEnthusiasmLevel = 0 }: Props) {
  const [enthusiasmLevel, setEnthusiasmLevel] = useState(baseEnthusiasmLevel)

  const onIncrement = () => setEnthusiasmLevel(enthusiasmLevel + 1)
  const onDecrement = () =>
    setEnthusiasmLevel(enthusiasmLevel > 0 ? enthusiasmLevel - 1 : 0)

  const getExclamationMarks = (numChars: number) =>
    numChars > 0 ? Array(numChars + 1).join("!") : ""

  return (
    <View style={styles.container}>
      <Text style={styles.greeting}>
        Hello {name}
        {getExclamationMarks(enthusiasmLevel)}
      </Text>
      <View>
        <Button
          title="Increase enthusiasm"
          accessibilityLabel="increment"
          onPress={onIncrement}
          color="blue"
        />
        <Button
          title="Decrease enthusiasm"
          accessibilityLabel="decrement"
          onPress={onDecrement}
          color="red"
        />
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
  },
  greeting: {
    fontSize: 20,
    fontWeight: "bold",
    margin: 16,
  },
})

export default Hello
```

Explore more syntax in the TypeScript playground.

### Where to Find Useful Advice

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- React's documentation on TypeScript
- React + TypeScript Cheatsheets for an overview of using React with TypeScript

### Using Custom Path Aliases with TypeScript

To use custom path aliases, configure both Babel and TypeScript:

1. Update `tsconfig.json` to include custom path mappings:

   ```json
   {
     "extends": "@react-native/typescript-config",
     "compilerOptions": {
       "baseUrl": ".",
       "paths": {
         "*": ["src/*"],
         "tests": ["tests/*"],
         "@components/*": ["src/components/*"]
       }
     }
   }
   ```

1. Install `babel-plugin-module-resolver`:

   - **npm**

     ```shell
     npm install --save-dev babel-plugin-module-resolver
     ```

   - **Yarn**
     ```shell
     yarn add --dev babel-plugin-module-resolver
     ```

1. Configure `babel.config.js`:

   ```json
   {
     "presets": ["module:metro-react-native-babel-preset"],
     "plugins": [
       [
         "module-resolver",
         {
           "root": ["./src"],
           "extensions": [
             ".ios.js",
             ".android.js",
             ".js",
             ".ts",
             ".tsx",
             ".json"
           ],
           "alias": {
             "tests": ["./tests/"],
             "@components": "./src/components"
           }
         }
       ]
     ]
   }
   ```

## VirtualizedList

The `VirtualizedList` component serves as a foundational implementation for more user-friendly components like `<FlatList>` and `<SectionList>`. It is particularly useful when additional flexibility is required, such as working with immutable data structures instead of plain arrays.

Virtualization significantly enhances memory efficiency and performance in handling large lists by maintaining only a finite number of active items within the render window. Items outside this window are replaced with appropriately sized blank spaces. The size of this window dynamically adjusts based on scrolling behavior, rendering items incrementally at low priority if they are far from the visible area or at high priority otherwise to minimize blank space visibility.

### Example

- TypeScript
- JavaScript

#### Caveats:

- Internal state is not preserved when content scrolls out of the render window. Ensure all data is captured within item data or external stores like Flux, Redux, or Relay.
- As a `PureComponent`, it will not re-render if props are shallow-equal. Ensure that everything your `renderItem` function depends on is passed as a prop (e.g., `extraData`) and is not strictly equal after updates to ensure UI updates on changes. This includes the `data` prop and parent component state.
- To maintain memory constraints and enable smooth scrolling, content is rendered asynchronously offscreen. This may result in faster-than-fill-rate scrolling revealing blank content temporarily. This tradeoff can be adjusted per application needs, with ongoing improvements being made behind the scenes.
- By default, the list looks for a `key` prop on each item to use as the React key. Alternatively, you can provide a custom `keyExtractor` prop.

### Reference

#### Props

##### ScrollView Props

Inherits ScrollView Props.

##### `data`

Opaque data type passed to `getItem` and `getItemCount` to retrieve items.

- **Type**: any

##### Require `getItem`

```typescript
;(data: any, index: number) => any
```

A generic accessor for extracting an item from any sort of data blob.

- **Type**: function

##### Require `getItemCount`

```typescript
;(data: any) => number
```

Determines how many items are in the data blob.

- **Type**: function

##### Require `renderItem`

```typescript
(info: any) => ?React.Element<any>
```

Takes an item from `data` and renders it into the list.

- **Type**: function

##### `CellRendererComponent`

Customizes how cells rendered by `renderItem`/`ListItemComponent` are wrapped within the underlying ScrollView. This component must accept event handlers notifying VirtualizedList of changes within the cell.

- **Type**: `React.ComponentType<CellRendererProps>`

##### `ItemSeparatorComponent`

Rendered between each item, excluding the top and bottom. By default, `highlighted` and `leadingItem` props are provided. `renderItem` provides `separators.highlight`/`unhighlight` to update the `highlighted` prop, with custom props added via `separators.updateProps`. Can be a React Component (e.g., `SomeComponent`) or a React element (e.g., `<SomeComponent />`).

- **Type**: component, function, element

##### `ListEmptyComponent`

Rendered when the list is empty. Can be a React Component (e.g., `SomeComponent`) or a React element (e.g., `<SomeComponent />`).

- **Type**: component, element

##### `ListItemComponent`

Each data item is rendered using this element. Can be a React Component Class or a render function.

- **Type**: component, function

##### `ListFooterComponent`

Rendered at the bottom of all items. Can be a React Component (e.g., `SomeComponent`) or a React element (e.g., `<SomeComponent />`).

- **Type**: component, element

##### `ListFooterComponentStyle`

Styling for internal View for `ListFooterComponent`.

- **Type**: ViewStyleProp
- **Required**: No

##### `ListHeaderComponent`

Rendered at the top of all items. Can be a React Component (e.g., `SomeComponent`) or a React element (e.g., `<SomeComponent />`).

- **Type**: component, element

##### `ListHeaderComponentStyle`

Styling for internal View for `ListHeaderComponent`.

- **Type**: View Style

##### `debug`

Enables extra logging and visual overlays to aid debugging of usage and implementation, with a significant performance hit.

- **Type**: boolean

##### `disableVirtualization`

> **Deprecated.** Virtualization provides significant performance and memory optimizations by fully unmounting React instances outside the render window. Only disable for debugging purposes.

- **Type**: boolean

##### `extraData`

A marker property to trigger re-rendering since it implements `PureComponent`. If your `renderItem`, `ListEmptyComponent`, or other components depend on external data, pass this as a prop and ensure it changes when the data updates.

##### `flashScrollIndicators()`

```typescript
flashScrollIndicators()
```

##### `getScrollableNode()`

```typescript
getScrollableNode(): any;
```

##### `getScrollRef()`

```typescript
getScrollRef():
  | React.ElementRef<typeof ScrollView>
  | React.ElementRef<typeof View>
  | null;
```

##### `getScrollResponder()`

```typescript
getScrollResponder () => ScrollResponderMixin | null;
```

Provides a handle to the underlying scroll responder. Note that `this._scrollRef` might not be a `ScrollView`, so we need to check that it responds to `getScrollResponder` before calling it.

##### `persistentScrollbar`

- **Type**: bool

##### `progressViewOffset`

Set this when an offset is needed for the loading indicator to show correctly.

- **Type**: number

##### `refreshControl`

A custom refresh control element. When set, it overrides the default `<RefreshControl>` component built internally. The `onRefresh` and `refreshing` props are also ignored. Only works for vertical VirtualizedList.

- **Type**: element

##### `refreshing`

Set this to true while waiting for new data from a refresh.

- **Type**: boolean

##### `removeClippedSubviews`

This may improve scroll performance for large lists.

> Note: May have bugs (missing content) in some circumstances - use at your own risk.

- **Type**: boolean

##### `renderScrollComponent`

```typescript
;(props: object) => element
```

Render a custom scroll component, e.g., with a differently styled `RefreshControl`.

- **Type**: function

##### `scrollToEnd()`

```typescript
scrollToEnd(params?: {animated?: boolean});
```

Scrolls to the end of the content. May be janky without the `getItemLayout` prop.

**Parameters:**

- Name: params
- Type: object

Valid `params` keys are:

- `'animated'` (boolean) - Whether the list should do an animation while scrolling. Defaults to `true`.

##### `scrollToIndex()`

```typescript
scrollToIndex(params: {
  index: number;
  animated?: boolean;
  viewOffset?: number;
  viewPosition?: number;
});
```

Valid `params` consist of:

- `'index'` (number). Required.
- `'animated'` (boolean). Optional.
- `'viewOffset'` (number). Optional.
- `'viewPosition'` (number). Optional.

##### `scrollToItem()`

```typescript
scrollToItem(params: {
  item: ItemT;
  animated?: boolean;
  viewOffset?: number;
  viewPosition?: number;
});
```

Valid `params` consist of:

- `'item'` (Item). Required.
- `'animated'` (boolean). Optional.
- `'viewOffset'` (number). Optional.
- `'viewPosition'` (number). Optional.

##### `scrollToOffset()`

```typescript
scrollToOffset(params: {
  offset: number;
  animated?: boolean;
});
```

Scroll to a specific content pixel offset in the list. Param `offset` expects the offset to scroll to. In case of `horizontal` is true, the offset is the x-value; otherwise, it's the y-value. Param `animated` (`true` by default) defines whether the list should do an animation while scrolling.

##### `viewabilityConfig`

See `ViewabilityHelper.js` for flow type and further documentation.

- **Type**: ViewabilityConfig

##### `viewabilityConfigCallbackPairs`

List of `ViewabilityConfig`/`onViewableItemsChanged` pairs. A specific `onViewableItemsChanged` will be called when its corresponding `ViewabilityConfig`'s conditions are met. See `ViewabilityHelper.js` for flow type and further documentation.

- **Type**: array of ViewabilityConfigCallbackPair

##### `updateCellsBatchingPeriod`

Amount of time between low-priority item render batches, e.g., for rendering items quite a ways off screen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.

- **Type**: number

##### `windowSize`

Determines the maximum number of items rendered outside of the visible area, in units of visible lengths. For example, if your list fills the screen, then `windowSize={21}` (the default) will render the visible screen area plus up to 10 screens above and below the viewport. Reducing this number will decrease memory consumption and may improve performance but increase the chance that fast scrolling reveals momentary blank areas of unrendered content.

- **Type**: number

## RootTag

The `RootTag` serves as an opaque identifier for the native root view in React Native applications. This refers to instances like `ReactRootView` or `RCTRootView` on Android and iOS platforms, respectively. Essentially, it acts as a surface identifier.

### When to Use a RootTag?

For most developers working with React Native, handling `RootTags` might not be necessary. However, they become crucial when an application renders multiple React Native root views, necessitating distinct handling of native API calls for each view. A common scenario is using native navigation where each screen corresponds to a separate React Native root view.

In such setups, every React Native root view is embedded within the platform's navigation component (e.g., `Activity` on Android or `UINavigationViewController` on iOS). This allows developers to utilize platform-specific navigation features like native look and feel and transitions. Interactions with these native navigation APIs can be facilitated through a native module.

For instance, updating a screen’s title bar might involve calling the navigation module's API method `setTitle("Updated Title")`. To specify which screen in the stack should have its title updated, a `RootTag` is required to identify the relevant root view and its container.

Another scenario for using `RootTag` arises when an application needs to attribute JavaScript calls to their native origins based on different root views. A `RootTag` helps differentiate these calls across various surfaces.

### Accessing RootTag

In React Native versions 0.65 and earlier, accessing a `RootTag` was done through a legacy context. With the introduction of Concurrent features in React 18, React Native transitioned to using the latest Context API via `RootTagContext` starting from version 0.66. Version 0.65 supports both the legacy context and the new `RootTagContext`, providing developers time to migrate their code.

#### Accessing RootTag with RootTagContext

```typescript
import { useContext } from "react"
import { RootTagContext } from "react-native"
import NativeAnalytics from "native-analytics"
import NativeNavigation from "native-navigation"

function ScreenA() {
  const rootTag = useContext(RootTagContext)

  const updateTitle = (title: string) => {
    NativeNavigation.setTitle(rootTag, title)
  }

  const handleOneEvent = () => {
    NativeAnalytics.logEvent(rootTag, "one_event")
  }

  // ...
}

class ScreenB extends React.Component {
  static contextType = RootTagContext

  updateTitle(title: string) {
    NativeNavigation.setTitle(this.context, title)
  }

  handleOneEvent() {
    NativeAnalytics.logEvent(this.context, "one_event")
  }

  // ...
}
```

For more information on using the Context API with classes and hooks, refer to the React documentation.

#### Breaking Changes

- **Version 0.65**: The `RootTagContext` was previously named `unstable_RootTagContext`. It has been renamed to `RootTagContext`, so any references in your codebase should be updated accordingly.

- **Version 0.66**: Access via the legacy context for `RootTag` will be removed, with `RootTagContext` taking its place. Developers are encouraged to migrate their usage of `RootTag` to `RootTagContext` starting from version 0.65.

### Future Plans

As React Native's architecture evolves, future updates to `RootTag` aim to maintain its opaque nature and prevent unnecessary complexity in codebases. It is important not to rely on the current implementation where `RootTag` aliases to a number. Developers relying on `RootTags` should monitor version change logs for updates.

## DevSettings Module

The `DevSettings` module provides methods for developers to customize settings during development.

### Reference

#### Methods

##### `addMenuItem()`

```typescript
static addMenuItem(title: string, handler: () => any): void;
```

Adds a custom menu item to the Developer Menu.

**Parameters:**

|Name|Type|
|-|-|
|title|string|
|handler|function|

**Example Usage:**

```typescript
DevSettings.addMenuItem("Show Secret Dev Screen", () => {
  Alert.alert("Showing secret dev screen!")
})
```

##### `reload()`

```typescript
static reload(reason?: string): void;
```

Reloads the application. This can be triggered directly or through user interaction.

**Example Usage:**

```typescript
<Button title="Reload" onPress={() => DevSettings.reload()} />
```

***

### Related Modules

- **AccessibilityInfo**

  - Alert
  - Animated
    - Animated.Value
    - Animated.ValueXY
  - Appearance
  - AppRegistry
  - AppState
  - Dimensions
  - Easing
  - InteractionManager
  - Keyboard
  - LayoutAnimation
  - Linking
  - PanResponder
  - PixelRatio
  - Platform
  - PlatformColor
  - RootTag
  - Share
  - StyleSheet
  - Systrace
  - Transforms
  - Vibration

- **Hooks**

  - useColorScheme
  - useWindowDimensions

- **iOS Specific Modules**

  - ActionSheetIOS
  - DynamicColorIOS
  - Settings

- **Android Specific Modules**
  - BackHandler
  - PermissionsAndroid
  - ToastAndroid

## Share

### Example

- TypeScript
- JavaScript

### Reference

### Methods

```typescript
static share(content: ShareContent, options?: ShareOptions): Promise<any>;
```

This method opens a dialog to share text content.

#### iOS Behavior:

- Returns a `Promise` that resolves with an object containing `action` and `activityType`.
- If the user dismisses the dialog, the `Promise` is resolved with `action` set to `Share.dismissedAction`, while other keys remain undefined.
- Note: Some share options may not appear or function on the iOS simulator.

#### Android Behavior:

- Returns a `Promise` that always resolves with `action` being `Share.sharedAction`.

**Properties:**

|Name|Type|Description|
|-|-|-|
|contentRequired|object|- `message`: A message to share<br>- `url`: A URL to share<br>- iOS: `title`: Title of the message<br>- Android: At least one of `url` or `message` is required.|
|options|object|- Android: `dialogTitle`<br>- iOS: `excludedActivityTypes`, `subject` (a subject for email), `tintColor`, `anchor` (node to anchor the action sheet, used on iPad)|

### Properties

#### `sharedAction`

```typescript
static sharedAction: 'sharedAction';
```

Indicates that the content was successfully shared.

#### `dismissedAction` (iOS)

```typescript
static dismissedAction: 'dismissedAction';
```

Indicates that the dialog has been dismissed.

## React Node Object Type

A React Node can be one of several types:

- **Boolean**: This type is ignored.
- `null` or `undefined`: These are also ignored.
- **Number**
- **String**
- A **React element**, which results from JSX.
- An array containing any of the above types, potentially nested.

***

### Related Object Types

- BoxShadowValue Object Type
- DropShadowValue Object Type
- LayoutEvent Object Type
- PressEvent Object Type
- Rect Object Type
- ViewToken Object Type

***

#### Navigation

- [Previous: PressEvent Object Type](#)
- [Next: Rect Object Type](#)

## StyleSheet

A `StyleSheet` serves as an abstraction similar to CSS StyleSheets. It enhances code quality by:

- Moving styles away from the render function, making the code easier to understand.
- Naming styles adds meaning to low-level components in the render function and encourages reuse.
- In most IDEs, using `StyleSheet.create()` provides static type checking and suggestions for writing valid styles.

### Reference

#### Methods

##### `compose()`

```typescript
static compose(style1: Object, style2: Object): Object | Object[];
```

Combines two styles such that `style2` will override any styles in `style1`. If either style is falsy, the other one is returned without allocating an array. This approach saves allocations and maintains reference equality for PureComponent checks.

##### `create()`

```typescript
static create(styles: Object extends Record<string, ViewStyle | ImageStyle | TextStyle>): Object;
```

An identity function for creating styles. The main practical benefit of using `StyleSheet.create()` is static type checking against native style properties.

##### `flatten()`

```typescript
static flatten(style: Array<Object extends Record<string, ViewStyle | ImageStyle | TextStyle>>): Object;
```

Flattens an array of style objects into one aggregated style object.

##### `setStyleAttributePreprocessor()`

> **WARNING: EXPERIMENTAL.** Breaking changes may occur frequently and will not be reliably announced. The feature might be deleted; use at your own risk.

```typescript
static setStyleAttributePreprocessor(
  property: string,
  process: (propValue: any) => any,
);
```

Sets a function to pre-process a style property value. This is used internally for processing color and transform values. It should only be used if you are certain of its necessity after exploring other options.

#### Properties

##### `absoluteFill`

A common pattern involves creating overlays with position absolute and zero positioning (`position: 'absolute', left: 0, right: 0, top: 0, bottom: 0`). The `absoluteFill` property is used for convenience to reduce duplication of these repeated styles. It can be customized in a StyleSheet.

##### `absoluteFillObject`

For cases where you need `absoluteFill` with slight modifications, `absoluteFillObject` allows customization within a StyleSheet.

##### `hairlineWidth`

Defined as the width of a thin line on the platform, this property is useful for setting the thickness of borders or divisions between elements. It ensures crisp lines by being a round number of pixels and attempts to match the standard width of a thin line on the underlying platform. However, its value may vary across different platforms and screen densities.

A line with `hairlineWidth` might not be visible if your simulator is downscaled.

## Dimensions

`useWindowDimensions` is the recommended API for React components, as it updates automatically with changes to the window's dimensions. This aligns well with the React paradigm.

```typescript
import { Dimensions } from "react-native"
```

To obtain the application window's width and height, use:

```typescript
const windowWidth = Dimensions.get("window").width
const windowHeight = Dimensions.get("window").height
```

> Note: While dimensions are available immediately, they can change due to factors like device rotation or foldable devices. Therefore, rendering logic or styles dependent on these values should call this function on every render instead of caching the value (e.g., using inline styles rather than setting a value in a `StyleSheet`).

For targeting foldable devices or those that can alter screen size or app window size, use the event listener provided by the Dimensions module as demonstrated below.

### Example

### Reference

### Methods

#### `addEventListener()`

```typescript
static addEventListener(
  type: 'change',
  handler: ({
    window,
    screen,
  }: DimensionsValue) => void,
): EmitterSubscription;
```

Add an event handler. Supported events:

- `change`: Triggers when a property within the `Dimensions` object changes. The argument to the event handler is of type `DimensionsValue`.

***

#### `get()`

```typescript
static get(dim: 'window' | 'screen'): ScaledSize;
```

Initial dimensions are set before `runApplication` is called, making them available before any other requires are executed, though they may be updated later.

Example usage:

```typescript
const { height, width } = Dimensions.get("window")
```

**Parameters:**

|Name|Type|Description|
|-|-|-|
|dimRequired|string|The name of the dimension as defined when calling `set`. Returns value for the dimension.|

> Note: On Android, the `window` dimension excludes the size used by the status bar (if not translucent) and bottom navigation bar.

***

### Type Definitions

#### DimensionsValue

**Properties:**

|Name|Type|Description|
|-|-|-|
|window|ScaledSize|Size of the visible Application window.|
|screen|ScaledSize|Size of the device's screen.|

#### ScaledSize

|Type|
|-|
|object|

**Properties:**

|Name|Type|
|-|-|
|width|number|
|height|number|
|scale|number|
|fontScale|number|

## Props

In React Native, most components are customizable through parameters known as `props`, short for properties. These allow developers to tailor component behavior and appearance.

### Example: The Image Component

Consider the basic `Image` component. It uses a prop named `source` to determine which image is displayed:

```typescript
<Image source={pic} />
```

Here, `{pic}` embeds the JavaScript variable `pic` into JSX. Any valid JavaScript expression can be placed within braces in JSX.

### Custom Components with Props

Custom components can also utilize `props`, enabling a single component to serve multiple purposes across an application by varying its properties. This is achieved by referencing `props` within the component's `render` function. Here’s how it works:

#### Example: Greeting Component

Using `name` as a prop allows customization of the `Greeting` component, making it reusable for different greetings.

```typescript
function Greeting(props) {
  return <Text>Hello, {props.name}!</Text>;
}

// Usage in JSX
<Greeting name="Alice" />
```

This example demonstrates how components can be used similarly to Core Components. The ability to create and use custom components is a powerful feature of React.

### View Component

The `View` component acts as a container for other components, aiding in style and layout management:

```typescript
<View>
  <Greeting name="Bob" />
</View>
```

By leveraging `props` along with basic components like `Text`, `Image`, and `View`, developers can construct a variety of static screens. To create dynamic applications that change over time, understanding State is essential.

## Animated.Value

`Animated.Value` is the standard value used for driving animations in a synchronized manner across multiple properties, though it can only be driven by one mechanism at a time. Initiating a new animation or calling `setValue` will halt any ongoing ones.

Typically initialized with `useAnimatedValue(0);` or `new Animated.Value(0);` in class components.

### Reference

#### Methods

##### `setValue()`

```typescript
setValue(value: number): void;
```

Directly sets the value, stopping any running animations and updating all bound properties.

**Parameters:**

- **value**: *number* (Required) - The new value to set.

##### `setOffset()`

```typescript
setOffset(offset: number): void;
```

Applies an offset on top of the current value, useful for adjustments like compensating a pan gesture start.

**Parameters:**

- **offset**: *number* (Required) - The offset value to apply.

##### `flattenOffset()`

```typescript
flattenOffset(): void;
```

Merges the offset into the base value and resets the offset to zero without changing the final output of the value.

##### `extractOffset()`

```typescript
extractOffset(): void;
```

Sets the offset to the base value, resetting the base value to zero while keeping the final output unchanged.

##### `addListener()`

```typescript
addListener(callback: (state: {value: number}) => void): string;
```

Adds an asynchronous listener for observing updates from animations. Returns a string identifier for the listener.

**Parameters:**

- **callback**: *function* (Required) - A function receiving an object with a `value` key set to the new value.

##### `removeListener()`

```typescript
removeListener(id: string): void;
```

Unregisters a listener using the identifier returned by `addListener()`.

**Parameters:**

- **id**: *string* (Required) - The identifier of the listener being removed.

##### `removeAllListeners()`

```typescript
removeAllListeners(): void;
```

Removes all registered listeners.

##### `stopAnimation()`

```typescript
stopAnimation(callback?: (value: number) => void): void;
```

Stops any running animation or tracking. Optionally invokes a callback with the final value, useful for updating state to match the animation position.

**Parameters:**

- **callback**: *function* (Optional) - A function receiving the final value after stopping the animation.

##### `resetAnimation()`

```typescript
resetAnimation(callback?: (value: number) => void): void;
```

Stops any animation and resets the value to its original state. Optionally invokes a callback with the original value.

**Parameters:**

- **callback**: *function* (Optional) - A function receiving the original value after resetting the animation.

##### `interpolate()`

```typescript
interpolate(config: InterpolationConfigType): void;
```

Interpolates the value before updating properties, e.g., mapping 0-1 to 0-10. See `AnimatedInterpolation.js` for details.

**Parameters:**

- **config**: *object* (Required) - Configuration object with keys:
  - **inputRange**: *array of numbers*
  - **outputRange**: *array of numbers or strings*
  - **easing** (optional): *function* returning a number given an input number
  - **extrapolate** (optional): *string* such as 'extend', 'identity', or 'clamp'
  - **extrapolateLeft** (optional): *string* such as 'extend', 'identity', or 'clamp'
  - **extrapolateRight** (optional): *string* such as 'extend', 'identity', or 'clamp'

##### `animate()`

```typescript
animate(animation: Animation, callback: () => void): void;
```

Typically used internally but can be utilized by a custom Animation class.

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|animation|Animation|Yes|See `Animation.js`.|
|callback|function|Yes|Callback function.|

## Systrace

`Systrace` is a standard Android marker-based profiling tool included with the installation of the Android platform-tools package. It visualizes profiled code blocks, which are surrounded by start/end markers, in a colorful chart format. Both the Android SDK and React Native framework provide standard markers that can be visualized using `Systrace`.

### Example

`Systrace` enables marking JavaScript (JS) events with a tag and an integer value. Non-Timed JS events can be captured using EasyProfiler.

### Reference

### Methods

#### `isEnabled()`

```typescript
static isEnabled(): boolean;
```

#### `beginEvent()`

```typescript
static beginEvent(eventName: string | (() => string), args?: EventArgs);
```

Use `beginEvent`/`endEvent` to start and end a profile within the same call stack frame.

#### `endEvent()`

```typescript
static endEvent(args?: EventArgs);
```

#### `beginAsyncEvent()`

```typescript
static beginAsyncEvent(
  eventName: string | (() => string),
  args?: EventArgs,
): number;
```

Use `beginAsyncEvent`/`endAsyncEvent` to start and then end a profile where the end can occur on another thread or outside of the current stack frame. The returned cookie variable should be used as input into the `endAsyncEvent` call.

#### `endAsyncEvent()`

```typescript
static endAsyncEvent(
  eventName: EventName,
  cookie: number,
  args?: EventArgs,
);
```

#### `counterEvent()`

```typescript
static counterEvent(eventName: string | (() => string), value: number);
```

Register the value to the profile name on the systrace timeline.

## Easing

The `Easing` module provides a collection of common easing functions used to create physically believable motion in animations, particularly with `Animated.timing()`.

A visualization of some common easing functions can be found at [easings.net](https://easings.net/).

### Predefined Animations

The `Easing` module offers several predefined animations:

- **Back**: An animation where the object moves slightly backward before proceeding forward.
- **Bounce**: A bouncing effect for animations.
- **Ease**: A basic inertial interaction, akin to an object gradually accelerating.
- **Elastic**: Simulates a spring-like oscillation.

### Standard Functions

The module includes three standard easing functions:

- `linear`
- `quad`
- `cubic`

Additionally, the `poly` function can be used for higher power functions like quartic and quintic.

### Additional Mathematical Functions

Other mathematical functions provided include:

- **Bezier**: Implements a cubic bezier curve.
- **Circle**: Provides a circular easing function.
- **Sin**: Offers a sinusoidal function.
- **Exp**: An exponential function.

#### Helpers to Modify Easing Functions

- `in`: Runs an easing function forwards.
- `out`: Executes an easing function in reverse.
- `inOut`: Symmetrizes any easing function, running it forward for half the duration and backward for the remainder.

### Example Usage

The module can be used with TypeScript or JavaScript.

### Reference Methods

#### Stepping Functions

##### `step0()`

```typescript
static step0(n: number): number;
```

Returns 1 for any positive value of `n`.

##### `step1()`

```typescript
static step1(n: number): number;
```

Returns 1 if `n` is greater than or equal to 1.

#### Linear Function

##### `linear()`

```typescript
static linear(t: number): number;
```

A linear function where position correlates directly with elapsed time.\
[Visualization](https://cubic-bezier.com/#0,0,1,1)

#### Basic Inertial Interaction

##### `ease()`

```typescript
static ease(t: number): number;
```

Simulates an object slowly accelerating to speed.\
[Visualization](https://cubic-bezier.com/#.42,0,1,1)

#### Quadratic Function

##### `quad()`

```typescript
static quad(t: number): number;
```

Position equals the square of elapsed time.\
[Visualization](https://easings.net/#easeInQuad)

#### Cubic Function

##### `cubic()`

```typescript
static cubic(t: number): number;
```

Position equals the cube of elapsed time.\
[Visualization](https://easings.net/#easeInCubic)

#### Power Function

##### `poly(n)`

```typescript
static poly(n: number): (t: number) => number;
```

Position is equal to the Nth power of elapsed time.

- n = 4: [Quartic Visualization](https://easings.net/#easeInQuart)
- n = 5: [Quintic Visualization](https://easings.net/#easeInQuint)

#### Sinusoidal Function

##### `sin()`

```typescript
static sin(t: number): number;
```

[Visualization](https://easings.net/#easeInSine)

#### Circular Function

##### `circle()`

```typescript
static circle(t: number): number;
```

[Visualization](https://easings.net/#easeInCirc)

#### Exponential Function

##### `exp()`

```typescript
static exp(t: number): number;
```

[Visualization](https://easings.net/#easeInExpo)

#### Elastic Interaction

##### `elastic(bounciness)`

```typescript
static elastic(bounciness: number): (t: number) => number;
```

Simulates a spring oscillating back and forth.

- Default bounciness is 1, with slight overshoot.
- Bounciness of 0 results in no overshoot.
- Higher values result in more overshoots.\
  [Visualization](https://easings.net/#easeInElastic)

#### Back Animation

##### `back(s)`

```typescript
static back(s: number): (t: number) => number;
```

Use with `Animated.parallel()` to create an effect where the object moves slightly backward at the start of the animation.

#### Bouncing Effect

##### `bounce()`

```typescript
static bounce(t: number): number;
```

Provides a basic bouncing effect.\
[Visualization](https://easings.net/#easeInBounce)

#### Cubic Bezier Curve

##### `bezier(x1, y1, x2, y2)`

```typescript
static bezier(x1: number, y1: number, x2: number, y2: number): (t: number) => number;
```

Equivalent to CSS Transitions' `transition-timing-function`.\
[Bezier Curve Tool](https://cubic-bezier.com/)

#### Modify Easing Functions

##### `in(easing)`

```typescript
static in(easing: (t: number) => number): (t: number) => number;
```

Runs an easing function forwards.

##### `out(easing)`

```typescript
static out(easing: (t: number) => number): (t: number) => number;
```

Executes an easing function in reverse.

##### `inOut(easing)`

```typescript
static inOut(easing: (t: number) => number): (t: number) => number;
```

Symmetrizes any easing function, running it forward for half the duration and backward for the remainder.

## Vibration

This section describes how to make a device vibrate.

### Example

For Android applications, it is necessary to request the `android.permission.VIBRATE` permission. This can be done by adding `<uses-permission android:name="android.permission.VIBRATE"/>` in the `AndroidManifest.xml`.

On iOS devices, vibration functionality is achieved using the `AudioServicesPlaySystemSound(kSystemSoundID_Vibrate)` method.

***

### Reference

#### Methods

##### `cancel()`

```typescript
static cancel(): void;
```

This method stops any ongoing vibrations that were initiated with a repeating pattern by calling `vibrate()`.

***

##### `vibrate()`

```typescript
static vibrate(
  pattern?: number | number[],
  repeat?: boolean
): void;
```

Initiates a vibration for a specified duration. By default, the vibration lasts for 400 milliseconds on Android. On iOS, this duration is fixed at approximately 400 milliseconds.

The `vibrate()` method can accept a `pattern` argument, which is an array of numbers representing time in milliseconds. If `repeat` is set to true, the vibration pattern will continue looping until `cancel()` is invoked.

- **On Android:** The odd indices in the `pattern` array specify the duration of each vibration, while even indices indicate the pause between vibrations.
- **On iOS:** All numbers in the `pattern` array represent the pause durations since the vibration length remains constant.

**Parameters:**

|Name|Type|Default|Description|
|-|-|-|-|
|pattern|number \| number\[]|`400`|Specifies either a single duration for vibration in milliseconds or an array of times.|
|repeat|boolean|`false`|If true, the vibration pattern will continue until `cancel()` is called.|

## Animated.ValueXY

A 2D value designed for driving 2D animations such as pan gestures. It shares a similar API with the standard `Animated.Value`, but it is multiplexed, containing two regular `Animated.Value` instances internally.

### Example

*Example content not provided.*

### Reference

#### Methods

##### `setValue()`

```typescript
setValue(value: { x: number; y: number }): void;
```

Directly sets the value. This action stops any ongoing animations and updates all bound properties.

**Parameters:**

- **value**: `{x: number; y: number}` (Required)\
  The new value to set, consisting of `x` and `y` coordinates.

##### `setOffset()`

```typescript
setOffset(offset: { x: number; y: number }): void;
```

Applies an offset on top of the current value. This can be useful for compensating initial positions in gestures like panning.

**Parameters:**

- **offset**: `{x: number; y: number}` (Required)\
  The offset to apply, consisting of `x` and `y` coordinates.

##### `flattenOffset()`

```typescript
flattenOffset(): void;
```

Merges the current offset into the base value and resets the offset to zero. The final output remains unchanged.

##### `extractOffset()`

```typescript
extractOffset(): void;
```

Transfers the current offset value to the base value, resetting the base value to zero. The final output remains unchanged.

##### `addListener()`

```typescript
addListener(callback: (value: { x: number; y: number }) => void): string;
```

Adds an asynchronous listener to observe updates from animations. This is useful as there's no way to synchronously read the value due to potential native driving.

**Returns:**\
A string identifier for the listener.

**Parameters:**

- **callback**: `function` (Required)\
  A function that receives an object with a `value` key set to the new value.

##### `removeListener()`

```typescript
removeListener(id: string): void;
```

Unregisters a listener using the identifier returned by `addListener()`.

**Parameters:**

- **id**: `string` (Required)\
  The identifier of the listener being removed.

##### `removeAllListeners()`

```typescript
removeAllListeners(): void;
```

Removes all registered listeners.

##### `stopAnimation()`

```typescript
stopAnimation(callback?: (value: { x: number; y: number }) => void): void;
```

Stops any running animation or tracking. The optional `callback` is invoked with the final value, useful for updating state to match the animation position.

**Parameters:**

- **callback**: `function` (Optional)\
  A function that receives the final value after stopping the animation.

##### `resetAnimation()`

```typescript
resetAnimation(callback?: (value: { x: number; y: number }) => void): void;
```

Stops any running animation and resets the value to its original state. The optional `callback` is invoked with the original value.

**Parameters:**

- **callback**: `function` (Optional)\
  A function that receives the original value after resetting the animation.

##### `getLayout()`

```typescript
getLayout(): { left: Animated.Value; top: Animated.Value };
```

Converts `{x, y}` into `{left, top}` for use in style properties. For example:

```typescript
style={this.state.anim.getLayout()}
```

##### `getTranslateTransform()`

```typescript
getTranslateTransform(): [{ translateX: Animated.Value }, { translateY: Animated.Value }];
```

Converts `{x, y}` into a usable translation transform. For example:

```typescript
style={{
  transform: this.state.anim.getTranslateTransform()
}}
```

## useColorScheme Hook

The `useColorScheme` hook from 'react-native' is designed to provide and subscribe to updates regarding color schemes via the `Appearance` module. It returns the current user's preferred color scheme, which can change based on direct actions like theme selection in device settings or automatically according to a schedule (e.g., switching between light and dark themes with day/night cycles).

### Supported Color Schemes

- `"light"`: Indicates that the user prefers a light color theme.
- `"dark"`: Indicates that the user prefers a dark color theme.
- `null`: No preferred color scheme has been indicated by the user.

### Example Usage

A comprehensive example demonstrating how to use this hook, along with React context for supporting both light and dark themes in an application, can be found in `AppearanceExample.js`.

## useWindowDimensions

```typescript
import { useWindowDimensions } from "react-native"
```

`useWindowDimensions` is a hook that automatically updates its values when there are changes in screen size or font scale. It provides the current window's width and height, which can be accessed as follows:

```typescript
const { height, width } = useWindowDimensions()
```

### Example

### Properties

#### `fontScale`

```typescript
useWindowDimensions().fontScale
```

This property indicates the current font size scale. Some operating systems allow users to adjust their font sizes for better readability. This value reflects any such adjustments.

***

#### `height`

```typescript
useWindowDimensions().height
```

Represents the height in pixels of the window or screen that your application occupies.

***

#### `scale`

```typescript
useWindowDimensions().scale
```

This property provides the pixel ratio of the device. Possible values include:

- `1`: One point equals one pixel (commonly PPI/DPI of 96, 76 on some platforms).
- `2` or `3`: Indicates a Retina or high DPI display.

***

#### `width`

```typescript
useWindowDimensions().width
```

Indicates the width in pixels of the window or screen that your application occupies.

## Keyboard

The `Keyboard` module provides functionality for controlling and responding to keyboard events in your application. It allows you to listen for native keyboard notifications, dismiss the keyboard, and synchronize layout animations with keyboard movements.

### Usage

- **Listening for Events**: Use the `addListener()` method to connect a JavaScript function to specific native keyboard notification events.
- **Dismissing Keyboard**: The `dismiss()` method can be used to hide the active keyboard and remove focus from input elements.
- **Synchronizing Layouts**: Utilize `scheduleLayoutAnimation` to align layout changes with keyboard movements, particularly useful for adjusting text inputs or accessory views.
- **Checking Visibility**: Use `isVisible()` to determine if the keyboard is currently visible.
- **Retrieving Metrics**: The `metrics()` method provides details about the soft-keyboard's size and position when it is visible.

### Reference

#### Methods

##### `addListener()`

```typescript
static addListener(
  eventType: KeyboardEventName,
  listener: KeyboardEventListener
): EmitterSubscription;
```

Connects a JavaScript function to a specified native keyboard notification event. Returns the reference to the listener.

**Parameters:**

|Name|Type|Description|
|-|-|-|
|`eventType`|string|Identifies the event you're listening for. See list below.|
|`listener`|function|The callback function executed when the event occurs.|

**Supported Events:**

- `keyboardWillShow`
- `keyboardDidShow`
- `keyboardWillHide`
- `keyboardDidHide`
- `keyboardWillChangeFrame`
- `keyboardDidChangeFrame`

> **Note:** On Android, only `keyboardDidShow` and `keyboardDidHide` events are available. These events will not trigger on Android 10 or below if the activity's `android:windowSoftInputMode` is set to `adjustNothing`.

##### `dismiss()`

```typescript
static dismiss();
```

Dismisses the active keyboard and removes focus from input elements.

##### `scheduleLayoutAnimation`

```typescript
static scheduleLayoutAnimation(event: KeyboardEvent);
```

Synchronizes layout changes with keyboard movements, useful for adjusting text inputs or other accessory views.

##### `isVisible()`

```typescript
static isVisible(): boolean;
```

Returns a boolean indicating whether the keyboard is currently visible.

##### `metrics()`

```typescript
static metrics(): KeyboardMetrics | undefined;
```

Provides the dimensions and position of the soft-keyboard if it is visible. Returns `undefined` if the keyboard is not visible.

## PermissionsAndroid

### Project with Native Code Required

This section is applicable only for projects that include native code. If you are using the managed Expo workflow, refer to the Expo documentation's guide on Permissions for alternatives.

`PermissionsAndroid` provides access to Android M's new permissions model. "Normal" permissions are granted by default upon application installation if they appear in `AndroidManifest.xml`. However, "dangerous" permissions require a dialog prompt. Use this module for those permissions.

On devices with SDK versions below 23, permissions listed in the manifest are automatically granted. Thus, `check` will always return `true`, and `request` will resolve to `PermissionsAndroid.RESULTS.GRANTED`.

If a user has previously denied a permission that you request, the OS advises your app to show a rationale for needing the permission. The optional `rationale` argument displays a dialog only if necessary; otherwise, the standard permission prompt appears.

### Example

#### Permissions Requiring User Prompt

Available as constants under `PermissionsAndroid.PERMISSIONS`:

- `READ_CALENDAR`: `'android.permission.READ_CALENDAR'`
- `WRITE_CALENDAR`: `'android.permission.WRITE_CALENDAR'`
- `CAMERA`: `'android.permission.CAMERA'`
- `READ_CONTACTS`: `'android.permission.READ_CONTACTS'`
- `WRITE_CONTACTS`: `'android.permission.WRITE_CONTACTS'`
- `GET_ACCOUNTS`: `'android.permission.GET_ACCOUNTS'`
- `ACCESS_FINE_LOCATION`: `'android.permission.ACCESS_FINE_LOCATION'`
- `ACCESS_COARSE_LOCATION`: `'android.permission.ACCESS_COARSE_LOCATION'`
- `ACCESS_BACKGROUND_LOCATION`: `'android.permission.ACCESS_BACKGROUND_LOCATION'`
- `RECORD_AUDIO`: `'android.permission.RECORD_AUDIO'`
- `READ_PHONE_STATE`: `'android.permission.READ_PHONE_STATE'`
- `CALL_PHONE`: `'android.permission.CALL_PHONE'`
- `READ_CALL_LOG`: `'android.permission.READ_CALL_LOG'`
- `WRITE_CALL_LOG`: `'android.permission.WRITE_CALL_LOG'`
- `ADD_VOICEMAIL`: `'com.android.voicemail.permission.ADD_VOICEMAIL'`
- `USE_SIP`: `'android.permission.USE_SIP'`
- `PROCESS_OUTGOING_CALLS`: `'android.permission.PROCESS_OUTGOING_CALLS'`
- `BODY_SENSORS`: `'android.permission.BODY_SENSORS'`
- `SEND_SMS`: `'android.permission.SEND_SMS'`
- `RECEIVE_SMS`: `'android.permission.RECEIVE_SMS'`
- `READ_SMS`: `'android.permission.READ_SMS'`
- `RECEIVE_WAP_PUSH`: `'android.permission.RECEIVE_WAP_PUSH'`
- `RECEIVE_MMS`: `'android.permission.RECEIVE_MMS'`
- `READ_EXTERNAL_STORAGE`: `'android.permission.READ_EXTERNAL_STORAGE'`
- `WRITE_EXTERNAL_STORAGE`: `'android.permission.WRITE_EXTERNAL_STORAGE'`
- `BLUETOOTH_CONNECT`: `'android.permission.BLUETOOTH_CONNECT'`
- `BLUETOOTH_SCAN`: `'android.permission.BLUETOOTH_SCAN'`
- `BLUETOOTH_ADVERTISE`: `'android.permission.BLUETOOTH_ADVERTISE'`
- `ACCESS_MEDIA_LOCATION`: `'android.permission.ACCESS_MEDIA_LOCATION'`
- `ACCEPT_HANDOVER`: `'android.permission.ACCEPT_HANDOVER'`
- `ACTIVITY_RECOGNITION`: `'android.permission.ACTIVITY_RECOGNITION'`
- `ANSWER_PHONE_CALLS`: `'android.permission.ANSWER_PHONE_CALLS'`
- `READ_PHONE_NUMBERS`: `'android.permission.READ_PHONE_NUMBERS'`
- `UWB_RANGING`: `'android.permission.UWB_RANGING'`
- `BODY_SENSORS_BACKGROUND`: `'android.permission.BODY_SENSORS_BACKGROUND'`
- `READ_MEDIA_IMAGES`: `'android.permission.READ_MEDIA_IMAGES'`
- `READ_MEDIA_VIDEO`: `'android.permission.READ_MEDIA_VIDEO'`
- `READ_MEDIA_AUDIO`: `'android.permission.READ_MEDIA_AUDIO'`
- `POST_NOTIFICATIONS`: `'android.permission.POST_NOTIFICATIONS'`
- `NEARBY_WIFI_DEVICES`: `'android.permission.NEARBY_WIFI_DEVICES'`
- `READ_VOICEMAIL`: `'com.android.voicemail.permission.READ_VOICEMAIL'`
- `WRITE_VOICEMAIL`: `'com.android.voicemail.permission.WRITE_VOICEMAIL'`

#### Result Strings for Requesting Permissions

Available as constants under `PermissionsAndroid.RESULTS`:

- `GRANTED`: `'granted'`
- `DENIED`: `'denied'`
- `NEVER_ASK_AGAIN`: `'never_ask_again'`

### Reference

#### Methods

##### `check()`

```typescript
static check(permission: string): Promise<boolean>;
```

Returns a promise resolving to a boolean indicating whether the specified permission has been granted.

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|permission|string|Yes|The permission to check for.|

##### `request()`

```typescript
static request(
  permission: string,
  rationale?: {
    title: string;
    message: string;
    buttonPositive: string;
    buttonNegative?: string;
    buttonNeutral?: string;
  }
): Promise<string>;
```

Prompts the user to enable a permission and returns a promise resolving to a string indicating whether the user allowed or denied the request, or does not want to be asked again.

If `rationale` is provided, this function checks with the OS whether it is necessary to show a dialog explaining why the permission is needed (<https://developer.android.com/training/permissions/requesting.html#explain>) and then shows the system permission dialog.

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|permission|string|Yes|The permission to request.|
|rationale|object|No|See `rationale` below.|

**Rationale:**

|Name|Type|Required|Description|
|-|-|-|-|
|title|string|Yes|The title of the dialog.|
|message|string|Yes|The message of the dialog.|
|buttonPositive|string|Yes|The text of the positive button.|
|buttonNegative|string|No|The text of the negative button.|
|buttonNeutral|string|No|The text of the neutral button.|

##### `requestMultiple()`

```typescript
static requestMultiple(
  permissions: string[]
): Promise<{ [key in string]: string }>;
```

Prompts the user to enable multiple permissions in the same dialog and returns an object with the permissions as keys and strings as values indicating whether the user allowed or denied the request, or does not want to be asked again.

**Parameters:**

|Name|Type|Required|Description|
|-|-|-|-|
|permissions|array|Yes|Array of permissions to request.|

## Signing Your Android Application for Distribution

Android mandates that applications must be digitally signed with a certificate before installation. For distribution via the Google Play Store, an app needs to be signed with a release key used for all future updates. Since 2017, Google Play can manage signing releases automatically through App Signing by Google Play. However, prior to uploading your application binary to Google Play, it must be signed with an upload key.

### Generating an Upload Key

#### Windows

On Windows, `keytool` should be executed from `C:\Program Files\Java\jdkx.x.x_x\bin` as administrator:

```shell
keytool -genkeypair -v -storetype PKCS12 -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```

This command prompts for passwords and Distinguished Name fields, generating a keystore file named `my-upload-key.keystore`. The key is valid for 10,000 days. Remember the alias used.

#### macOS

On macOS, locate your JDK bin folder using:

```shell
/usr/libexec/java_home
```

Navigate to that directory with `cd /your/jdk/path` and run:

```shell
sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```

**Caution:** Keep the keystore file private. If lost or compromised, follow recovery instructions.

### Setting Up Gradle Variables

1. Place `my-upload-key.keystore` in the `android/app` directory.
1. Edit `~/.gradle/gradle.properties` or `android/gradle.properties`, adding:

```properties
MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore
MYAPP_UPLOAD_KEY_ALIAS=my-key-alias
MYAPP_UPLOAD_STORE_PASSWORD=*****
MYAPP_UPLOAD_KEY_PASSWORD=*****
```

These are global Gradle variables for signing the app. Use `~/.gradle/gradle.properties` to avoid checking them into git.

### Adding Signing Config to Your App's Gradle Config

Edit `android/app/build.gradle` and add:

```groovy
...
android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            if (project.hasProperty('MYAPP_UPLOAD_STORE_FILE')) {
                storeFile file(MYAPP_UPLOAD_STORE_FILE)
                storePassword MYAPP_UPLOAD_STORE_PASSWORD
                keyAlias MYAPP_UPLOAD_KEY_ALIAS
                keyPassword MYAPP_UPLOAD_KEY_PASSWORD
            }
        }
    }
    buildTypes {
        release {
            ...
            signingConfig signingConfigs.release
        }
    }
}
...
```

### Generating the Release AAB

Run:

```shell
npx react-native build-android --mode=release
```

This bundles JavaScript into an Android App Bundle (AAB). Ensure `gradle.properties` does not include `org.gradle.configureondemand=true`.

The generated AAB is located at `android/app/build/outputs/bundle/release/app-release.aab`, ready for Google Play upload. Configure App Signing by Google Play on the Google Play Console.

### Testing the Release Build

Uninstall any previous app versions and install using:

```shell
npm run android -- --mode="release"
```

or

```shell
yarn android --mode release
```

Ensure signing is set up as described above. Terminate running bundler instances since all code is bundled in the APK's assets.

### Publishing to Other Stores

The default APK includes native code for `x86`, `x86_64`, `ARMv7a`, and `ARM64-v8a`. For smaller APKs, create separate APKs per CPU:

```groovy
android {
    splits {
        abi {
            reset()
            enable true
            universalApk false
            include "armeabi-v7a", "arm64-v8a", "x86", "x86_64"
        }
    }
}
```

Upload to markets supporting device targeting. For others, set `universalApk true` for a universal APK.

### Enabling Proguard (Optional)

Proguard reduces APK size by stripping unused React Native Java bytecode:

```groovy
/**
 * Run Proguard to shrink the Java bytecode in release builds.
 */
def enableProguardInReleaseBuilds = true
```

Test thoroughly if enabled, as it may require specific configurations for native libraries.

### Migrating Old Android React Native Apps

For apps not using App Signing by Google Play, generate a new upload key and update `android/app/build.gradle` to use this key. Follow Google Play Help instructions to send your original release key to Google Play.

### Default Permissions

The `INTERNET` permission is added by default. The `SYSTEM_ALERT_WINDOW` permission is included in debug mode but removed in production.
